unit uAxPEG;
{Copied from Ver 11.1\ASBPegRest_XE8}
{Copied from Ver 11.2\ASBPegRest_XE8}
{PEG unit}
interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Vcl.Graphics, Vcl.Controls, Forms, db,
  Vcl.Dialogs, Vcl.Grids, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.ComCtrls,Clipbrd, dateutils, uXDS,
  uStructDef,uParse,XMLDoc,XMLIntf,StrUtils,uPublishToRMQ,
  // Delphi XE3 has a DBXJson object for JSON support but above that version (>XE3) DBXJson is deprecated and JSON object is used.
{$IF CompilerVersion > 24.0}
      JSON
{$ELSE}
      DBXJson
{$IFEND}
      ;

type
  TGetFieldValue = Function(FieldName: String; RowNo: integer):String of object;
  TSDEvaluateExpr = function(sExpression : String):String of object;
  TSDRegVarToParser = Procedure(pVarname, pVarDType, pVarValue: String) of object;

  TAxPEG = class
  private
    sPEGGlobalKeyValue,sPEGTask_EventDateTime,sCurMakeTasksParent,sAxGroupWithPriorIndex : String;
    bIsCurrentPEGTask,bIsPEGV2,bIsFirstMake,bCurMakeIsSubTask,bIsParentTask : Boolean;
    bAddPublishRMQObjtoList,bIsAmendment,bIsPEGAttached,pegLastApproved,bPEGRejectedOrReturned,bPEGWithdrawn : Boolean;
    PublishMsgObjList: TList;
    sCurrentPEGInitiator : String;
    bautoapproval,bIsTaskNotification : Boolean;

    function AddRecToAxActiveTasks(pPegGetActiveXDS: TXDS; sPriorIdx,
      sPriorTask: String): String;
    Function AddRecToAxActiveTaskStatus(inpXDS: TXDS; pTaskId,
      pStatus: String):String;
    procedure AddRecToAxProcess(inpXDS: TXDS; pTaskId, pStatus: String);
    function CanInitiatePEG(pProcessName, pTaskName, pIndexNo,
      pKeyValue: String): Boolean;

    function FillDynamicParams(pInputStr: String): String;
    //function GetActorFilter(pActorName: String): String;
    Function GetActorFilter(pAssignToActor : String):String;
    function getDisplayData: String;
    function GetKeyField: String;
    function GetNextTask(pCurTaskName, pCurProcessName, pTransid: String): TXDS;
    function GetReportingManager(sUserName: String): String;
    function GetTaskId(pTransId, PProcessName, pTaskName, pTaskType, pKeyValue,
      pIndexNo: String): String;
    function MakeTypeRecordExistsInAxActiveTasks(pProcessName, pTaskName,
      pIndexNo, pKeyValue: String): Boolean;
    procedure PegInit(pPegXDS: TXDS);
    procedure UpdatePEGStatusInAxPegTransTable(inpXDS: TXDS; pStatus: String);
    procedure WriteStream(fname, table, where: String; stm: TStringStream);
    function GetInitiator(pProcessName, pTaskName, pTransid,
      pKeyValue: String): String;
    function GetSameIndexTaskNames(pCurProcessName, pCurTaskname,
      pCurIndex: String): String;
    function IsSameIndexTaskExistsAndActive(pCurProcessName, pTaskname,
      pCurIndex: String): Boolean;
    procedure PublishMessageToRMQ(pTaskId,pTransId,pProcessName,pTaskName,
      pKeyField,pKeyValue : String;bRemind,bEscalate,bNotification,bUseBusinessdateLogic : Boolean);

    function GetProcessTable(pProcessName: String): String;
    function GetDisplayTextDetails(pTaskId: String): String;
    function IsPEGV2Process(pProcessName: String): Boolean;

    //PEG V2 starts

    procedure CheckAxProcessDef_PEGV2;
    procedure EVALProcessSet(pPegXDS: TXDS;pPriorIndex : String = '0';pPriorTask : String = '');
    procedure GetNextTask_PEGV2(pCurTaskName, pCurProcessName,pKeyValue,
      pTransid: String);
    procedure PegInit_PEGV2(pPegXDS: TXDS);
    //function GetAxProcessDef(transtype,pProcessName: string): TXDS;
    function GetAxProcessDef(transtype : string;pProcessName : String = '') : TXDS;
    procedure AddRecToAxActiveTaskParams(inpXDS: TXDS; pTaskId,
      pStatus: String);
    function GetTaskParams(pProcessName, pTaskName, pKeyValue,
      pTransId: String;pParamsFrom : Integer): String;
    function GetTaskParamsValues(pTaskParams: String): String;
    procedure RegisterAxActiveParams(pProcessName, pTaskName, pKeyValue,
      pTransId: String);
    function GetPEGTaskEventDateTime: String;
    function GetParentTaskXDSOfSubTask(pProcessName, pTaskName,
      pKeyValue: String): TXDS;
    function HasActiveSubTasks(pProcessName,pParentTaskName,pKeyValue,sSubTaskNames:String): Boolean;
    function HasSubTasks(pProcessName, pParentTaskName,
      pKeyValue: String; var sSubTaskNames: String): Boolean;
    function GetParentTaskUser(pAxActiveTaskStatus_TaskId: String): String;
    function HaveSubTasksCompleted(pProcessName, pTaskName,
      pKeyValue: String): Boolean;
    function GetGroupWithPriorIndexNo(pProcessName, pTaskName,
      pTransid: String): String;
    function GetMaxIndexNo(pProcessName, pGroupedIndexNo: String): String;
    function GetSameGroupedIndexTaskNames(pCurProcessName, pCurTaskname,
      pTransid, pGroupWithPriorIndex: String): String;
    function IsSameGroupedIndexTaskExistsAndActive(pCurProcessName, pTaskname,
      pTransid: String; var pGroupWithPriorIndex: String): Boolean;
    procedure DoAutoApprovalForOrphanTasks(pTransid, pTaskId, pProcessName,
      pTaskName, pKeyField, pKeyValue: String);
    function GetSkipLevelRM(sUserName: String): String;
    procedure DoAutoForwardForSameUser(pTaskId: String);
	
	//Amendment
	  procedure GetNextProcessAmendmentTask;
    procedure RegisterToParser(pVarName, pVarType, pVarValue: String);
    function EvalExpr(pExpr: String): String;
    function GetProcessStatusForAmend(pTransid, pKeyValue: string): string;
    function GetTaskPendingWithUsers(pProcessName, pTransid,
      pKeyValue: String;var sPEGDataJson : String): String;
    function GetAmendmentConfirmation(pProcessName: String): String;
    function GetProcessStatusNew(pCurUserTaskName,pTransid, pKeyValue: String;
      bGetLastStatusOfPeg: Boolean; dQry: TXds): string;
    function GetProcessName(pTransId, pKeyField, pKeyValue: String): String;
    function GetInitTaskName(pTransId, pProcessName: String): String;
    function GetRecID(pProcessName,pTransid,pKeyValue: String): String;
    procedure AddPEGConfigs(pProcessName, pTaskName, pTransid: String;
      pDataJson: TJsonObject);
    function CreatePEGorAmendDataJSON(dataXDS: TXDS;
      const dataJson: String): string;
    function ConvertTimestampToDateTime(const timestamp: string): string;
    function GetTransInitDateTime(pProcessName, pKeyValue: String): String;


    //PEG V2 ends

  public

    structdef : TStructDef;
    Parser : TEval;
    GetFieldValue : TGetFieldValue;
    SDEvaluateExpr : TSDEvaluateExpr;
    SDRegVarToParser : TSDRegVarToParser;
    Object_ASBDataObj : TObject;

    TransType,sCancelRemarks,sCancelledBy,sCancelledOn : String;
    LastSavedRecordId : Extended;
    StoreDataObject,ParserObject : TObject;
    delrowsnode : IXMLNode;
    IsPegEdit,bIsPEGApprovalOnSave : Boolean;

    constructor create(pStructDef : TStructDef); virtual;
    destructor destroy; override;

    procedure CheckAxProcessDef;
    function IsPegTaskInitiated: Boolean;
    procedure CancelPEGActiveTasks;
    procedure PushSaveDataToQueue(sQueueName,sAPIPayload: String);
    procedure PushMessagesToRMQ;
    function IsPegActiveTaskExists(sKeyField : String = ''): Boolean;
    procedure CallPEGApproveUsingTaskId(pTaskId: String);

	  procedure SaveAmend;
    procedure FetchAmendForLoadData;

    Function HasPegActiveTasks:Boolean;

end;

implementation

uses uAxPEGActions,uAxAmend;

//Create
constructor TAxPEG.create(pStructDef : TStructDef);
begin
  //create
  structdef := pStructDef;
  GetFieldValue := nil;
  SDEvaluateExpr := nil;
  SDRegVarToParser := nil;
  Object_ASBDataObj := nil;
  PublishMsgObjList:= nil;
  StoreDataObject := nil;
  ParserObject := nil;

  sPEGGlobalKeyValue := '';
  sPEGTask_EventDateTime := '';
  bIsCurrentPEGTask := False;
  sCancelRemarks := '';
  sCancelledBy := '';
  sCancelledOn := '';

  //Setting this as True for testing purpose
  bIsPEGV2 := True; //Setting this value as true by default
  //bIsPEGV2 := False;
  bIsFirstMake := True;
  bCurMakeIsSubTask := False;
  sCurMakeTasksParent := '';
  bIsParentTask := False;
  sAxGroupWithPriorIndex := '';
  PublishMsgObjList:= TList.create;
  bAddPublishRMQObjtoList := true; //by default setting to True
  sCurrentPEGInitiator := '';//Global var
  delrowsnode := nil;
  bIsAmendment := False;
  bIsPEGAttached := False;
  IsPegEdit := False;
  pegLastApproved := False;
  bPEGRejectedOrReturned := False;
  bIsPEGApprovalOnSave := False;
  bPEGWithdrawn := False;
end;

//Destroy
destructor TAxPEG.Destroy;
var
  iIdx : Integer;
begin
  //Destroy
  if Assigned(PublishMsgObjList) then
  begin
    try
      // Clear the list and destroy the objects
      for iIdx := 0 to PublishMsgObjList.Count - 1 do
      begin
        if Assigned(PublishMsgObjList[iIdx]) then
        begin
          TPublishToRMQ(PublishMsgObjList[iIdx]).Free;
        end;
      end;
      PublishMsgObjList.Clear;
    finally
      PublishMsgObjList.Free;
    end;
  end;
  inherited;
end;

//IsValidVariableName
function IsValidVariableName(s : String) : Boolean;
  var i : integer;
  c : String;
begin
  result := True;
  for i := 1 to length(s) do
  begin
     c := copy(s,i,1);
     if pos(c,'abcdefghijklmnopqrstuvwxyz_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ') > 0 then continue
     else
     begin
       result := false;
       break
     end;
  end;
end;

//PEG functionality starts here //

//FillDynamicParams | :dynamicvar
Function TAxPEG.FillDynamicParams(pInputStr : String):String;
var orgInputStr, SQLText, PName,pValue, S:String;
    p1, p2, l , i, iIdx : integer;
    StrAfterP1pos : String;
begin
  Result := pInputStr;
  structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams');
  structdef.axprovider.dbm.gf.DoDebug.msg(pInputStr);
  if (Trim(pInputStr) = '') or (pos(':', pInputStr) = 0) then
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('Exit from FillDynamicParams.');
    exit;
  end;
  orgInputStr := pInputStr;
  while true do begin
    p1 := pos(':', pInputStr);
    If p1 = 0 Then break;
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : p1 '+InttoStr(p1));
    StrAfterP1pos := Copy(pInputStr, p1 + 1, length(pInputStr));
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : StrAfterP1pos '+StrAfterP1pos);
    iIdx := 1;
    while IsValidVariableName(StrAfterP1pos[iIdx]) do
    begin
      inc(iIdx);
    end;
    p2 := iIdx-1;
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : p2 '+InttoStr(p2));
    pName := (Copy(pInputStr, p1 + 1, p2));
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : pName '+pName);
    pValue := '';
    if pName<>'' then begin
      if assigned(Parser) then
      begin
        pValue:=Parser.GetVarValue(pName);
      end;
      if pValue = '' then
        pValue:=GetFieldValue(pName,1);
      if (pValue = '') {and (Assigned(SDEvaluateExpr))} then
      begin
        pValue := EvalExpr(pName);//SDEvaluateExpr(pName);
      end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : pValue '+pValue);
    Delete(pInputStr, p1, p2 + 1);
    if pValue = '' then
      Insert(' '+pName, pInputStr, p1)//Added dummy string to avoid unwanted string replace in the original string
    else
      Insert(pValue, pInputStr, p1);
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : pInputStr '+pInputStr);
    if pValue <> '' then
    begin
      Delete(orgInputStr, p1, p2 + 1);
      Insert(pValue, orgInputStr, p1);
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : orgInputStr '+orgInputStr);
  end;
  result := orgInputStr;
  structdef.axprovider.dbm.gf.DoDebug.msg('FillDynamicParams : result '+result);
end;

//WriteStream
procedure TAxPEG.WriteStream(fname, table, where: String; stm: TStringStream);
var
  csql : String;
  myParams: TParams;
  updXDS : TXDS;
begin
  try
    updXDS := nil;
    myParams := nil;
    updXDS := structdef.axprovider.dbm.GetXDS(nil);
    updXDS.buffered := True;
    csql := 'UPDATE '+table+' SET '+fname+' = :MemoParam WHERE '+where;
    myParams := TParams.Create;
    myParams.Clear;
    myParams.CreateParam(ftMemo, 'MemoParam', ptInput);
    myparams.ParamByName('memoparam').AsString := stm.DataString;
    structdef.axprovider.dbm.gf.DoDebug.msg(csql);
    updXDS.CDS.CommandText := csql;
    updXDS.CDS.Params.Assign(myParams);
    updXDS.CDS.Execute;
  finally
    if Assigned(myParams) then
      FreeAndNil(myParams);
    if Assigned(updXDS) then
      FreeAndNil(updXDS);
  end;
end;


//GetReportingManager
Function TAxPEG.GetReportingManager(sUserName:String): String;
var
  getCurIndexXDS: TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetReportingManager starts...');
  try
    result := '';
    getCurIndexXDS := nil;
    getCurIndexXDS := structdef.axprovider.dbm.GetXDS(nil);
    getCurIndexXDS.buffered := true;
    getCurIndexXDS.CDS.CommandText := 'select reportingto from axusers where '
      + structdef.axprovider.dbm.gf.sqllower + '(username)=' + quotedstr(lowercase(sUserName));
    getCurIndexXDS.open;
    if getCurIndexXDS.CDS.RecordCount > 0 then
      result := getCurIndexXDS.CDS.FieldByName('reportingto').AsString
    else
      structdef.axprovider.dbm.gf.DoDebug.msg('GetReportingManager/ reportingto not found for the user '+sUserName);
  finally
    if Assigned(getCurIndexXDS) then
    begin
      if getCurIndexXDS.Active then
        getCurIndexXDS.close;
      FreeAndNil(getCurIndexXDS)
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetReportingManager ends.');
end;

//GetSkipLevelRM
Function TAxPEG.GetSkipLevelRM(sUserName:String): String;
var
  getCurIndexXDS: TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSkipLevelRM starts...');
  try
    result := '';
    getCurIndexXDS := nil;
    getCurIndexXDS := structdef.axprovider.dbm.GetXDS(nil);
    getCurIndexXDS.buffered := true;
    getCurIndexXDS.CDS.CommandText :=
    'select reportingto from axusers where username = '+
    '(select reportingto from axusers where  '+
    structdef.axprovider.dbm.gf.sqllower + '(username) = '+ quotedstr(lowercase(sUserName))+')';
    getCurIndexXDS.open;
    if getCurIndexXDS.CDS.RecordCount > 0 then
      result := getCurIndexXDS.CDS.FieldByName('reportingto').AsString
    else
      structdef.axprovider.dbm.gf.DoDebug.msg('GetSkipLevelRM/ reportingto not found for the user '+sUserName);
  finally
    if Assigned(getCurIndexXDS) then
    begin
      if getCurIndexXDS.Active then
        getCurIndexXDS.close;
      FreeAndNil(getCurIndexXDS)
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSkipLevelRM ends.');
end;

//getDisplayData | When display contetnt is empty then frame form's visbale field data as a content
Function TAxPEG.getDisplayData():String;
var
  I : Integer;
  tmpFld : pFld;
begin
  Result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('getDisplayData starts...');
  if Assigned(structdef) then
  begin
     for I := 0 to structdef.flds.Count-1 do
     begin
      tmpFld := structdef.flds[I];
      if tmpFld.FrameNo > 1 then
        Break;
      if tmpFld.hidden then
        Continue;
      Result := Result + ','+   GetFieldValue(tmpFld.FieldName,1);
     end;
     if Result <> '' then
      Delete(Result,1,1);
     structdef.axprovider.dbm.gf.DoDebug.msg('getDisplayData/Result '+Result);
  end
  else
    structdef.axprovider.dbm.gf.DoDebug.msg('getDisplayData/structdef object is not assigned.');
  structdef.axprovider.dbm.gf.DoDebug.msg('getDisplayData ends.');
end;


//GetActorFilter  | New logic Process users
Function TAxPEG.GetActorFilter(pAssignToActor : String):String;
var
  getFilterXDS : TXDS;
  iIdx,dotPOS : Integer;

  sName,sTransId,sFieldName,sFieldValue : String;
  slFieldNames : TStringList;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter starts...');
  result := '';
  getFilterXDS := nil;
  slFieldNames := nil;
  try
    slFieldNames := TStringList.Create;
    slFieldNames.Delimiter := '~';
    slFieldNames.StrictDelimiter := True;

    getFilterXDS := structdef.axprovider.dbm.GetXDS(nil);
    getFilterXDS.buffered := True;

    if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
      getFilterXDS.CDS.CommandText := 'SELECT DISTINCT '+
           ' substr(TRIM(REGEXP_SUBSTR(split_value, ''[^|]+'', 1, 1)),'+
           'INSTR(TRIM(REGEXP_SUBSTR(split_value, ''[^|]+'', 1, 1)),''-('')+2,'+
           'LENgth(TRIM(REGEXP_SUBSTR(split_value, ''[^|]+'', 1, 1)))-'+
           '(INSTR(TRIM(REGEXP_SUBSTR(split_value, ''[^|]+'', 1, 1)),''-('')+2)) fldname FROM '+
           ' (SELECT DISTINCT trim(REGEXP_SUBSTR(tbl_datagrp, ''[^~]+'', 1, LEVEL)) split_value, a.stransid FROM '+
           ' axpdef_peg_grpfilter g2, axpdef_peg_actor a '+
           ' WHERE a.axpdef_peg_actorid = g2.axpdef_peg_actorid '+
           ' AND a.assignmodecnd = 3 '+
           ' AND a.actorname = '+QuotedStr(pAssignToActor)+
           ' CONNECT BY REGEXP_SUBSTR (tbl_datagrp,''[^~]+'',1,LEVEL) IS NOT NULL '+
           ' ) c '
    else
      getFilterXDS.CDS.CommandText :=
      'SELECT DISTINCT substring(unnest(string_to_array(split_part(tbl_datagrp, ''|'', 1), '','')), position(''-('' in '+
      'unnest(string_to_array(split_part(tbl_datagrp, ''|'', 1), '','')))+ 2, abs((position(''-('' in '+
      'unnest(string_to_array(split_part(tbl_datagrp, ''|'', 1), '','')))+ 2) - '+
      'length(substring(unnest(string_to_array(split_part(tbl_datagrp, ''|'', 1), '','')), 1, '+
      'length(unnest(string_to_array(split_part(tbl_datagrp, ''|'', 1), '',''))))))) fldname FROM '+
      '(SELECT unnest(string_to_array(tbl_datagrp, ''~'')) tbl_datagrp, a.stransid FROM '+
      'axpdef_peg_grpfilter g2, axpdef_peg_actor a WHERE a.axpdef_peg_actorid = g2.axpdef_peg_actorid '+
      'AND a.assignmodecnd = 3 AND a.actorname = '+QuotedStr(pAssignToActor)+') c';



    (*
     'select distinct concat(stransid,''.'',substring(substring(unnest(string_to_array( split_part(tbl_datagrp,''|'',1) '+
     ', '','')), position(''-('' in unnest(string_to_array( split_part(tbl_datagrp,''|'',1) , '','')))+ 2, '+
     'abs((position(''-('' in unnest(string_to_array( split_part(tbl_datagrp,''|'',1) , '','')))+ 2) - '+
     'length(substring(unnest(string_to_array( split_part(tbl_datagrp,''|'',1) , '','')), 1, length(unnest(string_to_array( split_part(tbl_datagrp,''|'',1) , '',''))))))),2)) fldname '+
       ' from '+
       ' (select unnest(string_to_array(tbl_datagrp,''~'')) tbl_datagrp,a.stransid '+
       ' from axpdef_peg_grpfilter g2 ,axpdef_peg_actor a '+
       ' where a.axpdef_peg_actorid=g2.axpdef_peg_actorid '+
       ' and a.assignmodecnd=3 '+
       ' and a.actorname = '+QuotedStr(pAssignToActor)+
       ' ) c ';
     *)
    (*
    'select g2.fldname '+
            ' from axpdef_peg_actor b,axpdef_peg_grpfilter g2 '+
            ' where b.axpdef_peg_actorid = g2.axpdef_peg_actorid '+
            ' and b.process = '+QuotedStr(pProcessName)+
            ' and b.taskname = '+QuotedStr(pTaskName)+
            ' and assignmodecnd=3'+
            ' group by g2.fldname';
    *)
    structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter SQL-1 : '+getFilterXDS.CDS.CommandText);
    getFilterXDS.open;
    if not getFilterXDS.CDS.IsEmpty then
    begin
      For iIdx := 0 to getFilterXDS.CDS.RecordCount-1 do
      begin
        sFieldValue := '';
        sName := getFilterXDS.CDS.FieldByName('fldname').AsString;
        dotPOS := pos('.',sName);
        if dotPOS > 0 then
        begin
          sTransId := LowerCase(Copy(sName,1,dotPOS - 1));
          //sFieldName := Copy(sName,dotPOS + 1,Length(sName));
          if sTransId = LowerCase(TransType) then
          begin
           (*
            As discussed with Abinash , Actor fieldname now comes along with datatype,
            Earlier it was coming like transid.fieldname , now it will come like transid.datatypefieldname
            so we need to remove datatype inorder to get the fieldname.
            *)
            sFieldName := Copy(sName,dotPOS + 2,Length(sName));  //dotpos+2 to avoid . and datatype
            sFieldValue := GetFieldValue(sFieldName,1);
          end
          else
          begin
            //Need to handle   | if the transid is different from the current task transid
          end;
          if (sFieldValue = '') {and (Assigned(SDEvaluateExpr))} then
          begin
            //if varname not found then result coming as varname | need to be checked
            sFieldValue := EvalExpr(sName);//SDEvaluateExpr(sName);
          end;
          structdef.axprovider.dbm.gf.DoDebug.msg(sName+' = '+sFieldValue);
          slFieldNames.Add(sName{sFieldName}+'='+sFieldValue);
        end;
        getFilterXDS.CDS.Next;
      end;
      if slFieldNames.Count > 0 then
      begin
        sFieldName := slFieldNames.CommaText;
        if POS(',',sFieldName) > 0 then
          sFieldName := ReplaceStr(sFieldName,',','~');
        result := sFieldName;
      end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter Result : '+result);
  finally
    if Assigned(getFilterXDS) then
      FreeAndNil(getFilterXDS);
    if Assigned(slFieldNames) then
      FreeAndNil(slFieldNames);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter ends.');
end;


//GetActorFilter  | Old Logic Actors
(*
Function TAxPEG.GetActorFilter(pActorName : String):String;
var
  getFilterXDS : TXDS;
  iIdx,dotPOS : Integer;

  sName,sTransId,sFieldName,sFieldValue,sGroupName : String;
  slFieldNames : TStringList;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter starts...');
  result := '';
  getFilterXDS := nil;
  slFieldNames := nil;
  try
    slFieldNames := TStringList.Create;
    slFieldNames.Delimiter := '~';
    slFieldNames.StrictDelimiter := True;

    getFilterXDS := structdef.axprovider.dbm.GetXDS(nil);
    getFilterXDS.buffered := True;
    getFilterXDS.CDS.CommandText := 'select b.actorname,g2.fldname '+
        ' from axpdef_peg_actor b,axpdef_peg_actorgrp g,axpdef_peg_group g1,axpdef_peg_grpfilter g2 '+
        ' where b.axpdef_peg_actorid = g.axpdef_peg_actorid '+
        ' and g1.axpdef_peg_groupid = g2.axpdef_peg_groupid '+
        ' and (g1.axpdef_peg_actorid = b.axpdef_peg_actorid or g1.axpdef_peg_actorid=1) '+
        ' and g1.grpname = g.actgroup '+
        ' and g.axpdef_peg_groupid=g1.axpdef_peg_groupid '+
        ' and b.actorname = '+QuotedStr(pActorName)+
        ' group by b.actorname,g2.fldname ';
    structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter SQL-1 : '+getFilterXDS.CDS.CommandText);
    getFilterXDS.open;
    if not getFilterXDS.CDS.IsEmpty then
    begin
      For iIdx := 0 to getFilterXDS.CDS.RecordCount-1 do
      begin
        sFieldValue := '';
        sName := getFilterXDS.CDS.FieldByName('fldname').AsString;
        dotPOS := pos('.',sName);
        if dotPOS > 0 then
        begin
          sTransId := LowerCase(Copy(sName,1,dotPOS - 1));
          sFieldName := Copy(sName,dotPOS + 1,Length(sName));
          if sTransId = LowerCase(TransType) then
            sFieldValue := GetFieldValue(sFieldName,1)
          else
          begin
            //Need to handle   | if the transid is different from the current task transid
          end;
          if (sFieldValue = '') and (Assigned(SDEvaluateExpr)) then
          begin
            //if varname not found then result coming as varname | need to be checked
            sFieldValue := SDEvaluateExpr(sName);
          end;
          structdef.axprovider.dbm.gf.DoDebug.msg(sName+' = '+sFieldValue);
          slFieldNames.Add(sName{sFieldName}+'='+sFieldValue);
        end
        else
        begin
          sGroupName := sGroupName + ','+  sName;
        end;
        getFilterXDS.CDS.Next;
      end;
      if sGroupName <> '' then
        Delete(sGroupName,1,1);
      if slFieldNames.Count > 0 then
      begin
        sFieldName := slFieldNames.CommaText;
        if POS(',',sFieldName) > 0 then
          sFieldName := ReplaceStr(sFieldName,',','~');
      end;
      if sGroupName <> '' then
      begin
        getFilterXDS.close;
        getFilterXDS.buffered := True;
        //DITINCT of GroupName,GroupValue | Works for Postgres and Oracle , other DB didnt checked,
        getFilterXDS.CDS.CommandText := 'select DISTINCT groupname,groupvalue  from usergroupings u where username ='+
                                        QuotedStr(structdef.axprovider.dbm.gf.UserName)+' and groupname  in ('+
                                        ''''+ReplaceStr(sGroupName,',',''',''')+''''+')';
        structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter SQL-1 : '+getFilterXDS.CDS.CommandText);
        getFilterXDS.open;
        sGroupName := '';
        if not getFilterXDS.CDS.IsEmpty then
        begin
          For iIdx := 0 to getFilterXDS.CDS.RecordCount-1 do
          begin
            sGroupName := sGroupName + '~' + getFilterXDS.CDS.FieldByName('groupname').AsString+'='+getFilterXDS.CDS.FieldByName('groupvalue').AsString;
            getFilterXDS.CDS.Next;
          end;
        end;
        if sGroupName <> '' then
          Delete(sGroupName,1,1);
        result := sGroupName;
      end;
      if sFieldName <> '' then
      begin
        if result <> '' then
          result := result +'~'+ sFieldName
        else
          result := sFieldName;
      end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter Result : '+result);
  finally
    if Assigned(getFilterXDS) then
      FreeAndNil(getFilterXDS);
    if Assigned(slFieldNames) then
      FreeAndNil(slFieldNames);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetActorFilter ends.');
end;
*)

//GetInitiator
Function TAxPEG.GetInitiator(pProcessName,pTaskName,pTransid,pKeyValue:String): String;
var
  getInitiatorXDS : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetInitiator Starts...');
    Result := '';
    getInitiatorXDS := nil;
    try
      getInitiatorXDS := structdef.axprovider.dbm.GetXDS(nil);
      getInitiatorXDS.buffered := True;
      //This query may need to be checked if any further issue comes in initiator when processing with multiple forms
      getInitiatorXDS.CDS.CommandText := 'select Initiator from AxActiveTasks where '+
                structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
                //structdef.axprovider.dbm.gf.sqllower+'(Taskname)='+QuotedStr(lowercase(pTaskName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Transid)='+QuotedStr(lowercase(pTransid))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Keyvalue)='+QuotedStr(lowercase(pKeyValue))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Tasktype)='+QuotedStr('make')+
                //' order by IndexNo,SubIndexNo asc';
                ' order by IndexNo asc,eventdatetime desc'; //This is to fetch the latest record.
                //'indexno='+pIndexNo; //Tasktype ='make'
      getInitiatorXDS.open;
      if not getInitiatorXDS.CDS.IsEmpty then
        Result := getInitiatorXDS.CDS.FieldByName('Initiator').AsString
      else
        Result :=  structdef.axprovider.dbm.gf.UserName;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetInitiator '+E.Message);
    end;
  finally
    if Assigned(getInitiatorXDS) then
      FreeAndNil(getInitiatorXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetInitiator Ends.');
end;


//GetParentTaskUser
Function TAxPEG.GetParentTaskUser(pAxActiveTaskStatus_TaskId : String): String;
var
  getInitiatorXDS : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetParentTaskUser Starts...');
    Result := '';
    getInitiatorXDS := nil;
    try
      getInitiatorXDS := structdef.axprovider.dbm.GetXDS(nil);
      getInitiatorXDS.buffered := True;
      getInitiatorXDS.CDS.CommandText := 'select username from axactivetaskstatus where '+
                'taskid ='+QuotedStr(pAxActiveTaskStatus_TaskId)+
                ' order by eventdatetime asc';
      getInitiatorXDS.open;
      if not getInitiatorXDS.CDS.IsEmpty then
        Result := getInitiatorXDS.CDS.FieldByName('username').AsString;

    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetParentTaskUser '+E.Message);
    end;
  finally
    if Assigned(getInitiatorXDS) then
      FreeAndNil(getInitiatorXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetParentTaskUser Ends.');
end;

//GetRecID
Function TAxPEG.GetRecID(pProcessName,pTransid,pKeyValue: String): String;
Var
  xQry: TXDS;
  sWhrStr : String;
begin


  result := '0';
  xQry := nil;
  xQry := structdef.axprovider.dbm.GetXDS(nil);
  Try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetRecID starts...');
    xQry.buffered := true;
    sWhrStr := ' KeyValue = ' + quotedstr(pKeyValue) + ' and ' +
      'lower(TaskType) = ''make'' and ' +
      'lower(ProcessName) = ' +LowerCase(quotedstr(pProcessName)) + ' and ' +
      'lower(Transid) = ' + LowerCase(quotedstr(pTransid));

    xQry.CDS.CommandText := 'select RecordId from AxActiveTaskStatus where '
      + sWhrStr;

    xQry.CDS.open;
    if xQry.CDS.RecordCount > 0 then
    begin
      xQry.CDS.First;
      result := xQry.CDS.FieldByName('RecordId').AsString;
    end;
    structdef.axProvider.dbm.gf.DoDebug.msg('recordid ' + result);
    structdef.axprovider.dbm.gf.DoDebug.msg('GetRecID ends.');
  Finally
    xQry.close;
    FreeAndNil(xQry);
  End;
end;

//AddRecToAxActiveTasks
Function TAxPEG.AddRecToAxActiveTasks(pPegGetActiveXDS : TXDS;sPriorIdx,sPriorTask : String):String;
var
  PegActiveTaskXDS,PegCheckActiveTaskXDS : TXDS;
  sDisplayData,sProcessName,sTaskName,sKeyField,sKeyValue,sTaskId,sTaskType : String;
  sIndexNo,sGroupField,sGroupValue,sTmpGroupField,sWhereCond : String;
  iIdx : Integer;
  sMapField,sMapValue,sTmpMapField,sTransId,sUpdateSQL : String;
  sAssignToFlg,sAssignToReportingManager,sToUser,sSubIndexNo,sProcessOwner : String;
  sToActor,sActorFilter,sFormFieldname,sProcessownerFlg,sInitiator,sReminder,sEscalation : String;
  sDisplayContents,sM_DisplayContents,sParentTaskId,sUseBusinessdateLogic,sInitonbehalf : String;

  stm : TStringStream;
  tmpStrList,slDisplayContents : TStringlist;
  bCanAddActiveTasks,bRemind,bEscalate,borphan_autoapproval,bUseBusinessdateLogic,bNotify : Boolean;
  sCurrentPEGTaskID,sSkiplevelcnd,sActualFormFieldname : String;
  dotPOS : Integer;

  sTaskNotification : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks starts...');
  Result := '';
  PegActiveTaskXDS := nil;
  PegCheckActiveTaskXDS := nil;
  stm := nil;
  tmpStrList := nil;
  slDisplayContents := nil;
  sParentTaskId := '';
  sCurrentPEGTaskID := '';
  sTaskNotification := '';

  if Not Assigned(pPegGetActiveXDS) or (pPegGetActiveXDS.CDS.RecordCount = 0) then
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/No tasks found to add in AxActiveTasks.');
    Exit;
  end;
  bCanAddActiveTasks := True;

  sProcessName := pPegGetActiveXDS.CDS.FieldByName('ProcessName').AsString;
  sTaskName := pPegGetActiveXDS.CDS.FieldByName('TaskName').AsString;
  sTaskType := pPegGetActiveXDS.CDS.FieldByName('TaskType').AsString;
  sIndexNo := pPegGetActiveXDS.CDS.FieldByName('IndexNo').AsString;
  sKeyValue := sPEGGlobalKeyValue;

  try
    PegCheckActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegCheckActiveTaskXDS.buffered := True;
    if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
      PegCheckActiveTaskXDS.CDS.CommandText :=  ' WITH FilteredTasks AS ( '+
                                                 ' SELECT a.TaskId,a.eventdatetime, a.IndexNo, a.SubIndexNo '+
                                                 ' FROM AxActiveTasks a '+
                                                 ' WHERE lower(ProcessName) = '+QuotedStr(lowercase(sProcessName))+
                                                 ' AND lower(Taskname) = '+QuotedStr(lowercase(sTaskName))+
                                                 ' AND lower(TaskType) = '+QuotedStr(lowercase(sTaskType))+
                                                 ' AND lower(KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
                                                 ' AND IndexNo = '+sIndexNo+
                                                 ' AND NOT EXISTS ( '+
                                                  ' SELECT 1 '+
                                                   ' FROM AxActiveTaskStatus b '+
                                                    ' WHERE a.taskid = b.taskid '+
                                                   ' ) '+
                                               ' ) '+
                                               ' SELECT TaskId '+
                                               ' FROM FilteredTasks '+
                                               ' ORDER BY eventdatetime, IndexNo, SubIndexNo DESC'
    else
      PegCheckActiveTaskXDS.CDS.CommandText := 'Select TaskId from AxActiveTasks a where '+
                  structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(sProcessName))+ ' and '+
                  structdef.axprovider.dbm.gf.sqllower+'(Taskname)='+QuotedStr(lowercase(sTaskName))+ ' and '+
                  structdef.axprovider.dbm.gf.sqllower+'(TaskType)='+QuotedStr(lowercase(sTaskType))+ ' and '+
                  structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(sKeyValue))+ ' and '+
                  'IndexNo='+sIndexNo+   //below exists condition newly added to handle return when re intiating the process
                  ' and not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid '+
                  ' order by eventdatetime,IndexNo,SubIndexNo desc)';
    PegCheckActiveTaskXDS.open;
    if PegCheckActiveTaskXDS.CDS.RecordCount > 0 then
    begin
       bCanAddActiveTasks := False;
       sCurrentPEGTaskID :=  PegCheckActiveTaskXDS.CDS.FieldByName('TaskId').AsString;
    end;
  finally
    if Assigned(PegCheckActiveTaskXDS) then
      FreeAndNil(PegCheckActiveTaskXDS);
  end;
  if Not bCanAddActiveTasks then
  begin
    //update recordId in the AxActiveTasks for the curren task (makey type record)
    if bIsCurrentPEGTask then
    begin
       try
         //update can be execute using filter sIsCurrentPEGTaskID but due to demo
         //we didnt changed the logic and giving it as its now, in future it can be hasnled
         //using sIsCurrentPEGTaskID instead of using porcess,task,tasktyp,keyvalue...
         sUpdateSQL := 'Update AxActiveTasks set recordid = '+FloattoStr(LastSavedRecordId)+' where '+
         structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(sProcessName))+ ' and '+
         structdef.axprovider.dbm.gf.sqllower+'(Taskname)='+QuotedStr(lowercase(sTaskName))+ ' and '+
         structdef.axprovider.dbm.gf.sqllower+'(TaskType)='+QuotedStr(lowercase(sTaskType))+ ' and '+
         structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(sKeyValue))+ ' and '+
         'IndexNo='+sIndexNo;
         structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/ Updating recordid for the task '+sTaskName);
         structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/ UpdateSQL '+sUpdateSQL);

         structdef.axprovider.ExecSQL(sUpdateSQL,'','',false);//ExecuteSQL(sUpdateSQL);

         try
           //The below code is to process post notifcations at the time saving make records
           // reminder and escalations will be added to queue while adding task to activetask table
           // but post notification will be executed only when the task is executed.
           //so for make type records its handled here | multiple make this will solve the issue.

           //This can be moved to end and make it as generic | Below exit can be removed and conditional
           //statment can be added to handle this code redundancy
           if (sCurrentPEGTaskID <> '') then
           begin
              sTransid := pPegGetActiveXDS.CDS.FieldByName('Transid').AsString;
              sKeyField := pPegGetActiveXDS.CDS.FieldByName('KeyField').AsString;

              //PublishtoRMQ starts
              //Publish Message to RMQ - Reminders , Escalation
              //sReminder := Trim(pPegGetActiveXDS.CDS.FieldByName('reminder').AsString);
              //sEscalation := Trim(pPegGetActiveXDS.CDS.FieldByName('escalation').AsString);

              //Whether to use functions for business day logic or
              //sUseBusinessdateLogic := Trim(pPegGetActiveXDS.CDS.FieldByName('usebusinessdatelogic').AsString);

              //if sReminder = '' then sReminder := '0';
              //if sEscalation = '' then sEscalation := '0';

              //if sReminder <> '0' then bRemind := True;
              //if sEscalation <> '0' then bEscalate := True;
              //if lowercase(sUseBusinessdateLogic) = 't' then bUseBusinessdateLogic := True;
              //If taskype make and it is first make then trigger notification also
              //if it is found
              bRemind := false;
              bEscalate := false;
              bUseBusinessdateLogic := false;

              //As per new design , Reminders and Escalation will be processed through Db function, RMQ , consumer service.
              //The consumer service will invoke notify restapi to trigger reminder / escalations
              // So only Post notifications / Task notification will be processed from here.
              // Index 1 ont be having any notifications, all other task will have Task Notifications.
              // Make will not have post notification.


              (*
              if (lowercase(sTaskType) = 'make') and bIsCurrentPEGTask
                and (bIsFirstMake) then
                bNotify := True
              else
                bNotify := False;

              if ((bRemind) or (bEscalate) or (bNotify)) then
                PublishMessageToRMQ({sTaskId}sCurrentPEGTaskID, sTransId, sProcessName, sTaskName,
                  sKeyField,sKeyValue,bRemind,bEscalate,{False}bNotify,bUseBusinessdateLogic);
              *)
              //PublishtoRMQ ends

           end;
         finally

         end;
       Except on E:Exception do
        structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/ Error in Updating recordid '+E.Message);
       end;
    end;
    Exit;
  end;

  try
  sInitonbehalf := '';
  sReminder := '';
  sEscalation := '';
  sUseBusinessdateLogic := '';
  sDisplayContents := '';
  sM_DisplayContents := '';
  bRemind := False;
  bEscalate := False;
  bNotify := False;
  bUseBusinessdateLogic := False;
  borphan_autoapproval := False;
  slDisplayContents := TStringList.Create;
  try
  PegActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
  begin
    PegActiveTaskXDS.Append('AxActiveTasks');
    PegActiveTaskXDS.submit('EventDateTime',GetPEGTaskEventDateTime{structdef.axprovider.dbm.gf.GetDateTimeStampString;},'c');
    sTaskId := floatTostr(structdef.axprovider.dbm.Gen_id(structdef.axprovider.dbm.connection));
    PegActiveTaskXDS.submit('TaskId',sTaskId,'c');
    sProcessName := pPegGetActiveXDS.CDS.FieldByName('ProcessName').AsString;
    PegActiveTaskXDS.submit('ProcessName',sProcessName,'c');
    sTaskName := pPegGetActiveXDS.CDS.FieldByName('TaskName').AsString;
    PegActiveTaskXDS.submit('TaskName', sTaskName,'c');
    sTaskType := pPegGetActiveXDS.CDS.FieldByName('TaskType').AsString;
    PegActiveTaskXDS.submit('TaskType', sTaskType,'c');
    PegActiveTaskXDS.submit('TaskDescription',pPegGetActiveXDS.CDS.FieldByName('TaskDescription').AsString,'c');
    sIndexNo := pPegGetActiveXDS.CDS.FieldByName('IndexNo').AsString;
    PegActiveTaskXDS.submit('IndexNo',sIndexNo,'n');
    sSubIndexNo := pPegGetActiveXDS.CDS.FieldByName('subIndexNo').AsString;
    if sSubIndexNo = '' then
        sSubIndexNo := '1';
    PegActiveTaskXDS.submit('SubIndexNo',sSubIndexNo,'n');
    sProcessOwner := pPegGetActiveXDS.CDS.FieldByName('ProcessOwner').AsString;

    sTransid := pPegGetActiveXDS.CDS.FieldByName('Transid').AsString;
    sKeyField := pPegGetActiveXDS.CDS.FieldByName('KeyField').AsString;
    if Not bIsParentTask then
    begin
      if sPEGGlobalKeyValue <> '' then
        sKeyValue := sPEGGlobalKeyValue
      else
        sKeyValue := GetFieldValue(sKeyField,1);
      PegActiveTaskXDS.submit('KeyValue',sKeyValue , 'c');
    end
    else //if ParentTask
      PegActiveTaskXDS.submit('KeyValue',pPegGetActiveXDS.CDS.FieldByName('KeyValue').AsString, 'c');
    //Initonbehalf
    sInitonbehalf := GetFieldValue('AxInitOnBehalf',1);
    //Initiator - First username who initiated the transaction
    if sIndexNo = '1' then //For the first index we alwasy keep first current user as Initiator
      sInitiator := structdef.axprovider.dbm.gf.username
    else
      sInitiator := GetInitiator(sProcessName,sTaskName,sTransid,sKeyValue);

    // processownerflg
    sProcessownerFlg := pPegGetActiveXDS.CDS.FieldByName('processownerflg').AsString;
    if sProcessownerFlg = '1' then //Actor
    begin
      //if ActorName is 'none' then send Processname+taskname as actorname,
      //its been handled in the trigger to get actor name.
      if lowercase(sProcessOwner) = 'none' then
        sProcessOwner := sProcessName+sTaskName;
      sActorFilter := GetActorFilter(sProcessOwner);//GetActorFilter(sProcessName,sTaskName);//GetActorFilter(sProcessOwner);
      PegActiveTaskXDS.submit('POwnerFilter',sActorFilter, 'c')
    end;
    PegActiveTaskXDS.submit('ProcessOwner',sProcessOwner,'c');
    PegActiveTaskXDS.submit('processownerflg',sProcessownerFlg,'n');
    {
    /* assigntoflg=
     * 1 - Reporting manager
     * 2 - Assign to Actor
     * 3 - Assign to Role
     * 4 - From form field
     * 6 - Skip level
     * 7 - Prior user
     */
    }
    sAssignToFlg := pPegGetActiveXDS.CDS.FieldByName('assigntoflg').AsString;
    PegActiveTaskXDS.submit('assigntoflg',sAssignToFlg,'c');
    if bIsParentTask then  //IsParentTask | SubTasks Parent
    begin
      //This XDS resultset belongs to AxActiveTasks table, so it will be having taskid column, That can be user as parent taskid
      sParentTaskId := pPegGetActiveXDS.CDS.FieldByName('taskid').AsString;
      sToUser := GetParentTaskUser(sParentTaskId);
      PegActiveTaskXDS.submit('ToUser',pPegGetActiveXDS.CDS.FieldByName('ToUser').AsString, 'c');
      if sToUser <> '' then
        PegActiveTaskXDS.submit('Grouped','T', 'c');

      if lowercase(sTaskType) = 'make' then //For Make update recordid during return
           PegActiveTaskXDS.submit('RecordId',pPegGetActiveXDS.CDS.FieldByName('RecordId').AsString, 'n');

      //fields for setting comments mandatory for Approve, Return & Reject
      PegActiveTaskXDS.submit('approvalcomments', pPegGetActiveXDS.CDS.FieldByName('approvalcomments').AsString, 'c');
      PegActiveTaskXDS.submit('rejectcomments', pPegGetActiveXDS.CDS.FieldByName('rejectcomments').AsString, 'c');
      PegActiveTaskXDS.submit('returncomments', pPegGetActiveXDS.CDS.FieldByName('returncomments').AsString, 'c');
      //PegActiveTaskXDS.submit('escalation', pPegGetActiveXDS.CDS.FieldByName('escalation').AsString, 'c');
      //PegActiveTaskXDS.submit('reminder', pPegGetActiveXDS.CDS.FieldByName('reminder').AsString, 'c');

      if bIsPEGV2 then
        //GroupWithPrior tasks will have same index (initial Task Index as GroupWithPriorIndex)
        PegActiveTaskXDS.submit('groupwithpriorindex', pPegGetActiveXDS.CDS.FieldByName('groupwithpriorindex').AsString, 'c');
    end
    else
    begin

      //if sIndexNo <> '1' then
      begin
        if sAssignToFlg = '1' then //Reporting manager
        begin
          if sInitonbehalf <> '' then
            sToUser := GetReportingManager(sInitonbehalf)
          else
            sToUser := GetReportingManager(structdef.axprovider.dbm.gf.username);
          //this will be handled by Abinash through procedure | processowner can be actor / role
          //if sToUser = '' then
          //  sToUser := sProcessOwner;
          //Is Grouped set to true to handle when to user is not empty since | DB triggers updated grouped 'T' for touser <> '' records
          if sToUser <> '' then
            PegActiveTaskXDS.submit('Grouped','T', 'c');
          PegActiveTaskXDS.submit('ToUser',sToUser, 'c');
        end
        else if sAssignToFlg = '2' then //Actor
        begin
          sToActor := pPegGetActiveXDS.CDS.FieldByName('AssignToActor').AsString;

          //if ActorName is 'none' then send Processname+taskname as actorname,
          //its been handled in the trigger to get actor name.
          if Lowercase(sToActor) = 'none' then
             sToActor := sProcessName+sTaskName;

          PegActiveTaskXDS.submit('AssignToActor',sToActor, 'c');
          sActorFilter := GetActorFilter(sToActor);//GetActorFilter(sProcessName,sTaskName);//GetActorFilter(sToActor);
          PegActiveTaskXDS.submit('ActorFilter',sActorFilter, 'c')
        end
        else if sAssignToFlg = '3' then //Role
        begin
          PegActiveTaskXDS.submit('AssignToRole',
          pPegGetActiveXDS.CDS.FieldByName('AssignToRole').AsString, 'c');

          //Handling Map field, MapValue
          sMapField := pPegGetActiveXDS.CDS.FieldByName('MapField').AsString;
          structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/MapField '+sMapField);
          sMapValue := '';
          if sMapField <> '' then
          begin
            //if Assigned(SDEvaluateExpr) then //Evaluate not reuqired since the direct field will be mapped here.
            begin
              iIdx := 1;
              sTmpMapField := Trim(structdef.axprovider.dbm.gf.GetNthString(sMapField,iIdx));
              while sTmpMapField <> '' do
              begin
                sMapValue := sMapValue+','+GetFieldValue(sTmpMapField,1){SDEvaluateExpr(sTmpMapField)};
                Inc(iIdx);
                sTmpMapField := Trim(structdef.axprovider.dbm.gf.GetNthString(sMapField,iIdx));
              end;
              if sMapValue <> '' then
                Delete(sMapValue,1,1);
            end;
          end;
          PegActiveTaskXDS.submit('MapFieldValue',sMapValue, 'c');
          structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/MapFieldValue '+sMapValue);
        end
        else if sAssignToFlg = '4' then //From form field
        begin
          sFormFieldname := pPegGetActiveXDS.CDS.FieldByName('formfieldname').AsString;
          sActualFormFieldname := sFormFieldname;
          dotPOS := pos('.',sFormFieldname);
          if dotPOS > 0 then
          begin
            sFormFieldname := Copy(sFormFieldname,dotPOS + 1,Length(sFormFieldname));
          end;
          //Considering that FormFieldname will be current transid always
          sToUser := GetFieldValue(sFormFieldname,1);
          // Check TaskParams
          if (sToUser = '') {and (Assigned(SDEvaluateExpr))} then
          begin
            sToUser := EvalExpr(sFormFieldname);//SDEvaluateExpr(sFormFieldname);
            if (sToUser = '') or (sToUser = sFormFieldname) then
            begin
              sToUser := EvalExpr(sActualFormFieldname);//SDEvaluateExpr(sActualFormFieldname);
              //if varname not found then result coming as varname | need to be checked
              if sToUser = sActualFormFieldname then sToUser := '';
            end;
          end;
          //this will be handled by Abinash through procedure | processowner can be actor / role
          //if sToUser = '' then
          //  sToUser := sProcessOwner;
          //Is Grouped set to true to handle when to user is not empty since | DB triggers updated grouped 'T' for touser <> '' records
          //When grouped is null the DB triggers will be executed to find the ToUser (based on Actor / Role)
          if sToUser <> '' then
            PegActiveTaskXDS.submit('Grouped','T', 'c');
          PegActiveTaskXDS.submit('ToUser',sToUser, 'c');
        end
        else if (sAssignToFlg = '5') and (bIsPEGV2) then //NA [PEG V2]
        begin
          sToUser := pPegGetActiveXDS.CDS.FieldByName('assignto').AsString;
          if sToUser <> '' then
            PegActiveTaskXDS.submit('Grouped','T', 'c');
          PegActiveTaskXDS.submit('ToUser',sToUser, 'c');
        end
        else if sAssignToFlg = '6' then //Skip level (Reporting manager's RM)
        begin
          //skiplevelcnd may need to be added into the AxActiveTasks table also | will check later
          sSkiplevelcnd := '';
          sSkiplevelcnd := pPegGetActiveXDS.CDS.FieldByName('skiplevelcnd').AsString;
          (*
          skiplevelcnd
          1 - Initiator skip level
          2 - User skip level
          *)
          if sSkiplevelcnd = '1' then //Initiator
          begin
            if sInitonbehalf <> '' then
              sToUser := GetSkipLevelRM(sInitonbehalf)
            else
              sToUser := GetSkipLevelRM(sInitiator);
          end
          else if sSkiplevelcnd = '2' then //User
            sToUser := GetSkipLevelRM(structdef.axprovider.dbm.gf.username);

//          if sInitonbehalf <> '' then
//            sToUser := GetSkipLevelRM(sInitonbehalf)
//          else
//            sToUser := GetSkipLevelRM(structdef.axprovider.dbm.gf.username);
          //Is Grouped set to true to handle when to user is not empty since | DB triggers updated grouped 'T' for touser <> '' records
          if sToUser <> '' then
            PegActiveTaskXDS.submit('Grouped','T', 'c');
          PegActiveTaskXDS.submit('ToUser',sToUser, 'c');
        end
        else if sAssignToFlg = '7' then // Prior user - it will be like fromuser  & touser will be same for this type
        begin
          sToUser := structdef.axprovider.dbm.gf.username;
          //Is Grouped set to true to handle when to user is not empty since | DB triggers updated grouped 'T' for touser <> '' records
          if sToUser <> '' then
            PegActiveTaskXDS.submit('Grouped','T', 'c');
          PegActiveTaskXDS.submit('ToUser',sToUser, 'c');
        end
      end;


      //fields for setting comments mandatory for Approve, Return & Reject
      PegActiveTaskXDS.submit('approvalcomments', pPegGetActiveXDS.CDS.FieldByName('approvecmt').AsString, 'c');
      PegActiveTaskXDS.submit('rejectcomments', pPegGetActiveXDS.CDS.FieldByName('rejectcmt').AsString, 'c');
      PegActiveTaskXDS.submit('returncomments', pPegGetActiveXDS.CDS.FieldByName('returncmt').AsString, 'c');

      if bIsPEGV2 then
      begin
        if sAxGroupWithPriorIndex = '' then
          sAxGroupWithPriorIndex := sIndexNo;
        //GroupWithPrior tasks will have same index (initial Task Index as GroupWithPriorIndex)
        PegActiveTaskXDS.submit('groupwithpriorindex', sAxGroupWithPriorIndex, 'c');
      end;
    end;

    PegActiveTaskXDS.submit('escalation', pPegGetActiveXDS.CDS.FieldByName('escalation').AsString, 'c');
    PegActiveTaskXDS.submit('reminder', pPegGetActiveXDS.CDS.FieldByName('reminder').AsString, 'c');
    PegActiveTaskXDS.submit('usebusinessdatelogic', pPegGetActiveXDS.CDS.FieldByName('usebusinessdatelogic').AsString, 'c');

    //User identificationfilters can be added only when the role is enabled.
    PegActiveTaskXDS.submit('useridentificationfilter',
        pPegGetActiveXDS.CDS.FieldByName('useridentificationfilter').AsString, 'c');
    PegActiveTaskXDS.submit('useridentificationfilter_of',
        pPegGetActiveXDS.CDS.FieldByName('useridentificationfilter_of').AsString, 'c');
    PegActiveTaskXDS.submit('mapfield_group',
        pPegGetActiveXDS.CDS.FieldByName('mapfield_group').AsString, 'c');
//    sTransid := pPegGetActiveXDS.CDS.FieldByName('Transid').AsString;
    PegActiveTaskXDS.submit('Transid',sTransid,'c');
//    sKeyField := pPegGetActiveXDS.CDS.FieldByName('KeyField').AsString;
    PegActiveTaskXDS.submit('KeyField',sKeyField,'c');
    PegActiveTaskXDS.submit('ExecOnApprove',pPegGetActiveXDS.CDS.FieldByName('ExecOnApprove').AsString,'c');

//    if Not bIsParentTask then
//    begin
//      if sPEGGlobalKeyValue <> '' then
//        sKeyValue := sPEGGlobalKeyValue
//      else
//        sKeyValue := GetFieldValue(sKeyField,1);
//      PegActiveTaskXDS.submit('KeyValue',sKeyValue , 'c');
//    end
//    else
//      PegActiveTaskXDS.submit('KeyValue',pPegGetActiveXDS.CDS.FieldByName('KeyValue').AsString, 'c');

    //if (lowercase(sTaskType) = 'make') and bIsCurrentPEGTask then  //only for maketype updating recordid
    //  PegActiveTaskXDS.submit('RecordId',FloattoStr(LastSavedRecordId), 'n');
    //Modified on 11/08/2023 to update recid for returned tasks .
	//As of now we do not have flag to identify return rec so the statement will be called everytime
    if (lowercase(sTaskType) = 'make') then  //only for maketype updating recordid
    begin
      if bIsCurrentPEGTask then
        PegActiveTaskXDS.submit('RecordId',FloattoStr(LastSavedRecordId), 'n')
      else
        PegActiveTaskXDS.submit('RecordId',GetRecID(sProcessName,sTransid,sKeyValue), 'n')
    end;

    PegActiveTaskXDS.submit('DisplayIcon', pPegGetActiveXDS.CDS.FieldByName('DisplayIcon').AsString, 'c');
    PegActiveTaskXDS.submit('DisplayTitle', FillDynamicParams(pPegGetActiveXDS.CDS.FieldByName('DisplayTitle').AsString), 'c');
    PegActiveTaskXDS.submit('DIsplaySubTitle', FillDynamicParams(pPegGetActiveXDS.CDS.FieldByName('DIsplaySubTitle').AsString), 'c');
    PegActiveTaskXDS.submit('DisplayButtons', pPegGetActiveXDS.CDS.FieldByName('DisplayButtons').AsString, 'c');

    //DisplayContent
    try
      slDisplayContents.Clear;
      stm := TStringStream.Create('');
      sDisplayData := trim(VartoStr(pPegGetActiveXDS.CDS.FieldByName('DIsplayContent').Value));
      //Hope stm write is not needed , need to be checked.
      if sDisplayData <> '' then
        stm.WriteString(sDisplayData);
      if stm.Size>0 then
      begin
        tmpStrList := TStringlist.Create;
        tmpStrList.Text := stm.DataString ;
        for iIdx := 0 to tmpStrList.Count-1 do
          slDisplayContents.Add(tmpStrList[iIdx]);
        sDisplayContents := slDisplayContents.text;
      end;
    finally
      if Assigned(tmpStrList) then
        FreeAndNil(tmpStrList);
      if Assigned(stm) then
        FreeAndNil(stm);
    end;

    if bIsPEGV2 then
    begin
      //returnable | Configurable
      PegActiveTaskXDS.submit('returnable', pPegGetActiveXDS.CDS.FieldByName('returnable').AsString, 'c');
      //allowsend , allowsendflg , sendtoactor
      PegActiveTaskXDS.submit('allowsend', pPegGetActiveXDS.CDS.FieldByName('allowsend').AsString, 'c');
      PegActiveTaskXDS.submit('allowsendflg', pPegGetActiveXDS.CDS.FieldByName('allowsendflg').AsString, 'c');
      PegActiveTaskXDS.submit('sendtoactor', pPegGetActiveXDS.CDS.FieldByName('sendtoactor').AsString, 'c');

      //disallow Initiator to approve
      PegActiveTaskXDS.submit('initiator_approval', pPegGetActiveXDS.CDS.FieldByName('initiator_approval').AsString, 'c');

      //MDisplayContent
      try
        slDisplayContents.Clear;
        stm := TStringStream.Create('');
        sDisplayData := trim(VartoStr(pPegGetActiveXDS.CDS.FieldByName('displaymcontent').Value));
        //Hope stm write is not needed , need to be checked.
        if sDisplayData <> '' then
          stm.WriteString(sDisplayData);
        if stm.Size>0 then
        begin
          tmpStrList := TStringlist.Create;
          tmpStrList.Text := stm.DataString ;
          for iIdx := 0 to tmpStrList.Count-1 do
            slDisplayContents.Add(tmpStrList[iIdx]);
          sM_DisplayContents := slDisplayContents.text;
        end;
      finally
        if Assigned(tmpStrList) then
          FreeAndNil(tmpStrList);
        if Assigned(stm) then
          FreeAndNil(stm);
      end;
    end;
    //isoptional
    PegActiveTaskXDS.submit('isoptional', pPegGetActiveXDS.CDS.FieldByName('isoptional').AsString, 'c');
    //autoapprove
    PegActiveTaskXDS.submit('autoapprove', pPegGetActiveXDS.CDS.FieldByName('autoapprove').AsString, 'c');

    // updating approve,reject,return related fields
    PegActiveTaskXDS.submit('approvereasons', pPegGetActiveXDS.CDS.FieldByName('approvereasons').AsString, 'c');
    PegActiveTaskXDS.submit('defapptext', FillDynamicParams(pPegGetActiveXDS.CDS.FieldByName('defapptext').AsString), 'c');
    PegActiveTaskXDS.submit('returnreasons', pPegGetActiveXDS.CDS.FieldByName('returnreasons').AsString, 'c');
    PegActiveTaskXDS.submit('defrettext', FillDynamicParams(pPegGetActiveXDS.CDS.FieldByName('defrettext').AsString), 'c');
    PegActiveTaskXDS.submit('rejectreasons', pPegGetActiveXDS.CDS.FieldByName('rejectreasons').AsString, 'c');
    PegActiveTaskXDS.submit('defregtext', FillDynamicParams(pPegGetActiveXDS.CDS.FieldByName('defregtext').AsString), 'c');

    PegActiveTaskXDS.submit('FromUser',structdef.axprovider.dbm.gf.UserName, 'c');
    PegActiveTaskXDS.submit('PriorIndex',sPriorIdx, 'n');
    PegActiveTaskXDS.submit('PriorTaskName',sPriorTask, 'c');
    //PriorUsername will be empty for first record
    PegActiveTaskXDS.submit('PriorUserName', {''}structdef.axprovider.dbm.gf.UserName, 'c');
//    //Initiator - First username
//    sInitiator := GetInitiator(sProcessName,sTaskName,sTransid,sKeyValue);
    PegActiveTaskXDS.submit('Initiator', sInitiator{structdef.axprovider.dbm.gf.username}, 'c');
    PegActiveTaskXDS.submit('initonbehalf', sInitonbehalf, 'c');
    PegActiveTaskXDS.post;
    //Update DisplayContent
    try
      sDisplayData := sDisplayContents;//slDisplayContents.text;
      // Frame sDisplayData
      sDisplayData := FillDynamicParams(sDisplayData);
      if Trim(sDisplayData) = '' then
        sDisplayData :=  getDisplayData();//sTaskName+'-'+sKeyField+'-'+sKeyValue;
      stm := TStringStream.Create(sDisplayData);
      if stm.Size > 0 then
      begin
        sWhereCond := '(TaskId)='+QuotedStr(sTaskId);
        WriteStream('DIsplayContent','AxActiveTasks',sWhereCond,stm); //dbm.WriteMemo('DIsplayContent','AxProcessDef',sWhereCond,stm);
      end;
    finally
      if Assigned(stm) then
        FreeandNil(stm);
    end;

    if bIsPEGV2 then
    begin
      //Update MDisplayContent
      try
        sDisplayData := sM_DisplayContents;//slDisplayContents.text;
        // Frame sDisplayData
        sDisplayData := FillDynamicParams(sDisplayData);
        //DisplaymContent can be empty - so leaving it as empty.
        //if Trim(sDisplayData) = '' then
          //sDisplayData :=  getDisplayData();//sTaskName+'-'+sKeyField+'-'+sKeyValue;
        stm := TStringStream.Create(sDisplayData);
        if stm.Size > 0 then //empy data also has to be updated in the table | else this will cause problem when editing the data
        begin
          sWhereCond := '(TaskId)='+QuotedStr(sTaskId);
          WriteStream('displaymcontent','AxActiveTasks',sWhereCond,stm); //dbm.WriteMemo('DIsplayContent','AxProcessDef',sWhereCond,stm);
        end;
      finally
        if Assigned(stm) then
          FreeandNil(stm);
      end;
    end;

    Result := sTaskid;

    //PublishtoRMQ starts

    // As per new design , Reminders and Escalation will be processed through Db function, RMQ , consumer service.
    // The consumer service will invoke axnotify restapi to trigger reminder / escalations
    // So only Post notifications / Task notification will be processed from here.
    // Index 1 will not be having any notifications, all other task will have Task Notifications.
    // Make task type will not have post notification.

    bRemind := false;
    bEscalate := false;
    bUseBusinessdateLogic := false;
    (*
    //Publish Message to RMQ - Reminders , Escalation
    sReminder := Trim(pPegGetActiveXDS.CDS.FieldByName('reminder').AsString);
    sEscalation := Trim(pPegGetActiveXDS.CDS.FieldByName('escalation').AsString);

    //Whether to use functions for business day logic or
    sUseBusinessdateLogic := Trim(pPegGetActiveXDS.CDS.FieldByName('usebusinessdatelogic').AsString);

    if sReminder = '' then sReminder := '0';
    if sEscalation = '' then sEscalation := '0';

    if sReminder <> '0' then bRemind := True;
    if sEscalation <> '0' then bEscalate := True;
    if lowercase(sUseBusinessdateLogic) = 't' then bUseBusinessdateLogic := True;

    //If taskype make and it is first make then trigger notification also
    //if it is found
    if (lowercase(sTaskType) = 'make') and bIsCurrentPEGTask
      and (bIsFirstMake) then
      bNotify := True
    else
      bNotify := False;
    *)

    (*
    for parent task by default we are setting notify true this will be checked against the axprocessdefv2 table for that
    Current task in the uPublishToRMQ,
    Since the parent task will be read from the axactivetasks table.

    AllTasks TaskNotification will be tirggered at this point. So we need to set falg to identify whether this is TaskNotifcation
    or post notification. Since we handled only post notifications till now, Now we need to handle TaskNotification as well.
    During make , All time only Task Notification will be processed but dring Approve/reject/return post notifications will b triggered.
    *)
    bIsTaskNotification := False;
    if sIndexNo <> '1' then
    begin
      if bIsParentTask then
         bNotify := True
      else
      begin
        //Notify must triggered only if tasknotification has value.
        //this cannot be checked for parent task / return task since during that time we will fecth task details from axactivetasks
        //but normally we fecth task details from axprocessdefv2. This has been handled accordinly.
        sTaskNotification := pPegGetActiveXDS.CDS.FieldByName('tasknotification').AsString;
        if sTaskNotification <> '' then
           bNotify := True;
      end;
      if bNotify then
        bIsTaskNotification := True;
    end;

    if ((bRemind) or (bEscalate) or (bNotify)) then
      PublishMessageToRMQ(sTaskId, sTransId, sProcessName, sTaskName,
        sKeyField,sKeyValue,bRemind,bEscalate,{False}bNotify,bUseBusinessdateLogic);
    //PublishtoRMQ ends

    //DoAutoApprovalForOrphanTasks
    if bIsPEGV2 and (Not bIsParentTask) then
    begin
      bautoapproval := False;
      //if auto approve is enabled
      if lowercase(sTaskType) = 'approve' then
        bautoapproval := LowerCase(pPegGetActiveXDS.CDS.FieldByName('autoapprove').AsString) = 't';
      if bautoapproval then
      begin
        //Auto Approve with in the Group with prior task may need to be handled separately if auto approve comes in middle level
        CallPEGApproveUsingTaskId(sTaskId);
      end
      else
      begin
        borphan_autoapproval := LowerCase(pPegGetActiveXDS.CDS.FieldByName('orphan_autoapproval').AsString) = 't';
        if borphan_autoapproval then
          DoAutoApprovalForOrphanTasks(sTransId,sTaskId,sProcessName,sTaskname,sKeyField,sKeyValue);
      end;
    end;

  end;
  Except on E:Exception do
  begin
    Result := '';
    structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks/Error '+E.Message);
  end;
  end;
  finally
    bautoapproval := False;
    bIsTaskNotification := False;
    if Assigned(PegActiveTaskXDS) then
    begin
      //if PegActiveTaskXDS.Active then
        PegActiveTaskXDS.close;
      FreeAndNil(PegActiveTaskXDS);
    end;
    if Assigned(slDisplayContents) then
      FreeAndNil(slDisplayContents);
  end;

  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTasks ends.');
end;


//GetSameIndexTaskNames
Function TAxPEG.GetSameIndexTaskNames(pCurProcessName,pCurTaskname,pCurIndex: String):String;
var
  getTaskNameXDS : TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSameIndexTaskNames starts...');
  try
  Result := '';
  getTaskNameXDS := nil;
  try
    getTaskNameXDS := structdef.axprovider.dbm.GetXDS(nil);
    getTaskNameXDS.buffered := true;
    getTaskNameXDS.CDS.CommandText := 'select * from AxProcessDef where ' +
       structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +(quotedstr(lowercase(pCurProcessName))) +' and '+
       structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' and '+
       structdef.axprovider.dbm.gf.sqllower+'(Taskname)<>'+QuotedStr(lowercase(pCurTaskname))+ ' and '+
       'IndexNo = ' + pCurIndex;
    getTaskNameXDS.open;
    if (getTaskNameXDS.CDS.RecordCount > 0) then //if rec found with same index
    begin
       Result := '';
       getTaskNameXDS.First;
       while Not getTaskNameXDS.CDS.Eof do
       begin
         Result := Result+','+QuotedStr(getTaskNameXDS.CDS.FieldByName('TaskName').AsString);
         getTaskNameXDS.CDS.Next;
       end;
       Delete(Result,1,1);
    end;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetSameIndexTaskNames '+E.Message);
  end;
  finally
    if Assigned(getTaskNameXDS) then
      FreeAndNil(getTaskNameXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSameIndexTaskNames ends.');
end;


//IsSameIndexTaskExistsAndActive - Copied from ASBPegRestObj
Function TAxPEG.IsSameIndexTaskExistsAndActive(pCurProcessName,pTaskname,pCurIndex: String):Boolean;
var
  CheckStatusXDS : TXDS;
  sTaskId,sTaskName,sProcessName : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('IsSameIndexTaskExistsAndActive starts...');
  try
    Result := False;
    CheckStatusXDS := nil;
    try
    sTaskName := GetSameIndexTaskNames(pCurProcessName,pTaskname,pCurIndex);
    if sTaskName <> '' then
    begin
       CheckStatusXDS := structdef.axprovider.dbm.GetXDS(nil);
       CheckStatusXDS.buffered := true;
       CheckStatusXDS.CDS.CommandText :=
       'select TaskId from AxActiveTasks a where '+
       structdef.axprovider.dbm.gf.sqllower + '(ProcessName) = ' +(quotedstr(lowercase(pCurProcessName))) +' and '+
       structdef.axprovider.dbm.gf.sqllower + '(TaskName) in (' +(lowercase(sTaskName))+') and '+
       structdef.axprovider.dbm.gf.sqllower + '(Keyvalue) = ' +(lowercase(QuotedStr(sPEGGlobalKeyValue)))+' and '+
       ' not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid )';
       CheckStatusXDS.open;
       if CheckStatusXDS.CDS.RecordCount > 0 then //If same index record is pending with action
        Result := True;
    end
    else
      Exit;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in IsSameIndexTaskExistsAndActive '+E.Message);
    end;
  finally
    if Assigned(CheckStatusXDS) then
      FreeAndNil(CheckStatusXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsSameIndexTaskExistsAndActive ends.');
end;



//GetNextTask
(*
Make should processed in an order , index & subindex
or else fetching tasks based on subindex may fail. In that case we may need to add function to check
is all same index tasks gets completed.
*)
Function TAxPEG.GetNextTask(pCurTaskName, pCurProcessName,
  pTransid: String): TXDS;
var
  sNextTaskExpr, sApplicabilityExpr, sNextTask: String;
  iCurIndexNo,iCurSubIndexNo: Integer;
  {bIsMakeType,}bNextTaskFound, bApplicability,bIsFirstTime: boolean;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask starts...');
  try
    result := nil;
    sNextTask := '';
    bNextTaskFound := false;
    bApplicability := false;
    //bIsMakeType := false;
    bIsFirstTime := True;
    result := structdef.axprovider.dbm.GetXDS(nil);
    result.buffered := true;
    result.CDS.CommandText := 'select * from AxProcessDef where ' +
      structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
      (quotedstr(lowercase(pCurProcessName))) + ' and '+
      structdef.axprovider.dbm.gf.sqllower + '(active)=' + (quotedstr('t')) +
      ' order by IndexNo,SubIndexNo asc';
    result.open;
    if result.CDS.RecordCount > 0 then
      result.CDS.First;
    While Not result.Eof do // if getNextTaskXDS.CDS.RecordCount > 0 then
    begin
      result.CDS.Filtered := false;
      result.CDS.Filter := structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +
        quotedstr(lowercase(pCurTaskName));
      result.CDS.Filtered := true;

      sNextTaskExpr := result.CDS.FieldByName('NextTask').AsString;
      iCurIndexNo := result.CDS.FieldByName('IndexNo').AsInteger;
      //bIsMakeType := LowerCase(result.CDS.FieldByName('TaskType').AsString)='make';
      if sNextTaskExpr <> '' then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Evaluating next task expression : ' +
          sNextTaskExpr);
        //if Assigned(SDEvaluateExpr) then
        begin
          sNextTask := EvalExpr(sNextTaskExpr);//SDEvaluateExpr(sNextTaskExpr);
          if sNextTask <> '' then
          begin
            result.CDS.Filtered := false;
            // if required TaskType filter has to be added.
            result.CDS.Filter := structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +
              quotedstr(lowercase(sNextTask));
            result.CDS.Filtered := true;
            if result.CDS.RecordCount > 0 then
              bNextTaskFound := true
            else
              raise exception.Create('Task ' + sNextTask + ' not found.');
          end;
        end
        //else
          //raise exception.Create('SDEvaluateExpr is not assigned.');
      end;
      if Not bNextTaskFound then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Finding next task using indexno.');
        (*
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Checking for SameIndex and it''s status.');
        if IsSameIndexTaskExistsAndActive(pCurProcessName,pCurTaskName,InttoStr(iCurIndexNo)) then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Same IndexNo('+InttoStr(iCurIndexNo)+') found and the task is active. So skipping the GetNextTask process now.');
          result := nil;
          exit;
        end;
        *)
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Finding next task using indexno.'+inttostr(iCurIndexNo));
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ reading subindexno.');
          (*
          This is introduced for,
          when the second level task has more than one subindex and in that when one task getting skipped,
          Then another task should with same index should get processed.
          *)
          //Get Current SubIndexNo
          //Not maketype then getsubindex and process, since for maketype its(subindex) already handled in CanInitPEG
          if {(Not bIsMakeType)}Not bIsFirstTime then  //Bfirsttime flag added | from sd firsttime always will be maketype
          begin
            iCurSubIndexNo := result.CDS.FieldByName('SubIndexNo').AsInteger;
            structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask/ Finding next task using subindexno.'+inttostr(iCurSubIndexNo));
            //if CurrentIndex Has Two More records (same index with diff subindex) then process it here
            result.CDS.Filtered := false;
            result.CDS.Filter := 'IndexNo = ' + inttostr((iCurIndexNo))+' and SubIndexNo = '+InttoStr((iCurSubIndexNo+1));
            result.CDS.Filtered := true;
            if result.CDS.RecordCount > 0 then
              bNextTaskFound := true;
          end;
          if Not bNextTaskFound then
          begin
            // Check record for CurrentIndex + 1
            result.CDS.Filtered := false;
            result.CDS.Filter := 'IndexNo = ' + inttostr((iCurIndexNo + 1));
            result.CDS.Filtered := true;
            if result.CDS.RecordCount > 0 then
              bNextTaskFound := true;
          end;
        end;
      end;
      if bNextTaskFound then
      begin
        sApplicabilityExpr := result.CDS.FieldByName('Applicability').AsString;
        if sApplicabilityExpr <> '' then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg
            ('GetNextTask/ Evaluating  Applicability expression ' +
            sApplicabilityExpr);

          bApplicability := lowercase(EvalExpr(sApplicabilityExpr)) = 't';
          (*
          if Assigned(SDEvaluateExpr) then
          begin
            bApplicability := lowercase(SDEvaluateExpr(sApplicabilityExpr)) = 't';
          end
          else
            raise exception.Create('SDEvaluateExpr is not assigned.');
          *)
        end
        else
          bApplicability := true;
        // If Applicability is empty('') then set bApplicability value as true
        if bApplicability then
        begin
          break; // Exit;
        end
        else
        begin
          pCurTaskName := result.CDS.FieldByName('TaskName').AsString;
          //Refer PEGREST GETNEXTTASK
          //UpdateSkippedTask({result.CDS.FieldByName('TaskId').AsString}sTaskId,result.CDS.FieldByName('KeyField').AsString);
          result.CDS.Filtered := false;
          bNextTaskFound := false;
          bIsFirstTime := False;
        end;
      end
      else
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask : Next task not found.');
        // raise Exception.Create('GetNextTask : Next task not found.');
        exit;
      end;
    end;
    if Not bNextTaskFound then
      structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask : Next task not found.');
  finally

  end;
end;

//MakeTypeRecordExistsInAxActiveTasks
Function TAxPEG.MakeTypeRecordExistsInAxActiveTasks(pProcessName,pTaskName,pIndexNo,pKeyValue: String):Boolean;
var
  checkMakeTypeRecXDS : TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('MakeTypeRecordExistsInAxActiveTasks starts...');
  Result := False;
  checkMakeTypeRecXDS := nil;
  try
  try
    checkMakeTypeRecXDS := structdef.axprovider.dbm.GetXDS(nil);
    checkMakeTypeRecXDS.close;
    checkMakeTypeRecXDS.buffered := True;
    checkMakeTypeRecXDS.CDS.CommandText := 'select * from AxActiveTasks where '+
              structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
              structdef.axprovider.dbm.gf.sqllower+'(Taskname)<>'+QuotedStr(lowercase(pTaskName))+ ' and '+
              structdef.axprovider.dbm.gf.sqllower+'(Keyvalue)<>'+QuotedStr(lowercase(pKeyValue))+ ' and '+
              'indexno='+pIndexNo; //Tasktype ='make'
    checkMakeTypeRecXDS.open;
    if checkMakeTypeRecXDS.CDS.RecordCount > 0 then
      Result := True;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('MakeTypeRecordExistsInAxActiveTasks/Error : '+E.Message);
  end;
  finally
    if Assigned(checkMakeTypeRecXDS) then
      FreeAndNil(checkMakeTypeRecXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('MakeTypeRecordExistsInAxActiveTasks ends.');
end;


//CanInitiatePEG | Modified on 13112023
Function TAxPEG.CanInitiatePEG(pProcessName,pTaskName,pIndexNo,pKeyValue : String): Boolean;
var
  SameMakeIndexXDS,CanInitPEGXDS : TXDS;
  sProcessName,sTaskName,sTransId,sKeyField,sKeyValue,sIndexNo : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('CanInitiatePEG starts...');
  Result := True;
  CanInitPEGXDS := nil;
  SameMakeIndexXDS := nil;
  try
  try
  //Adding same index process records into AxActive Tasks if not exists starts
  SameMakeIndexXDS := structdef.axprovider.dbm.GetXDS(nil);
  SameMakeIndexXDS.close;
  SameMakeIndexXDS.buffered := True;
  //Handled only PEG V2, since V1 is deprecated
//  SameMakeIndexXDS.CDS.CommandText := 'select * from AxProcessDefv2 a where '+
//              structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+' and '+
//              structdef.axprovider.dbm.gf.sqllower+'(Taskname) <>'+QuotedStr(lowercase(pTaskName))+ ' and '+
//              structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' and '+
//              ' indexno = '+pIndexNo+' and '+
//              ' not exists (select taskname from AxActiveTasks b where a.taskname=b.taskname  and '+
//              structdef.axprovider.dbm.gf.sqllower+'(b.keyvalue) = '+QuotedStr(lowercase(pKeyValue))+' and '+
//              ' indexno = '+pIndexNo+') '+
//              ' order by IndexNo,SubIndexNo asc';

  SameMakeIndexXDS.CDS.CommandText :=
            //'SELECT pdv.*, ppm.powner as processowner , ppm.pownerflg as processownerflg '+
            //Changing column order to avoid same columns from AxprocessDefV2
            'SELECT ppm.powner as processowner , ppm.pownerflg as processownerflg,pdv.* '+
            ' FROM AxprocessDefV2 pdv '+
            ' JOIN axpdef_peg_processmaster ppm ON pdv.processname = ppm.caption '+
            ' WHERE '+
              structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+' and '+
              structdef.axprovider.dbm.gf.sqllower+'(Taskname) <>'+QuotedStr(lowercase(pTaskName))+ ' and '+
              structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' and '+
              ' indexno = '+pIndexNo+' and '+
              ' not exists (select taskname from AxActiveTasks b where pdv.taskname=b.taskname  and '+
              structdef.axprovider.dbm.gf.sqllower+'(b.keyvalue) = '+QuotedStr(lowercase(pKeyValue))+' and '+
              ' indexno = '+pIndexNo+') '+
              ' order by IndexNo asc';

  SameMakeIndexXDS.open;
  if SameMakeIndexXDS.CDS.RecordCount > 0 then
  begin
    SameMakeIndexXDS.CDS.First;
    //AddToAxActiveTasks if not exists
    while Not SameMakeIndexXDS.CDS.eof do
    begin
      AddRecToAxActiveTasks(SameMakeIndexXDS,'0','');
      SameMakeIndexXDS.CDS.Next;
    end;
  end;
  //Adding same index process records into AxActive Tasks if not exists ends

  //Checking is there any same index tasks pending with action , if found then skip get next tasks until all tasks gets completed
  CanInitPEGXDS := structdef.axprovider.dbm.GetXDS(nil);
  CanInitPEGXDS.close;
  CanInitPEGXDS.buffered := True;
  CanInitPEGXDS.CDS.CommandText := 'Select * from AxActiveTasks a where '+
    structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
    structdef.axprovider.dbm.gf.sqllower+'(Keyvalue) = '+QuotedStr(lowercase(pKeyValue))+' and '+
    ' indexno='+pIndexNo+' and '+
    ' not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid)';
  CanInitPEGXDS.open;
  if CanInitPEGXDS.CDS.RecordCount > 0  then //if rec found then continue
    Result := False
  else
    Result := True;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('CanInitiatePEG/ Error '+E.Message);
  end;
  finally
    if Assigned(SameMakeIndexXDS) then
      FreeAndNil(SameMakeIndexXDS);
    if Assigned(CanInitPEGXDS) then
      FreeAndNil(CanInitPEGXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('CanInitiatePEG ends.');
end;

//PegInit
Procedure TAxPEG.PegInit(pPegXDS : TXDS);
var
  sCurProcIndexNo,sNextProcIndexNo,sCurProcTaskName : String;
  sCurProcessname,sKeyField,sKeyValue : String;
  PegGetActiveXDS : TXDS;

  bIsFirstTime,bApplicability : Boolean;
  sApplicabilityExpr : String;
begin
  PegGetActiveXDS := nil;
  if Not Assigned(pPegXDS) then
    Exit;
  structdef.axprovider.dbm.gf.DoDebug.msg('PegInit starts...');
  try
  PegGetActiveXDS := structdef.axprovider.dbm.GetXDS(nil);
  begin
    sCurProcIndexNo := pPegXDS.cds.Fieldbyname('IndexNo').AsString;
    sCurProcTaskName := pPegXDS.cds.Fieldbyname('Taskname').AsString;
    sCurProcessname := pPegXDS.cds.Fieldbyname('ProcessName').AsString;

    sKeyField := pPegXDS.cds.Fieldbyname('KeyField').AsString;
    sKeyValue := GetFieldValue(sKeyField,1);
    sNextProcIndexNo :=  InttoStr(StrtoInt(sCurProcIndexNo)+1); //CurrentIndexNo + 1

    //Add record to AxActiveTasks | All Same index make type data processed or not
    if CanInitiatePEG(sCurProcessname,sCurProcTaskName,sCurProcIndexNo,sKeyValue) then
    begin
      PegGetActiveXDS := GetNextTask(sCurProcTaskName,pPegXDS.cds.Fieldbyname('ProcessName').AsString,transtype);
      if Assigned(PegGetActiveXDS) and (PegGetActiveXDS.CDS.RecordCount > 0) then
      begin
        PegGetActiveXDS.CDS.First;
        bIsFirstTime := True;
        bApplicability := True;
        sApplicabilityExpr := '';
        while Not PegGetActiveXDS.CDS.EOF do
        begin
          (*
          When subindex having applicablity ,then only first subindex applicablity getting evaluated in the GetNextTasks.
          The remaining subindex task applicablity not evalauated.
          That has been handled here.
          For the first time applicablity expression not required since it will be evaluated in getNextTasks itself.
          For the remaining sundeindex tasks we are handling here.  The same to be handled in AsbPEGRest also.
          *)
          if Not bIsFirstTime then // Not Firsttime
          begin
            sApplicabilityExpr := PegGetActiveXDS.CDS.FieldByName('Applicability').AsString;
            if sApplicabilityExpr <> '' then
            begin
              structdef.axprovider.dbm.gf.DoDebug.msg
                ('PegInit/ Evaluating  Applicability expression ' +
                sApplicabilityExpr);

              bApplicability := lowercase(EvalExpr(sApplicabilityExpr)) = 't';
              (*
              if Assigned(SDEvaluateExpr) then
              begin
                bApplicability := lowercase(SDEvaluateExpr(sApplicabilityExpr)) = 't';
              end
              else
                structdef.axprovider.dbm.gf.DoDebug.msg('PegInit/SDEvaluateExpr is not assigned.');
              *)
            end
            else
              bApplicability := true;
          end;
          if bApplicability then
            AddRecToAxActiveTasks(PegGetActiveXDS,sCurProcIndexNo,sCurProcTaskName);
          PegGetActiveXDS.CDS.Next;
          bIsFirstTime := False;
        end;
      end;
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('PegInit ends.');
  finally
    if Assigned(PegGetActiveXDS) then
    begin
      if PegGetActiveXDS.Active then
        PegGetActiveXDS.close;
      FreeAndNil(PegGetActiveXDS);
    end;
  end;
end;


//Update PEG status to AxPeg_Transid table
Procedure TAxPEG.UpdatePEGStatusInAxPegTransTable(inpXDS: TXDS;pStatus : String);
var
  PegActiveTaskXDS: TXDS;
  sSQLText,sTableName,sProcessName,sTaskName,sStatus,sStatusText,wstr : String;
  sRecordId,sKeyField,sKeyValue,sDBType : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('UpdatePEGStatusInAxPegTransTable starts...');
  PegActiveTaskXDS := nil;
  if Not Assigned(inpXDS) or (inpXDS.CDS.RecordCount = 0) then
    exit;
  sDBType := structdef.axprovider.dbm.Connection.DbType;
  //Create table if not found | Table check need to be handled in someother way
  sTableName := 'axpeg_'+TransType;
  if Not structdef.axprovider.TableFound(sTableName) then
  begin
    if (sDBType = 'ms sql') or (sDBType = 'mysql') or (sDBType = 'postgre') then
      sSQLText := 'Create table '+sTableName+'(EventDateTime varchar(30),Transid varchar(5),ProcessName varchar(200),KeyValue varchar(500), Recordid Numeric(16),Status Numeric(1),StatusText Varchar(4000),WithDrawn Varchar(1))'
    else if (sDBType = 'oracle') then
      sSQLText := 'Create table '+sTableName+'(EventDateTime varchar2(30),Transid varchar(5),ProcessName varchar2(200),KeyValue varchar2(500),Recordid Number(16),Status Number(1),StatusText Varchar2(4000),WithDrawn Varchar2(1))';
    try
      structdef.axprovider.ExecSQL(sSQLText,'','',false);
      structdef.axprovider.dbm.gf.doDebug.Msg('Firing SQL '+ sSQLText+' <OK>');
    Except on e:exception do
      begin
        structdef.axprovider.dbm.gf.doDebug.Msg('Firing SQL '+ sSQLText+' <error> '+E.Message);
        Exit;
      end;
    end;
  end;

  try
    structdef.axprovider.dbm.gf.DoDebug.msg('Adding recrod to UpdatePEGStatusInAxPegTransTable');
    PegActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegActiveTaskXDS.close;
    PegActiveTaskXDS.submit('EventDateTime', GetPEGTaskEventDateTime{structdef.axprovider.dbm.gf.GetDateTimeStampString}, 'c');
    PegActiveTaskXDS.submit('Transid', TransType, 'c');
    sProcessName := inpXDS.CDS.FieldByName('ProcessName').AsString;
    sTaskName := inpXDS.CDS.FieldByName('TaskName').AsString;
    PegActiveTaskXDS.submit('ProcessName', sProcessName, 'c');
    sKeyField := inpXDS.CDS.FieldByName('KeyField').AsString;
    sKeyValue := GetFieldValue(sKeyField,1);
    PegActiveTaskXDS.submit('KeyValue', sKeyValue, 'c');
    sRecordId := FloattoStr(LastSavedRecordId);
    PegActiveTaskXDS.submit('Recordid', sRecordId, 'n');
    if LowerCase(pStatus) = 'approved' then
    begin
      sStatus := '1';
      sStatusText := 'Task '+sTaskName+' is approved by '+structdef.axprovider.dbm.gf.UserName+'.';
    end
    else if LowerCase(pStatus) = 'rejected' then
    begin
      sStatus := '2';
      sStatusText := 'Task '+sTaskName+' is rejected by '+structdef.axprovider.dbm.gf.UserName+'.';
    end
    else
    begin
      sStatus := '0';//InProgress
      sStatusText := sProcessName+' process is in progress.';
    end;
    PegActiveTaskXDS.submit('Status', sStatus, 'n');
    PegActiveTaskXDS.submit('StatusText', sStatusText, 'c');
    //wstr := ' ProcessName = '+QuotedStr(sProcessName)+' and Recordid = '+sRecordId;
    wstr := ' ProcessName = '+QuotedStr(sProcessName)+' and KeyValue = '+QuotedStr(sKeyValue);
    PegActiveTaskXDS.AddOrEdit(sTableName,wstr);
  finally
    if Assigned(PegActiveTaskXDS) then
      FreeAndNil(PegActiveTaskXDS);
  end;

  structdef.axprovider.dbm.gf.DoDebug.msg('UpdatePEGStatusInAxPegTransTable ends.');
end;


//AddRecToAxProcess
//IF THIS METHOD IS NOT USED THEN IT CAN BE REMOVED IN THE NEXT RELEASE.
Procedure TAxPEG.AddRecToAxProcess(inpXDS: TXDS;pTaskId,pStatus : String);
var
  PegActiveTaskXDS: TXDS;
  sTaskId,sProcessName,sKeyField,sKeyValue,wstr,sAxProcessTableName : String;
  sDisplayTextDetails,sDisplayIcon,sDisplayTitle,sTimeLineTitle : String;
  sTaskName,sTaskType,sIndexNo : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxProcess starts...');
  PegActiveTaskXDS := nil;
  if Not Assigned(inpXDS) or (inpXDS.CDS.RecordCount = 0) then
    exit;
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('Adding recrod to AddRecToAxProcess');
    sAxProcessTableName := '';
    try
      sProcessName := inpXDS.CDS.FieldByName('ProcessName').AsString;
      sTaskName := inpXDS.CDS.FieldByName('TaskName').AsString;
      sTaskType := inpXDS.CDS.FieldByName('TaskType').AsString;
      sKeyField := inpXDS.CDS.FieldByName('KeyField').AsString;
      sKeyValue := GetFieldValue(sKeyField,1);
      sIndexNo := inpXDS.CDS.FieldByName('IndexNo').AsString;

      // We use AxProcess table Temporarily, Later this will be taken from Process Master
      //sAxProcessTableName := 'AxProcess';

      sAxProcessTableName := GetProcessTable(sProcessName);
      if sAxProcessTableName = '' then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('Process Table name not defined in the process master.');
        Exit;
      end;

      if pTaskId = '' then
        pTaskId := GetTaskId(TransType,sProcessName,sTaskName,sTaskType,sKeyValue,sIndexNo);

      PegActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
      PegActiveTaskXDS.close;
      PegActiveTaskXDS.submit('EventDateTime', GetPEGTaskEventDateTime{structdef.axprovider.dbm.gf.GetDateTimeStampString}, 'c');
      if pTaskId = '' then
        sTaskId := floatTostr(structdef.axprovider.dbm.Gen_id(structdef.axprovider.dbm.connection))
      else
        sTaskId := pTaskId;
      PegActiveTaskXDS.submit('TaskId',sTaskId,'c') ;
      PegActiveTaskXDS.submit('Transid', TransType, 'c');
      PegActiveTaskXDS.submit('ProcessName', sProcessName, 'c');
      PegActiveTaskXDS.submit('TaskName', sTaskName{inpXDS.CDS.FieldByName('TaskName').AsString}, 'c');
      //sKeyField := inpXDS.CDS.FieldByName('KeyField').AsString;
      //sKeyValue := GetFieldValue(sKeyField,1);
      PegActiveTaskXDS.submit('KeyValue', sKeyValue, 'c');
      PegActiveTaskXDS.submit('TaskStatus', pStatus, 'c');

      PegActiveTaskXDS.submit('TaskType', sTaskType{inpXDS.CDS.FieldByName('TaskType').AsString}, 'c');
      PegActiveTaskXDS.submit('UserName', structdef.axprovider.dbm.gf.username, 'c');
      PegActiveTaskXDS.submit('NextTask', ''{sPEGNextTasks}, 'c');


      if bIsPEGV2 then
      begin
        //TimelineTitle
        sTimeLineTitle := inpXDS.CDS.FieldByName('TimelineTitle').AsString;
        //GetDisplayText Details
        sDisplayTextDetails := GetDisplayTextDetails(sTaskId);
      end;

      sDisplayIcon := structdef.axprovider.dbm.gf.GetNthString(sDisplayTextDetails,1,'$#$');
      sDisplayTitle := structdef.axprovider.dbm.gf.GetNthString(sDisplayTextDetails,2,'$#$');
      PegActiveTaskXDS.submit('displayicon', sDisplayIcon, 'c');
      PegActiveTaskXDS.submit('displaytitle', sDisplayTitle, 'c');

      PegActiveTaskXDS.submit('RecordId',FloattoStr(LastSavedRecordId), 'n');
      PegActiveTaskXDS.submit('KeyField', sKeyField{inpXDS.CDS.FieldByName('KeyField').AsString}, 'c');
      PegActiveTaskXDS.submit('IndexNo', sIndexNo{inpXDS.CDS.FieldByName('IndexNo').AsString}, 'n');

      PegActiveTaskXDS.submit('TimelineTitle', sTimeLineTitle, 'c');

      //Each process task status should get updated.
      //wstr := ' ProcessName = '+QuotedStr(sProcessName)+' and KeyValue = '+QuotedStr(sKeyValue);
      wstr := '1=2';
      PegActiveTaskXDS.AddOrEdit(sAxProcessTableName,wstr);
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\AddRecToAxProcess - '+e.Message);
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\AddRecToAxProcess - '+e.Message);
    end;
    end;
  finally
    if Assigned(PegActiveTaskXDS) then
      FreeAndNil(PegActiveTaskXDS);
  end;

  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxProcess ends.');
end;

//GetTaskId
Function TAxPEG.GetTaskId(pTransId,PProcessName,pTaskName,pTaskType,pKeyValue,pIndexNo : String):String;
var
  PegGetTaskIDXDS: TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskId starts...');
  Result := '';
  PegGetTaskIDXDS := nil;
  try
    PegGetTaskIDXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegGetTaskIDXDS.buffered := True;
    if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
      PegGetTaskIDXDS.CDS.CommandText :=  ' WITH FilteredTasks AS ( '+
                                                 ' SELECT a.TaskId, a.eventdatetime, a.IndexNo, a.SubIndexNo '+
                                                 ' FROM AxActiveTasks a '+
                                                 ' WHERE lower(ProcessName) = '+QuotedStr(lowercase(PProcessName))+
                                                 ' AND lower(Taskname) = '+QuotedStr(lowercase(pTaskName))+
                                                 ' AND lower(TaskType) = '+QuotedStr(lowercase(pTaskType))+
                                                 ' AND lower(KeyValue) = '+QuotedStr(lowercase(pKeyValue))+
                                                 ' AND lower(Transid) = '+QuotedStr(lowercase(pTransId))+
                                                 ' AND IndexNo = '+pIndexNo+
                                                 ' AND NOT EXISTS ( '+
                                                  ' SELECT 1 '+
                                                   ' FROM AxActiveTaskStatus b '+
                                                    ' WHERE a.taskid = b.taskid '+
                                                   ' ) '+
                                               ' ) '+
                                               ' SELECT TaskId '+
                                               ' FROM FilteredTasks '+
                                               ' ORDER BY eventdatetime, IndexNo, SubIndexNo DESC'
    else
      PegGetTaskIDXDS.CDS.CommandText := 'Select TaskId from AxActiveTasks a where '+
                structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(PProcessName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Taskname)='+QuotedStr(lowercase(pTaskName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(TaskType)='+QuotedStr(lowercase(pTaskType))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(pKeyValue))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Transid)='+QuotedStr(lowercase(pTransId))+ ' and '+
                'IndexNo='+pIndexNo+   //below exists condition newly added to handle return when re intiating the process
                ' and not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid '+
                ' order by eventdatetime,IndexNo,SubIndexNo desc)';

    PegGetTaskIDXDS.open;
    if PegGetTaskIDXDS.CDS.RecordCount > 0 then
       Result := PegGetTaskIDXDS.CDS.FieldByName('TaskId').AsString;
  finally
    if Assigned(PegGetTaskIDXDS) then
      FreeAndNil(PegGetTaskIDXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskId ends.');
end;

//AddRecToAxActiveTaskStatus
Function TAxPEG.AddRecToAxActiveTaskStatus(inpXDS: TXDS;pTaskId,pStatus : String):String;
var
  PegActiveTaskXDS: TXDS;
  sTaskId,sSubIndexNo,sKeyField,sKeyValue : String;
  sProcessName,sTaskName,sIndexNo,sTaskType : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTaskStatus starts...');
  result := '';
  PegActiveTaskXDS := nil;
  if Not Assigned(inpXDS) or (inpXDS.CDS.RecordCount = 0) then
    exit;
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('Adding recrod to AxActiveTaskStatus');

    sProcessName := inpXDS.CDS.FieldByName('ProcessName').AsString;
    sTaskName := inpXDS.CDS.FieldByName('TaskName').AsString;
    sTaskType := inpXDS.CDS.FieldByName('TaskType').AsString;
    sKeyField := inpXDS.CDS.FieldByName('KeyField').AsString;
    sKeyValue := GetFieldValue(sKeyField,1);
    sIndexNo := inpXDS.CDS.FieldByName('IndexNo').AsString;

    if pTaskId = '' then
      pTaskId := GetTaskId(TransType,sProcessName,sTaskName,sTaskType,sKeyValue,sIndexNo);

    if pTaskId = '' then
      sTaskId := floatTostr(structdef.axprovider.dbm.Gen_id(structdef.axprovider.dbm.connection))
    else
      sTaskId := pTaskId;

    PegActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegActiveTaskXDS.Append('AxActiveTaskStatus');
    PegActiveTaskXDS.submit('EventDateTime', GetPEGTaskEventDateTime{structdef.axprovider.dbm.gf.GetDateTimeStampString}, 'c');

    PegActiveTaskXDS.submit('TaskId',sTaskId,'c') ;
    PegActiveTaskXDS.submit('Transid', TransType, 'c');

    PegActiveTaskXDS.submit('KeyField', sKeyField, 'c');
    PegActiveTaskXDS.submit('KeyValue', sKeyValue, 'c');
    PegActiveTaskXDS.submit('RecordId',FloattoStr(LastSavedRecordId), 'n');
    PegActiveTaskXDS.submit('TaskStatus', pStatus, 'c');
    PegActiveTaskXDS.submit('Username', structdef.axprovider.dbm.gf.UserName, 'c');
    PegActiveTaskXDS.submit('ProcessName', sProcessName, 'c');
    PegActiveTaskXDS.submit('TaskName', sTaskName, 'c');
    PegActiveTaskXDS.submit('TaskType', sTaskType, 'c');
    PegActiveTaskXDS.submit('IndexNo', sIndexNo, 'n');
    sSubIndexNo := inpXDS.CDS.FieldByName('SubIndexNo').AsString;
    if sSubIndexNo = '' then
      sSubIndexNo := '1';
    PegActiveTaskXDS.submit('SubIndexNo', sSubIndexNo, 'n');
    PegActiveTaskXDS.submit('PriorIndex', '0', 'n');
    if (LowerCase(pStatus) = 'cancelled') then
    begin
      PegActiveTaskXDS.submit('cancel', 'T', 'c');
      PegActiveTaskXDS.Submit('cancelremarks',scancelremarks,'c'); //Text field need to be checked whether updating or not
      PegActiveTaskXDS.Submit('cancelledby',scancelledby,'c');
      PegActiveTaskXDS.Submit('cancelledon',scancelledon
      ,'d');//DateTime field
    end;
    PegActiveTaskXDS.post;
    Result := sTaskId;
	if (LowerCase(pStatus) <> 'skipped') and (LowerCase(pStatus) <> 'cancelled') then
	begin
    	//AddRecToAxProcess(inpXDS,sTaskId,pStatus);
	    UpdatePEGStatusInAxPegTransTable(inpXDS,pStatus);
      if bIsPEGV2 then
        AddRecToAxActiveTaskParams(inpXDS,sTaskId,pStatus);
	end;
  finally
    if Assigned(PegActiveTaskXDS) then
      FreeAndNil(PegActiveTaskXDS);
  end;

  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTaskStatus ends.');
end;

(*
CheckAxProcessDef
ProcDefResult = Select * from AxProcessDef where transid=:giventransid and active = T and tasktype=make
*)
Procedure TAxPEG.CheckAxProcessDef;
var
  pegXDS : TXDS;
  sApplicabilityExpr,sProcessName,sTaskName,sIndexNo,sStatus,sKeyField,sTaskId : String;
  bApplicability : Boolean;
begin
  try
    //PEG VERSION 2.0 TEST
    sPEGGlobalKeyValue := '';
    sPEGTask_EventDateTime := '';
    pegXDS := structdef.axprovider.CheckAxProcessDef(transtype,'v2'); //structdef.axprovider.CheckAxProcessDef(transtype);
    //if pegXDS.CDS.RecordCount > 0 then
       //sProcessName := pegXDS.CDS.FieldByName('ProcessName').AsString;
    //bIsPEGV2 := IsPEGV2Process(sProcessName);
    if Assigned(pegXDS) and (pegXDS.CDS.RecordCount > 0) then
      bIsPEGV2 := True;
    if bIsPEGV2 then
    begin
      CheckAxProcessDef_PEGV2;
      Exit;
    end;
    //PEG VERSION 2.0 TEST
    //If the transaction is peg attached transaction then continue or exit.
    structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef starts...');
    try
      //the below CheckAxProcessDef may not be needed  since we already checked and got xds at begining itself.
      pegXDS := structdef.axprovider.CheckAxProcessDef(transtype,'v1');
      if Assigned(pegXDS) and (pegXDS.CDS.RecordCount > 0) then
      begin
        pegXDS.CDS.First;
        while Not pegXDS.CDS.EOF do
        begin
          sProcessName := pegXDS.CDS.FieldByName('ProcessName').AsString;
          sTaskName := pegXDS.CDS.FieldByName('TaskName').AsString;
          sIndexNo := pegXDS.CDS.FieldByName('IndexNo').AsString;
          sKeyField := pegXDS.CDS.FieldByName('KeyField').AsString;
          sPEGGlobalKeyValue  := GetFieldValue(sKeyField,1);
          structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef/ProcessName '+sProcessName);
          //Check applicablity for make type record
          bApplicability := False;
          sApplicabilityExpr := pegXDS.CDS.FieldByName('Applicability').AsString;
          if sApplicabilityExpr <> '' then
          begin
            structdef.axprovider.dbm.gf.DoDebug.msg
              ('GetNextTask/ Evaluating  Applicability expression ' +
              sApplicabilityExpr);
            bApplicability := lowercase(EvalExpr(sApplicabilityExpr)) = 't'
            (*
            if Assigned(SDEvaluateExpr) then
              bApplicability := lowercase(SDEvaluateExpr(sApplicabilityExpr)) = 't'
            else
              raise exception.Create('SDEvaluateExpr is not assigned.');
            *)
          end
          else
            bApplicability := True;
          // If Applicability is empty('') then set bApplicability value as true
          if Not bApplicability then
          begin
             structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef/Applicablity is false, so Skipping PEG init for this transaction.');
             sStatus := 'skipped';
          end
          else
          begin
            bIsCurrentPEGTask := True;
            sTaskId := AddRecToAxActiveTasks(pegXDS,{sIndexNo}'0',{sTaskName}'');
            bIsCurrentPEGTask := False;
            sStatus := 'made';
          end;
          sTaskId := AddRecToAxActiveTaskStatus(pegXDS,sTaskId,sStatus);
          if sStatus = 'made' then
            PegInit(pegXDS);
          AddRecToAxProcess(pegXDS,sTaskId,sStatus);
          pegXDS.CDS.Next;
        end;
      end;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\CheckAxProcessDef - '+e.Message);
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\CheckAxProcessDef - '+e.Message);
    end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef ends.');
  finally
    if Assigned(pegXDS) then
    begin
      if pegXDS.Active then pegXDS.close;
      FreeAndnil(pegXDS);
    end;
  end;
end;


//GetKeyField
Function TAxPEG.GetKeyField:String;
var
  PegGetKeyFieldXDS : TXDS;
  sTablename : String;
begin
  PegGetKeyFieldXDS := nil;
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetKeyField starts...');
  try
  PegGetKeyFieldXDS := structdef.axprovider.dbm.GetXDS(nil);
  PegGetKeyFieldXDS.close;
  PegGetKeyFieldXDS.buffered := True;
  //Key field can be read from axprocessdef
  //PegGetKeyFieldXDS.cds.CommandText := 'Select * from AxActiveTasks where '+structdef.axprovider.dbm.gf.sqllower+
  //                                  '(transid)='+QuotedStr(lowercase(transtype))+' order by EventDateTime desc';
  //ProcessNam filter to be added.
  if bIsPEGV2 then
    sTablename := 'AxProcessDefv2'
  else
    sTableName := 'AxProcessDef';

  if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
     PegGetKeyFieldXDS.cds.CommandText := 'Select KeyField from '+sTableName+
    ' where '+structdef.axprovider.dbm.gf.sqllower+
    '(transid)='+QuotedStr(lowercase(transtype))+
    ' and keyfield is not null and '+
    structdef.axprovider.dbm.gf.sqllower+'(active) = ''t'''
  (*
  Oracle does, indeed, treat an empty string as NULL. This includes in comparisons, so:
  where mycolumn = ''
  is the same as:
  where mycolumn = NULL
  *)
  else
    PegGetKeyFieldXDS.cds.CommandText := 'Select KeyField from '+sTableName+
    ' where '+structdef.axprovider.dbm.gf.sqllower+
    '(transid)='+QuotedStr(lowercase(transtype))+
    ' and keyfield is not null and keyfield <> '''' and '+
    structdef.axprovider.dbm.gf.sqllower+'(active) = ''t''';

  PegGetKeyFieldXDS.open;
  if PegGetKeyFieldXDS.CDS.RecordCount > 0 then
      result := PegGetKeyFieldXDS.CDS.FieldByName('KeyField').AsString;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetKeyField ends.');
  finally
    if Assigned(PegGetKeyFieldXDS) then
    begin
      if PegGetKeyFieldXDS.Active then
        PegGetKeyFieldXDS.close;
      FreeAndNil(PegGetKeyFieldXDS);
    end;
  end;
end;


//GetProcessName
Function TAxPEG.GetProcessName(pTransId,pKeyField,pKeyValue : String):String;
var
  PegGetProcessXDS : TXDS;
begin
  PegGetProcessXDS := nil;
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessName starts...');
  try
  try
  PegGetProcessXDS := structdef.axprovider.dbm.GetXDS(nil);
  PegGetProcessXDS.close;
  PegGetProcessXDS.buffered := True;
  //When there are mutiple process for same transation then need to think about handling statusbars
//  PegGetProcessXDS.cds.CommandText := 'Select Processname from AxActiveTasks '+
//    ' where lower(transid)='+QuotedStr(lowercase(transtype))+
//    ' and lower(keyfield) ='+QuotedStr(lowercase(pKeyField))+
//    ' and KeyValue ='+QuotedStr(pKeyValue);

     PegGetProcessXDS.cds.CommandText :=
      ' SELECT DISTINCT a.processname '+
      ' FROM axactivetasks a '+
      ' JOIN axpdef_peg_processmaster p ON a.processname = p.caption '+
      ' WHERE '+
      ' lower(a.transid) = '+QuotedStr(lowercase(transtype))+
      ' AND lower(a.keyfield) = '+QuotedStr(lowercase(pKeyField))+
      ' AND a.keyvalue = '+QuotedStr(pKeyValue)+
      ' AND lower(p.amendment) <> ''t'' ';


  PegGetProcessXDS.open;
  if PegGetProcessXDS.CDS.RecordCount > 0 then
      result := PegGetProcessXDS.CDS.FieldByName('Processname').AsString;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetProcessName '+E.Message);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessName ends.');
  finally
    if Assigned(PegGetProcessXDS) then
    begin
      if PegGetProcessXDS.Active then
        PegGetProcessXDS.close;
      FreeAndNil(PegGetProcessXDS);
    end;
  end;
end;




// IsPegTaskInitiated
(*
Read from AxTaskStatus table. If there is atleast one record for which there is a record in AxTaskStatusStatus table, then load in read only mode.
*)
Function TAxPEG.IsPegTaskInitiated:Boolean;
var
  PegGetTasksXDS : TXDS;
  sKeyField,sTaskName,sProcessName,sIndexNo,sKeyValue : String;
  bGetLastStatusOfPeg,bIsAmendTransReadonly : boolean;
  sCurUserTaskName : string;
begin
  PegGetTasksXDS := nil;
  result := False;
  bGetLastStatusOfPeg := False;
  //If the transaction is peg attached transaction then continue or exit.
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPegTaskInitiated starts...');
  try
  sKeyField := GetKeyField;
  if sKeyField = '' then
  begin
     structdef.axprovider.dbm.gf.DoDebug.msg('Invalid KeyField.');
     Exit;
  end;
  sCurUserTaskName := '';
  sKeyValue := GetFieldValue(sKeyField,1);
  sProcessName := GetProcessName(transtype,sKeyField,sKeyValue);
  PegGetTasksXDS := structdef.axprovider.dbm.GetXDS(nil);
  PegGetTasksXDS.close;
  PegGetTasksXDS.buffered := True;
  PegGetTasksXDS.cds.CommandText :=
//Modified query with amendment check
//Modifying below query since , transid , keyfield and <> make filters may impact when we have multiple makes
  ' SELECT a.* FROM AxActiveTasks a '+
  ' INNER JOIN axpdef_peg_processmaster p '+
   ' ON LOWER(a.processname) = LOWER(p.caption) '+
  ' WHERE LOWER(a.processname) = '+QuotedStr(lowercase(sProcessName))+
  //' AND LOWER(a.transid) = '+QuotedStr(lowercase(transtype))+
  //' AND LOWER(a.KeyField) = '+QuotedStr(lowercase(sKeyField))+
  ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
  //' AND LOWER(a.tasktype) <> ''make'' '+
  ' AND a.IndexNo <> 1 '+//'First Make'
  ' AND NOT EXISTS ( '+
     ' SELECT taskid FROM AxActiveTaskStatus b '+
     ' WHERE a.taskid = b.taskid '+
     //' ORDER BY eventdatetime, IndexNo DESC '+
    ' ) '+
    ' AND (lower(p.amendment) <> ''t'' or p.amendment is null or p.amendment = '''') '+
    ' ORDER BY a.eventdatetime DESC';
    //When parallel tasks are active it has to be handled if needed.

  PegGetTasksXDS.open;

  if PegGetTasksXDS.CDS.IsEmpty then
  begin
    //Is current user involved in the process attached to this TStruct
    begin
      PegGetTasksXDS.close;
      PegGetTasksXDS.buffered := True;
      PegGetTasksXDS.cds.CommandText :=
         'select taskid,taskname from axactivetaskstatus a '+
          ' where LOWER(a.processname) = '+QuotedStr(lowercase(sProcessName))+
          ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
          ' and LOWER(a.transid) = '+QuotedStr(lowercase(transtype))+
          ' and LOWER(a.tasktype) = ''make'' '+
          ' and '+QuotedStr(structdef.axprovider.dbm.gf.username)+' in (a.username) ';
      PegGetTasksXDS.open;
    end;

    //Get the Latest status of process only if the current user involved in the process
    if Not PegGetTasksXDS.CDS.IsEmpty then
    begin
      sCurUserTaskName := PegGetTasksXDS.CDS.FieldByName('Taskname').AsString;
      bGetLastStatusOfPeg := True;
      PegGetTasksXDS.close;
      PegGetTasksXDS.buffered := True;
      PegGetTasksXDS.cds.CommandText :=
       ' SELECT a.*, s.taskstatus, s.statustext, s.username as actuser, s.eventdatetime FROM AxActiveTasks a '+
      ' INNER JOIN axpdef_peg_processmaster p ON LOWER(a.processname) = LOWER(p.caption) '+
      ' INNER JOIN AxActiveTaskStatus s ON a.taskid = s.taskid '+
      ' WHERE LOWER(a.processname) = '+QuotedStr(lowercase(sProcessName))+
      ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
      ' AND LOWER(a.tasktype) <> ''make'' '+ //skip make
      ' and EXISTS (  SELECT taskid  FROM AxActiveTaskStatus b WHERE a.taskid = b.taskid  ) '+
      ' AND (lower(p.amendment) <> ''t'' or p.amendment is null or p.amendment = '''') '+
      ' ORDER BY s.eventdatetime desc ';
      PegGetTasksXDS.open;
    end else begin
      bGetLastStatusOfPeg := True;
      PegGetTasksXDS.close;
      PegGetTasksXDS.buffered := True;
      PegGetTasksXDS.cds.CommandText :=
       ' SELECT a.*, s.taskstatus, s.statustext, s.username as actuser, s.eventdatetime FROM AxActiveTasks a '+
      ' INNER JOIN axpdef_peg_processmaster p ON LOWER(a.processname) = LOWER(p.caption) '+
      ' INNER JOIN AxActiveTaskStatus s ON a.taskid = s.taskid '+
      ' WHERE LOWER(a.processname) = '+QuotedStr(lowercase(sProcessName))+
      ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
      ' AND LOWER(a.tasktype) <> ''make'' '+ //skip make
      //Commented the filter below to get whatever the last status is.
      //' AND LOWER(s.taskstatus) = ''approved'' '+ //skip make
      ' and EXISTS (  SELECT taskid  FROM AxActiveTaskStatus b WHERE a.taskid = b.taskid  ) '+
      ' AND (lower(p.amendment) <> ''t'' or p.amendment is null or p.amendment = '''') '+
      ' ORDER BY s.eventdatetime desc ';
      PegGetTasksXDS.open;
      sCurUserTaskName := PegGetTasksXDS.CDS.FieldByName('Taskname').AsString;
    end;
  end;

  bIsAmendTransReadonly := False;
  // When PEG and Amendment are there , during that time if we load trans then
  // readonly has to be handled even if any one of the flow is enabled
  if (structdef.IsAmendmentEnabled) and (structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans) then
    bIsAmendTransReadonly := True;

  structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := False;
  if PegGetTasksXDS.CDS.RecordCount > 0 then
  begin
    sProcessName := PegGetTasksXDS.CDS.FieldByName('Processname').AsString;
    sTaskname := PegGetTasksXDS.CDS.FieldByName('Taskname').AsString;
    sCurrentPEGInitiator := PegGetTasksXDS.CDS.FieldByName('Initiator').AsString;
    //Set readonly trans for PEG/if active PEG found
    // if not over all status then set readonly ,
    // if we fetch over all status then PEG is not pending with any user except initiator
    if Not bGetLastStatusOfPeg then
      structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := True;
    //if amendment is there then its status will be updated first in the sAxPegStatus
    //so to keep amendment and peg status together and for processing purpose we added in the same varaible
    //This can be splitted and handled in the future if required.
    structdef.axprovider.dbm.gf.sAxPegStatus := structdef.axprovider.dbm.gf.sAxPegStatus+ //amendment status if exists
    '$#*#$'+//separateot for amendment and Peg status
    'false'+'$##$'+ //Is Amendment
     //GetProcessStatus(transtype,sKeyValue); //PEG Status
     GetProcessStatusNew(sCurUserTaskName,transtype,sKeyValue,bGetLastStatusOfPeg,PegGetTasksXDS); //PEG Status | New
  end;

  if (pegLastApproved) or
     (bPEGRejectedOrReturned and (sCurrentPEGInitiator <> structdef.axprovider.dbm.gf.username)) then
        structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := true;


  if structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans then //set based on IsPEGEdit
    //EditForm true -> readonly false | EdiForm false -> readonly true
    structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := Not IsPegEdit;

    (*
     Added on 15/11/2023,
     if PEG & Amendment exists for the same form:
     1- Once PEG returned / withdrawn  then Amendment should start
        We must allow initiator to modify the transaction.
        On modification amendment should start.
        On comlete of Amendment PEG should start.
    *)
    
    if (structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans) and
       (structdef.IsAmendmentEnabled) and
       ( (((bPEGWithdrawn) {or (pegLastApproved)})
        and (sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username))
        or (bPEGRejectedOrReturned
        and (sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username)) )  then
      structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := False;
  //end;


  //Override bAxPegReadOnlyTrans value if amendment enabled and its readonly
  if bIsAmendTransReadonly then
    structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := True;

  Result := structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPegTaskInitiated ends.');
  finally
    if Assigned(PegGetTasksXDS) then
    begin
      if PegGetTasksXDS.Active then
        PegGetTasksXDS.close;
      FreeAndNil(PegGetTasksXDS);
    end;
  end;
end;

//AddPEGConfigs
Procedure TAxPEG.AddPEGConfigs(pProcessName, pTaskName,
  pTransid: String; pDataJson: TJsonObject);
var
  xQry: TXDS;
  sWhrStr, sConfVal: String;
  pair: TJSONPair;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('AddPEGConfigs starts...');
  xQry := nil;
  try

    if Not Assigned(pDataJson) then
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg
        ('AddPEGConfigs/DataJson object is not assigned.');
      exit;
    end;

    xQry := structdef.axprovider.dbm.GetXDS(nil);
    xQry.buffered := True;
    sWhrStr := 'lower(ProcessName) = ' + lowercase(quotedstr(pProcessName)) +
      ' and ' + 'lower(Taskname) = ' + lowercase(quotedstr(pTaskName)) + ' and '
      + 'lower(Transid) = ' + lowercase(quotedstr(pTransid));

    xQry.CDS.CommandText :=
      'select returnable,action_buttons,taskbuttons,showbuttons,cmsg_appcheck,cmsg_return,cmsg_reject from axprocessdefv2 where '
      + sWhrStr;

    xQry.CDS.open;
    if xQry.CDS.RecordCount > 0 then
    begin
      xQry.CDS.First;

      // returnable
      sConfVal := xQry.CDS.FieldByName('returnable').AsString;
      pair := TJSONPair.create('returnable', sConfVal);
      pDataJson.AddPair(pair);

      // action_buttons
      sConfVal := xQry.CDS.FieldByName('action_buttons').AsString;
      pair := TJSONPair.create('action_buttons', sConfVal);
      pDataJson.AddPair(pair);

      // taskbuttons
      sConfVal := xQry.CDS.FieldByName('taskbuttons').AsString;
      pair := TJSONPair.create('taskbuttons', sConfVal);
      pDataJson.AddPair(pair);

      // showbuttons
      sConfVal := xQry.CDS.FieldByName('showbuttons').AsString;
      pair := TJSONPair.create('showbuttons', sConfVal);
      pDataJson.AddPair(pair);

      // approve / check
      sConfVal := xQry.CDS.FieldByName('cmsg_appcheck').AsString;
      pair := TJSONPair.create('cmsg_appcheck', sConfVal);
      pDataJson.AddPair(pair);

      // return
      sConfVal := xQry.CDS.FieldByName('cmsg_return').AsString;
      pair := TJSONPair.create('cmsg_return', sConfVal);
      pDataJson.AddPair(pair);

      // reject
      sConfVal := xQry.CDS.FieldByName('cmsg_reject').AsString;
      pair := TJSONPair.create('cmsg_reject', sConfVal);
      pDataJson.AddPair(pair);

    end;
  Finally
    if Assigned(xQry) then
    begin
      if xQry.Active then
        xQry.close;
      FreeAndNil(xQry);
    end;
  End;
  structdef.axprovider.dbm.gf.DoDebug.msg('AddPEGConfigs ends.');
end;

//CreatePEGorAmendDataJSON
function TAxPEG.CreatePEGorAmendDataJSON(dataXDS : TXDS; const dataJson: String): string;
var
  pegDataJson,jsonDataObj : TJSONObject;
  pair: TJSONPair;
  tmpTransid,tmpTaskid,tmpTaskname,tmpProcessname,tmpKeyfield,tmpKeyvalue : String;
  tmpapprovalcomments,tmprejectcomments,tmpreturncomments,tmpapprovereasons,
  tmpdefapptext,tmpreturnreasons,tmpdefrettext,tmprejectreasons,tmpdefregtext,
  tmpdisplaytitle,tmpTaskType : String;
begin

  if Assigned(dataXDS) and (dataXDS.CDS.RecordCount > 0) then
  begin
    tmpTransid := dataXDS.CDS.FieldByName('transid').AsString;
    tmpTaskid := dataXDS.CDS.FieldByName('taskid').AsString;
    tmpTaskname := dataXDS.CDS.FieldByName('taskname').AsString;
    tmpProcessname := dataXDS.CDS.FieldByName('processname').AsString;
    tmpKeyfield := dataXDS.CDS.FieldByName('keyfield').AsString;
    tmpKeyvalue := dataXDS.CDS.FieldByName('keyvalue').AsString;
    tmpTaskType := dataXDS.CDS.FieldByName('tasktype').AsString;

    tmpdisplaytitle := dataXDS.CDS.FieldByName('displaytitle').AsString;

    tmpapprovalcomments := dataXDS.CDS.FieldByName('approvalcomments').AsString;
    tmprejectcomments := dataXDS.CDS.FieldByName('rejectcomments').AsString;
    tmpreturncomments := dataXDS.CDS.FieldByName('returncomments').AsString;

    tmpapprovereasons := dataXDS.CDS.FieldByName('approvereasons').AsString;
    tmpdefapptext := dataXDS.CDS.FieldByName('defapptext').AsString;
    tmpreturnreasons := dataXDS.CDS.FieldByName('returnreasons').AsString;
    tmpdefrettext := dataXDS.CDS.FieldByName('defrettext').AsString;
    tmprejectreasons := dataXDS.CDS.FieldByName('rejectreasons').AsString;
    tmpdefregtext := dataXDS.CDS.FieldByName('defregtext').AsString;
  end;

  // Create the "data" JSON object
  jsonDataObj := TJSONObject.Create;
  if Trim(dataJson) <> '' then
    jsonDataObj := TJSONObject.ParseJSONValue(dataJson) as TJSONObject;

  pegDataJson := TJSONObject.Create;
  pegDataJson.AddPair('transid', tmpTransid);
  pegDataJson.AddPair('taskid', tmpTaskid);
  pegDataJson.AddPair('taskname', tmpTaskname);
  pegDataJson.AddPair('processname', tmpProcessname);
  pegDataJson.AddPair('keyfield', tmpKeyfield);
  pegDataJson.AddPair('keyvalue', tmpKeyvalue);
  pegDataJson.AddPair('tasktype', tmpTasktype);

  pair := TJSONPair.Create('displaytitle', tmpdisplaytitle);
  pegDataJson.AddPair(pair);

  // Add a JSON pair
  pair := TJSONPair.Create('approvalcomments', tmpapprovalcomments);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('rejectcomments', tmprejectcomments);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('returncomments', tmpreturncomments);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('approvereasons', tmpapprovereasons);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('defapptext', tmpdefapptext);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('returnreasons', tmpreturnreasons);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('defrettext', tmpdefrettext);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('rejectreasons', tmprejectreasons);
  pegDataJson.AddPair(pair);
  pair := TJSONPair.Create('defregtext', tmpdefregtext);
  pegDataJson.AddPair(pair);

  //Add PEG configurations
  //Need introduce join with processsdefv2 table in the main querys to avoid extra DB calls
  AddPEGConfigs(tmpProcessname,tmpTaskName,tmpTransid,pegDataJson);

  (*
  //Enable / Disable approvalcomments / rejectcomments / returncomments
  pegDataJson.AddPair('approvalcomments', tmpapprovalcomments);
  pegDataJson.AddPair('rejectcomments', tmprejectcomments);
  pegDataJson.AddPair('returncomments', tmpreturncomments);

  //reasons - comma separated values to select from drop down
  //deftext - default texts / comments / remarks
  pegDataJson.AddPair('approvereasons', tmpapprovereasons);
  pegDataJson.AddPair('defapptext', tmpdefapptext);
  pegDataJson.AddPair('returnreasons', tmpreturnreasons);
  pegDataJson.AddPair('defrettext', tmpdefrettext);
  pegDataJson.AddPair('rejectreasons', tmprejectreasons);
  pegDataJson.AddPair('defregtext', tmpdefregtext);
  *)
  pegDataJson.AddPair('amenddata', jsonDataObj);

  // Create the main JSON object
  //Result := TJSONObject.Create.AddPair('amenddata', amendDataJson).ToString;
  Result :=  pegDataJson.ToString;
end;

//CreatePEGorAmendDataJSON
function CreatePEGorAmendDataJSON(const tmpTransid, tmpTaskid, tmpTaskname, tmpProcessname, tmpKeyfield, tmpKeyvalue: string; const dataJson: String): string; Overload;
var
  amendDataJson,jsonDataObj : TJSONObject;
begin
  // Create the "data" JSON object
  jsonDataObj := TJSONObject.Create;
  if Trim(dataJson) <> '' then
    jsonDataObj := TJSONObject.ParseJSONValue(dataJson) as TJSONObject;

  amendDataJson := TJSONObject.Create;
  amendDataJson.AddPair('transid', tmpTransid);
  amendDataJson.AddPair('taskid', tmpTaskid);
  amendDataJson.AddPair('taskname', tmpTaskname);
  amendDataJson.AddPair('processname', tmpProcessname);
  amendDataJson.AddPair('keyfield', tmpKeyfield);
  amendDataJson.AddPair('keyvalue', tmpKeyvalue);
  amendDataJson.AddPair('amenddata', jsonDataObj);

  // Create the main JSON object
  //Result := TJSONObject.Create.AddPair('amenddata', amendDataJson).ToString;
  Result :=  amendDataJson.ToString;
end;


//GetTaskPendingWithUsers | getNextLevelUsers
Function TAxPEG.GetTaskPendingWithUsers(pProcessName,pTransid,pKeyValue : String;var sPEGDataJson : String):String;
var
  dQry : TXDS;
  //tmpTransid,tmpTaskid,tmpTaskname,tmpProcessname,tmpKeyfield,tmpKeyvalue : String;
begin
  dQry := nil;
  Result := '';
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskPendingWithUsers starts...');
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := True;
      //For postgres | Oracle it has to be handled
      if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
         dQry.CDS.CommandText:= 'SELECT (  '+
                      ' SELECT LISTAGG(a.ToUser, '','') WITHIN GROUP (ORDER BY a.ToUser) AS ToUsers '+
                      ' FROM AxActiveTasks a '+
                      ' LEFT JOIN AxActiveTaskStatus s '+
                      ' ON a.Taskid = s.Taskid '+
                        ' AND a.keyvalue = s.keyvalue '+
                        ' AND a.processname = s.processname '+
                      ' WHERE a.keyvalue = ' + QuotedStr(pKeyValue) +
                        ' AND a.processname = '+ QuotedStr(pProcessname) +
                        ' AND s.Taskid IS NULL '+
                    ' ) AS ToUsers, '+
                    ' a.* '+
                  ' FROM AxActiveTasks a '+
                  ' WHERE a.TaskId NOT IN (SELECT TaskId FROM AxActiveTaskStatus WHERE TaskId IS NOT NULL) '+
                  ' AND ROWNUM = 1 '
      else
        dQry.CDS.CommandText:=
            (*
                      ' SELECT STRING_AGG(DISTINCT a.ToUser, '','') AS ToUsers '+
                      ' FROM AxActiveTasks a '+
                      ' LEFT JOIN AxActiveTaskStatus s '+
                         ' ON a.Taskid = s.Taskid '+
                             ' AND a.transid = s.transid '+
                             ' AND a.keyvalue = s.keyvalue '+
                             ' AND a.processname = s.processname '+
                      ' WHERE a.transid = :pTransid'+
                         ' AND a.keyvalue = :pKeyValue'+
                         ' AND a.processname = :Processname'+
                         ' AND s.Taskid IS NULL';
            *)

           //Fetches Tousers as comma separated values and task details
           //Transid filter removed to handle multiple make transactions
          'SELECT ToUsers, a.* ' +
          'FROM ( ' +
          '  SELECT STRING_AGG(a.ToUser, '','') AS ToUsers ' +
          '  FROM AxActiveTasks a ' +
          '  LEFT JOIN AxActiveTaskStatus s ' +
          '    ON a.Taskid = s.Taskid ' +
          //'       AND a.transid = s.transid ' +
          '       AND a.keyvalue = s.keyvalue ' +
          '       AND a.processname = s.processname ' +
          '  WHERE '+
          //' a.transid = ' + QuotedStr(pTransid) + ' AND '+
          '    a.keyvalue = ' + QuotedStr(pKeyValue) +
          '    AND a.processname = ' + QuotedStr(pProcessname) +
          '    AND s.Taskid IS NULL ' +
          ') subquery ' +
          'CROSS JOIN ( ' +
          '  SELECT DISTINCT a.Taskid, a.* ' +
          '  FROM AxActiveTasks a ' +
          '  LEFT JOIN AxActiveTaskStatus s ' +
          '    ON a.Taskid = s.Taskid ' +
          '       AND a.transid = s.transid ' +
          '       AND a.keyvalue = s.keyvalue ' +
          '       AND a.processname = s.processname ' +
          '  WHERE '+
          //' a.transid = ' + QuotedStr(pTransid) +' AND '+
          '    a.keyvalue = ' + QuotedStr(pKeyValue) +
          '    AND a.processname = ' + QuotedStr(pProcessname) +
          '    AND s.Taskid IS NULL ' +
          '  LIMIT 1 ' +  //Limiting to one row to avoid duplicate rows
          ') a';

      //dQry.AssignParam(0,pTransid,'c');
      //dQry.AssignParam(1,pKeyValue,'c');
      //dQry.AssignParam(2,pProcessName,'c');
      dQry.Open;
      if not dQry.CDS.IsEmpty then
      begin
        Result :=
          dQry.CDS.FieldByName('ToUsers').AsString;

//          tmpTransid := dQry.CDS.FieldByName('transid').AsString;
//          tmpTaskid := dQry.CDS.FieldByName('taskid').AsString;
//          tmpTaskname := dQry.CDS.FieldByName('taskname').AsString;
//          tmpProcessname := dQry.CDS.FieldByName('processname').AsString;
//          tmpKeyfield := dQry.CDS.FieldByName('keyfield').AsString;
//          tmpKeyvalue := dQry.CDS.FieldByName('keyvalue').AsString;

          sCurrentPEGInitiator := dQry.CDS.FieldByName('initiator').AsString;

          sPEGDataJson := CreatePEGorAmendDataJSON(dQry, sPEGDataJson);
          //sPEGDataJson := CreatePEGorAmendDataJSON(dQry, '');
//          sPEGDataJson := CreatePEGorAmendDataJSON(tmpTransid, tmpTaskid, tmpTaskname, tmpProcessname,
//                           tmpKeyfield, tmpKeyvalue, '');
      end;
      dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetTaskPendingWithUsers '+E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
end;

//UserExists
function UserExists(const userList, user: string): Boolean;
var
  userString: string;
begin
  // Add commas to the beginning and end of the user list string for consistent matching
  userString := ',' + userList + ',';

  // Check if the user is found in the user list string
  Result := Pos(',' + user + ',', userString) > 0;
end;

function DeleteAndAddValue(const originalString, valueToDelete, valueToAdd: string): string;
var
  stringList: TStringList;
  i: Integer;
begin
  // Create a TStringList and set the delimiter to a comma
  stringList := TStringList.Create;
  try
    stringList.Delimiter := ',';

    // Load the original string into the TStringList
    stringList.DelimitedText := originalString;

    // Find and delete the value to be removed
    for i := stringList.Count - 1 downto 0 do
    begin
      if stringList[i] = valueToDelete then
        stringList.Delete(i);
    end;

    // Insert the new value at the beginning of the string list
    stringList.Insert(0, valueToAdd);

    // Return the modified string
    Result := stringList.DelimitedText;
  finally
    stringList.Free;
  end;
end;

//GetInitTaskName
Function TAxPEG.GetInitTaskName(pTransId,pProcessName : String):String;
var
  PegGetProcessXDS : TXDS;
begin
  PegGetProcessXDS := nil;
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetInitTaskName starts...');
  try
  try
  PegGetProcessXDS := structdef.axprovider.dbm.GetXDS(nil);
  PegGetProcessXDS.close;
  PegGetProcessXDS.buffered := True;
  //When there are mutiple process for same transation then need to think about handling statusbars
  PegGetProcessXDS.cds.CommandText := 'Select Taskname from axprocessdefv2 '+
    ' where lower(transid)='+QuotedStr(lowercase(transtype))+
    ' and lower(processname) ='+QuotedStr(lowercase(pProcessName))+
    ' and indexno = 1';

  PegGetProcessXDS.open;
  if PegGetProcessXDS.CDS.RecordCount > 0 then
      result := PegGetProcessXDS.CDS.FieldByName('Taskname').AsString;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetInitTaskName '+E.Message);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetInitTaskName ends.');
  finally
    if Assigned(PegGetProcessXDS) then
    begin
      if PegGetProcessXDS.Active then
        PegGetProcessXDS.close;
      FreeAndNil(PegGetProcessXDS);
    end;
  end;
end;

//GetProcessStatus
function TAxPEG.GetProcessStatusNew(pCurUserTaskName,pTransid,pKeyValue : String;bGetLastStatusOfPeg : Boolean;dQry :TXds):string;
var
  s,sToUsers,sEnablePEGActions,sPEGDataJson,sEnablePEGWithdraw:String;
  sLastStatus,sPegConfirmMsg,sProcessName,ApproverComments,sPEGStatus : String;
  sActiveTaskType : String;
  bEnablePegActions : boolean;

function ConvertTimestampToDateTime(const timestamp: string): string;
var
  year, month, day, hour, minute, second, ms: Word;
begin
  // Extract the individual date and time components from the timestamp
  year := StrToInt(Copy(timestamp, 1, 4));
  month := StrToInt(Copy(timestamp, 5, 2));
  day := StrToInt(Copy(timestamp, 7, 2));
  hour := StrToInt(Copy(timestamp, 9, 2));
  minute := StrToInt(Copy(timestamp, 11, 2));
  second := StrToInt(Copy(timestamp, 13, 2));
  ms := StrToInt(Copy(timestamp, 15, 3));

  // Create a TDateTime value using the extracted components
  //Result := Format('%4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d.%3.3d', [year, month, day, hour, minute, second, ms]);
  Result := Format('%4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d', [year, month, day, hour, minute, second]);
  try
    //Result := formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.ShortDateFormat,StrtoDateTime(Result));
    Result := formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.ShortDateFormat,EncodeDate(year,month,day)) +' '+
    formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.LongTimeFormat,EncodeTime(hour,minute,second,ms))
  except
  end;
end;

begin
  //dQry := nil;
  Result := '';
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessStatusNew starts...');
    try
      //Instead of providing all details, we are providing only status
      if Assigned(dQry) and (not dQry.CDS.IsEmpty) then
      begin
        dQry.cds.First;
        sActiveTaskType := '';
        sLastStatus := '';
        sPegConfirmMsg := '';
        sToUsers := '';
        bEnablePegActions := false;
        sEnablePEGWithdraw := 'false';
        sEnablePEGActions := 'false';

        sProcessName := dQry.CDS.FieldByName('Processname').AsString;

        if Not bGetLastStatusOfPeg then
        begin
          sActiveTaskType := lowercase(dQry.CDS.FieldByName('tasktype').AsString);
          sPegConfirmMsg := ''//As of now there is no confirmation message provided for peg, in future i could be provided.
        end
        else
        begin
          sLastStatus := lowercase(dQry.CDS.FieldByName('taskstatus').AsString);
          ApproverComments := (dQry.CDS.FieldByName('statustext').AsString);
          if sLastStatus = 'approved' then
            pegLastApproved := true
          else if (sLastStatus = 'returned') or (sLastStatus='rejected') then
            bPEGRejectedOrReturned := True
          else if (sLastStatus = 'withdrawn') then
            bPEGWithdrawn := True;
        end;

        sToUsers := '';
        if Not bGetLastStatusOfPeg then
        begin
          sToUsers:= GetTaskPendingWithUsers(sProcessName,pTransid,pKeyValue,sPEGDataJson);

          if (sToUsers <> '') and (UserExists(sToUsers,structdef.axprovider.dbm.gf.username)) then
          begin
            sToUsers := DeleteAndAddValue(sToUsers,structdef.axprovider.dbm.gf.username,'you');
            bEnablePegActions := True;//sEnablePEGActions := 'true';
          end
          else
            bEnablePegActions := False;//sEnablePEGActions := 'false';

          //The below code has to be optmized.
          if bEnablePegActions and (Lowercase(pTransid)=lowercase(dQry.CDS.FieldByName('transid').AsString))  then
             bEnablePegActions := True
          else
             bEnablePegActions := False;

          //If PEG initiator and Current user are same then enable withdraw button
          if (sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username) then
            sEnablePEGWithdraw := 'true'
          else
            sEnablePEGWithdraw := 'false';
          //Disable actions for make task type
          if sActiveTaskType = 'make' then
            bEnablePegActions := False;
        end
        else
          sPEGDataJson := CreatePEGorAmendDataJSON(dQry, sPEGDataJson);

        if bEnablePegActions then
          sEnablePEGActions := 'true'
        else
          sEnablePEGActions := 'false';

        //Prepare status message if task pending / inprogress (except with initiator)
       if Not bGetLastStatusOfPeg then
       begin
          if sActiveTaskType = 'make' then
          begin
            Result :=
              dQry.CDS.FieldByName('PriorTaskName').AsString +' done by '+
              ifthen(dQry.CDS.FieldByName('priorusername').AsString = structdef.axprovider.dbm.gf.username,'you', dQry.CDS.FieldByName('priorusername').AsString)+
              //ifthen(sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username,'you', dQry.CDS.FieldByName('Initiator').AsString)+
              ' on '+ConvertTimestampToDateTime(dQry.CDS.FieldByName('EventDateTime').AsString) +
              ' and '+dQry.CDS.FieldByName('TaskName').AsString+' is pending';
              if Trim(sToUsers) <> '' then
              begin
                Result := Result+' with '+
                ifthen(sToUsers = structdef.axprovider.dbm.gf.username,'you',sToUsers)+'.'
              end
              else
              begin //if user is empty then showm only task is pending.
                Result := Result+'.';
              end;
          end
          else
          begin
             Result := dQry.CDS.FieldByName('PriorTaskName').AsString +' done by '+
              ifthen(dQry.CDS.FieldByName('priorusername').AsString = structdef.axprovider.dbm.gf.username,'you', dQry.CDS.FieldByName('priorusername').AsString)+
              //ifthen(sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username,'you', dQry.CDS.FieldByName('Initiator').AsString)+
              //dQry.CDS.FieldByName('UserName').AsString +
              ' on '+ConvertTimestampToDateTime(dQry.CDS.FieldByName('EventDateTime').AsString) +
              //' and pending with '+sToUsers+'.'
              ' is awaiting approval';
              if Trim(sToUsers) <> '' then
              begin
                Result := Result+' with '+sToUsers+'.';
              end
              else
              begin //if user is empty then showm only task is pending.
                Result := Result+'.';
              end;
          end;
        end
        else
        //if sLastStatus = 'Approved' then
        begin
          Result :=
            //GetInitTaskName(pTransid,dQry.CDS.FieldByName('Processname').AsString)+ //GetInitTaskName
            //dQry.CDS.FieldByName('TaskName').AsString +
            pCurUserTaskName +
            ' done by '+ dQry.CDS.FieldByName('priorusername').AsString +
            ' on '+ConvertTimestampToDateTime(dQry.CDS.FieldByName('EventDateTime').AsString) +
            ' is '+sLastStatus+' by ' +dQry.CDS.FieldByName('actuser').AsString;
        end;

        //Result := Result + sToUsers + '.' ; //Status
        Result := Result + '$##$'+sEnablePEGActions;//Enable PEG Action buttons
        if Trim(sPEGDataJson) = '' then
          sPEGDataJson := '{}';
        Result:= Result+'$##$'+ sPEGDataJson;//Data

        Result := Result+'$##$'+ sEnablePEGWithdraw;//Withdraw
        //PEG confirmation message
        //Replace dynamic params
        sPegConfirmMsg := ''; // Not implemented for PEG, as of now its only implemented for Amendment
        sPegConfirmMsg := FillDynamicParams(sPegConfirmMsg);
        Result:= Result+'$##$'+sPegConfirmMsg;// PEG Confirmation message.
        //PEGStatus
        sPEGStatus := '';
        Result:= Result+'$##$'+sPEGStatus;//PEGstatus for display purpose on pop div |as of now its only implemented for Amendment
        //Approver Comments if exists
        Result:= Result+'$##$'+ApproverComments; //ApproverComments
        //Is this transaction finally approved or not?
        Result:= Result+'$##$'+ifthen(pegLastApproved,'true','false'); //FinalApproval
      end
      else Result := '';
      //dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetProcessStatusNew '+E.Message);
    end;
  finally
    //if Assigned(dQry) then
      //FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessStatusNew ends.');
end;



(*
CancelPEGActiveTasks
*)
Procedure TAxPEG.CancelPEGActiveTasks;
var
  pegXDS,getActiveTasksXDS : TXDS;
  sSQLText,sKeyField,sKeyValue,sTaskId : String;
begin
  try
    //If the transaction is peg attached transaction then continue or exit.
    structdef.axprovider.dbm.gf.DoDebug.msg('CancelPEGActiveTasks starts...');
    getActiveTasksXDS := nil;
    try
      pegXDS := structdef.axprovider.CheckAxProcessDef(transtype);
      if pegXDS.CDS.RecordCount > 0 then
      begin

        sKeyField := GetKeyField;
        if sKeyField = '' then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('Invalid KeyField.');
          Exit;
        end;
        sKeyValue := GetFieldValue(sKeyField,1);

        getActiveTasksXDS := structdef.axprovider.dbm.GetXDS(nil);
        getActiveTasksXDS.close;
        getActiveTasksXDS.buffered := True;
        //SQL - Other DBs need to be handled |
        //Postrgres SQL
        if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
          sSQLText := 'SELECT TaskId, a.* '+
                          ' FROM ( '+
                          ' SELECT a.TaskId AS taskid1, a.*, ROW_NUMBER() OVER (PARTITION BY a.TaskId ORDER BY NULL) AS rn '+
                          ' FROM AxActiveTasks a '+
                          ' WHERE lower(transid) = '+QuotedStr(lowercase(transtype))+
                          ' AND lower(KeyField) = '+QuotedStr(lowercase(sKeyField))+
                          ' AND lower(KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
                          ' AND a.TaskId NOT IN ( '+
                          '   SELECT taskid FROM axactivetaskstatus '+
                          ' ) '+
                          ' ) a '+
                          ' WHERE rn = 1 '
        else
          sSQLText := 'Select DISTINCT ON (a.TaskId) TaskId,a.* from AxActiveTasks a where '+
                          '(transid)='+QuotedStr(lowercase(transtype))+' and '+structdef.axprovider.dbm.gf.sqllower+
                          '(KeyField)='+QuotedStr(lowercase(sKeyField))+' and '+structdef.axprovider.dbm.gf.sqllower+
                          '(KeyValue)='+QuotedStr(lowercase(sKeyValue))+
                          ' and taskid not in '+
                          ' (select taskid from axactivetaskstatus) ';
                          //' order by TaskId,EventDateTime asc';

        getActiveTasksXDS.cds.CommandText := sSQLText;
        getActiveTasksXDS.open;
        if getActiveTasksXDS.CDS.RecordCount > 0 then
        begin
          //AddrectoActiveTaskStatus with status cancelled
          getActiveTasksXDS.CDS.First;
          while Not getActiveTasksXDS.CDS.Eof do
          begin
            sTaskId := getActiveTasksXDS.CDS.FieldByName('TaskId').AsString;
            AddRecToAxActiveTaskStatus(getActiveTasksXDS,sTaskId,'cancelled');
            getActiveTasksXDS.CDS.Next;
          end;
        end;
      end;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\CancelPEGActiveTasks - '+e.Message);
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\CancelPEGActiveTasks - '+e.Message);
    end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('CancelPEGActiveTasks ends.');
  finally
    if Assigned(pegXDS) then
    begin
      if pegXDS.Active then pegXDS.close;
      FreeAndnil(pegXDS);
    end;
    if Assigned(getActiveTasksXDS) then
    begin
      if getActiveTasksXDS.Active then getActiveTasksXDS.Close;
      FreeAndNil(getActiveTasksXDS);
    end;
  end;
end;

//PushMessagesToRMQ
(*
 Process PublishMsgObjList TList
*)
Procedure TAxPEG.PushMessagesToRMQ;
var
  iIdx : Integer;
begin
  try
  structdef.axprovider.dbm.gf.DoDebug.msg('PushMessagesToRMQ starts...');
  if Not bAddPublishRMQObjtoList then
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('PushMessagesToRMQ/Messages processed already while adding tasks.');
    Exit;
  end;
  if Assigned(PublishMsgObjList) then
  begin
    for iIdx := 0 to PublishMsgObjList.Count - 1 do
    begin
      if Assigned(PublishMsgObjList[iIdx]) then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('Processing message for task '+
           TPublishToRMQ(PublishMsgObjList[iIdx]).sTaskName );
        TPublishToRMQ(PublishMsgObjList[iIdx]).PublishMessage;
      end;
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('PushMessagesToRMQ ends.');
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in PushMessagesToRMQ :'+E.Message);
  end;
end;

//PublishToRMQ
Procedure TAxPEG.PublishMessageToRMQ(pTaskId,pTransId,pProcessName,pTaskName,pKeyField,pKeyValue : String;bRemind,bEscalate,bNotification,bUseBusinessdateLogic : Boolean);
var
  PublishToRMQ : TPublishToRMQ;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('PublishMessageToRMQ starts...');
  try
    PublishToRMQ := nil;
    try
      PublishToRMQ := TPublishToRMQ.create(structdef);
      PublishToRMQ.bIsPEGV2 := bIsPEGV2;
      PublishToRMQ.Parser := nil;//Parser;
      PublishToRMQ.SDEvaluateExpr := SDEvaluateExpr;

      PublishToRMQ.sTaskId := pTaskId;
      PublishToRMQ.sTransId := pTransId;
      PublishToRMQ.sProcessName := pProcessName;
      PublishToRMQ.sTaskName := pTaskName;
      PublishToRMQ.sKeyField := pKeyField;
      PublishToRMQ.sKeyValue := pKeyValue;
      PublishToRMQ.bRemind := bRemind;
      PublishToRMQ.bEscalate := bEscalate;
      PublishToRMQ.bNotification := bNotification;
      PublishToRMQ.bUseBusinessdateLogic := bUseBusinessdateLogic;
      PublishToRMQ.bScriptJobs := False;
      PublishToRMQ.bIsTaskNotification := bIsTaskNotification;
      if bAddPublishRMQObjtoList then
        PublishMsgObjList.Add(PublishToRMQ) // Ownership transfer
      else
        PublishToRMQ.PublishMessage;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in PublishMessageToRMQ : '+E.Message);
    end;
    end;
  finally
    if bAddPublishRMQObjtoList then
      PublishToRMQ := nil
    else
    begin
      if Assigned(PublishToRMQ) then
        FreeAndNil(PublishToRMQ);
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('PublishMessageToRMQ ends.');
end;

//GetProcessTable
Function TAxPEG.GetProcessTable(pProcessName : String):String;
var dQry :TXds;
begin
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessTable starts...');
  try
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := True;
      dQry.CDS.CommandText:='Select ProcessTable from axpdef_peg_processmaster where '+
                            structdef.axprovider.dbm.gf.sqllower+'(caption) = :scaption';
      dQry.AssignParam(0,lowercase(pProcessName),'c');
      dQry.Open;
      if not dQry.CDS.IsEmpty then
      begin
        Result :=dQry.CDS.FieldByName('ProcessTable').AsString;
      end
      else Result := '';
      dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetProcessTable '+E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessTable ends.');
end;

//GetDisplayTextDetails
//Returns DisplayIcon and DisplayTitle '$#$' separated
Function TAxPEG.GetDisplayTextDetails(pTaskId : String):String;
var dQry :TXds;
begin
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetDisplayTextDetails starts...');
  try
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := True;
      dQry.CDS.CommandText:='Select displayicon,displaytitle from axactivetasks where '+
                            structdef.axprovider.dbm.gf.sqllower+'(taskid) = :TaskId';
      dQry.AssignParam(0,lowercase(pTaskId),'c');
      dQry.Open;
      if not dQry.CDS.IsEmpty then
      begin
        Result :=dQry.CDS.FieldByName('displayicon').AsString+'$#$'+dQry.CDS.FieldByName('displaytitle').AsString;
      end
      else Result := '';
      dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetDisplayTextDetails '+E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetDisplayTextDetails ends.');
end;

//GetPEGTaskEventDateTime   | to keep eventdatetime same for same task in Axactivetasks,Status,Process tables..
Function TAxPEG.GetPEGTaskEventDateTime:String;
begin
  if sPEGTask_EventDateTime = '' then
    sPEGTask_EventDateTime := structdef.axprovider.dbm.gf.GetDateTimeStampString;
  result := sPEGTask_EventDateTime;
end;


//IsPEGV2Process
Function TAxPEG.IsPEGV2Process(pProcessName : String):Boolean;
var dQry :TXds;
begin
  result := false;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPEGV2Process starts...');
  try
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := True;
      dQry.CDS.CommandText:='Select IsPEGV2 from axpdef_peg_processmaster where '+
                            structdef.axprovider.dbm.gf.sqllower+'(caption) = :scaption';
      dQry.AssignParam(0,lowercase(pProcessName),'c');
      dQry.Open;
      if not dQry.CDS.IsEmpty then
      begin
        Result := lowercase(dQry.CDS.FieldByName('IsPEGV2').AsString) = 't';
      end;
      dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in IsPEGV2Process '+E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPEGV2Process ends.');
end;



//PEG VERSION 2.0 Starts here

//GetParentTaskXDSOfSubTask
Function TAxPEG.GetParentTaskXDSOfSubTask(pProcessName,pTaskName,pKeyValue:String): TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetParentTaskXDSOfSubTask Starts...');
    Result := nil;
    try
      Result := structdef.axprovider.dbm.GetXDS(nil);
      Result.buffered := True;
      Result.CDS.CommandText := 'select * from AxActiveTasks where '+
                structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Taskname)='+QuotedStr(lowercase(pTaskName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(Keyvalue)='+QuotedStr(lowercase(pKeyValue))+
                ' order by IndexNo,SubIndexNo asc';
      Result.open;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetParentTaskXDSOfSubTask '+E.Message);
      if Assigned(Result) then
        FreeAndNil(Result);
    end;
    end;
  finally
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetParentTaskXDSOfSubTask Ends.');
end;


//HasSubTasks
(*
 1- Checks for SubTasks in the AxProcessDef
*)
Function TAxPEG.HasSubTasks(pProcessName,pParentTaskName,pKeyValue:String;var sSubTaskNames : String): Boolean;
var
  xdsHasSubTasks : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('HasSubTasks Starts...');
    Result := False;
    xdsHasSubTasks := nil;
    sSubTaskNames := '';
    if Trim(pParentTaskName) = '' then
      Exit;
    try
      xdsHasSubTasks := structdef.axprovider.dbm.GetXDS(nil);
      xdsHasSubTasks.buffered := True;
      xdsHasSubTasks.CDS.CommandText := 'select Taskname from axprocessdefv2 where '+
                structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
                structdef.axprovider.dbm.gf.sqllower+'(ParentTaskname)='+QuotedStr(lowercase(pParentTaskName))+ ' and '+
                //structdef.axprovider.dbm.gf.sqllower+'(Transid)='+QuotedStr(lowercase(pTransid))+' and '+
                structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' '+
                //structdef.axprovider.dbm.gf.sqllower+'(Keyvalue)='+QuotedStr(lowercase(pKeyValue))+
                ' order by IndexNo,SubIndexNo asc';
      xdsHasSubTasks.open;
      if xdsHasSubTasks.CDS.IsEmpty then //checks for subtasks in AxprocessDefV2
      begin
        Result := False;
        Exit;
      end
      else //Checks for Active subtasks
      begin
        Result := True;
        xdsHasSubTasks.CDS.First;
        while Not xdsHasSubTasks.CDS.Eof do
        begin
          sSubTaskNames := sSubTaskNames+','+QuotedStr(LowerCase(xdsHasSubTasks.CDS.FieldByName('taskname').AsString));
          xdsHasSubTasks.CDS.Next;
        end;
        if sSubTaskNames <> '' then
          Delete(sSubTaskNames,1,1);
      end;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in HasSubTasks '+E.Message);
      if Assigned(xdsHasSubTasks) then
        FreeAndNil(xdsHasSubTasks);
    end;
    end;
  finally
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('HasSubTasks Ends.');
end;

//HaveSubTasksCompleted
//Checks for given subtasks status in AxActiveTaskStatus
Function TAxPEG.HaveSubTasksCompleted(pProcessName,pTaskName,pKeyValue:String): Boolean;
var
  xdsHaveSubTasksCompleted : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('HaveSubTasksCompleted Starts...');
    Result := False;
    xdsHaveSubTasksCompleted := nil;
    try
      xdsHaveSubTasksCompleted := structdef.axprovider.dbm.GetXDS(nil);
      xdsHaveSubTasksCompleted.buffered := True;
      xdsHaveSubTasksCompleted.CDS.CommandText := 'Select TaskId from AxActiveTaskStatus a where '+
          structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
          structdef.axprovider.dbm.gf.sqllower+'(Taskname) = '+QuotedStr(lowercase(pTaskName))+ ' and '+
          structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(pKeyValue));

      xdsHaveSubTasksCompleted.open;
      if xdsHaveSubTasksCompleted.CDS.IsEmpty then //checks for subtasks in AxprocessDefV2
        Result := False
      else
        Result := True;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in HaveSubTasksCompleted '+E.Message);
      if Assigned(xdsHaveSubTasksCompleted) then
        FreeAndNil(xdsHaveSubTasksCompleted);
    end;
    end;
  finally
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('HaveSubTasksCompleted Ends.');
end;


//HasActiveSubTasks
(*
 1- Checks for SubTasks in the AxProcessDef
 2- Checks for the Active subtasks in the AxActiveTasks Table
*)
Function TAxPEG.HasActiveSubTasks(pProcessName,pParentTaskName,pKeyValue,sSubTaskNames:String): Boolean;
var
  xdsHasActiveSubTasks : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('HasActiveSubTasks Starts...');
    Result := False;
    xdsHasActiveSubTasks := nil;
    try
      xdsHasActiveSubTasks := structdef.axprovider.dbm.GetXDS(nil);
      xdsHasActiveSubTasks.buffered := True;
      xdsHasActiveSubTasks.CDS.CommandText := 'Select TaskId from AxActiveTasks a where '+
          structdef.axprovider.dbm.gf.sqllower+'(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
          structdef.axprovider.dbm.gf.sqllower+'(Taskname) in ('+sSubTaskNames+ ') and '+
          structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(pKeyValue))+ ' and '+
          //structdef.axprovider.dbm.gf.sqllower+'(Transid)='+QuotedStr(lowercase(pTransid))+
          ' not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid )';//+
          //' order by eventdatetime,IndexNo,SubIndexNo desc)';
          //Order by not required for this query since we are jsut checking existense of records

      xdsHasActiveSubTasks.open;
      if xdsHasActiveSubTasks.CDS.IsEmpty then //checks for subtasks in AxprocessDefV2
        Result := False
      else
        Result := True;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in HasActiveSubTasks '+E.Message);
      if Assigned(xdsHasActiveSubTasks) then
        FreeAndNil(xdsHasActiveSubTasks);
    end;
    end;
  finally
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('HasActiveSubTasks Ends.');
end;


//EVALProcessSet
Procedure TAxPEG.EVALProcessSet(pPegXDS: TXDS;pPriorIndex : String = '0';pPriorTask : String = '');
Var
  sApplicabilityExpr, sProcessName, sTaskName, sStatus, sKeyField,
    sTaskId,sTaskType: String;
  bApplicability: Boolean;

  sCommand, sCondition, sGrouping,sIndexNo,sSubIndexNo,sParentTask,sSubTaskNames : String;
  bResult, bSkip, bBreak, bIsTaskAdded, bIsSubTask, bHasActiveSubTasks, bSkipSubTasks,bIsFirstTime : Boolean;
begin
  Try
    structdef.axprovider.dbm.gf.DoDebug.msg('EVALProcessSet starts...');
    (*
    if Not assigned(SDEvaluateExpr) then
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg
        ('EVALProcessSet/SDEvaluateExpr is not assigned.');
      exit;
    end;
    *)
    bIsCurrentPEGTask := False;
    bBreak := False;
    bResult := True;//False;Set reult default true
    bSkip := False;
    bIsTaskAdded := False;
    bSkipSubTasks := False;
    bIsFirstTime := True;
    if pPegXDS.CDS.RecordCount > 0 then
    begin
      //pPegXDS.CDS.First;
      structdef.axprovider.dbm.gf.DoDebug.msg
                ('EVALProcessSet/ Current Record No : '+InttoStr(pPegXDS.CDS.RecNo));
      While Not pPegXDS.CDS.Eof do
      begin
        if bBreak then
          Break;

        //For SubTasks
        sParentTask := '';
        bIsSubTask := False;
        bHasActiveSubTasks := False;

        sCommand := lowercase(pPegXDS.CDS.FieldByName('TaskType').AsString);//lowercase(pPegXDS.CDS.FieldByName('Command').AsString);
        (*
        The below bIsFirstTime conditional block introduced to handle the else if tasks
        scenario :
          if cond
          form1
          else if conf2
          form2
          else if cond 3
          form3
          else
          form4
          end
          make - new form

          as per the data cond2 is true and the record is pending in form2
          if the users enters the data in form2 then it should goto make - newform
          but on form2 save its check else if cond3
        *)
        if bIsFirstTime then
        begin
          if (sCommand = 'else') or (sCommand = 'else if') then
            bSkip := True;

          bIsFirstTime := False;
        end;

        sCondition := (pPegXDS.CDS.FieldByName('Applicability').AsString);//lowercase(pPegXDS.CDS.FieldByName('Description').AsString);
        sGrouping := lowercase(pPegXDS.CDS.FieldByName('groupwithprior').AsString);//lowercase(pPegXDS.CDS.FieldByName('Grouping').AsString);
        sIndexNo := (pPegXDS.CDS.FieldByName('IndexNo').AsString);
        sSubIndexNo := (pPegXDS.CDS.FieldByName('SubIndexNo').AsString);
        if sSubIndexNo = '' then
          sSubIndexNo := '1';

        //If No Task Added for this iteration and command is empty and grouping is after prior
        if (Not bIsTaskAdded) and (Trim(sCommand)='') and (lowercase(sGrouping)='f'{'after prior'}) then
          bResult := True;

        structdef.axprovider.dbm.gf.DoDebug.msg
                ('Command : '+sCommand+'.  Condition : '+sCondition+'.  Grouping : '+sGrouping);
        //Evaluating condition for first make.
        (*
         Defining if condition in the first index may not be possible , since condition
         referes fields and taskparams based on Transid , without first make defining condition
         is not possible, to resolve this we enabled condition in the first make.

         This is to avoid PEG init based on condition.
        *)
        if (sIndexNo = '1') and (sCommand = 'make') and (Trim(sCondition) <> '') then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('Evaluating condition for first make.');
          bResult := lowercase(EvalExpr(sCondition)) = 't';//lowercase(SDEvaluateExpr(sCondition)) = 't';
          (*
          if first make condition not satisfied the exit from PEG INIT,
          else continue with the process.
          *)
          if not bResult then
            Break; //Exit
        end;

        // While loops conditions not handled.
        if (sCommand = 'if') then
        begin
          bResult := lowercase(EvalExpr(sCondition)) = 't';
          //bResult := lowercase(SDEvaluateExpr(sCondition)) = 't';
          //bResult := (SDEvaluateExpr(sCondition)) = '1';
          // Parser.Evaluate(sCondition); bResult := Parser.Value='1';
          bSkip := bResult;
        end
        else if (sCommand = 'else if') then
        begin
          if bSkip then
            bResult := False
          else
            bResult := Not bResult;
          if bResult then
          begin
            bResult := lowercase(EvalExpr(sCondition)) = 't';
            //bResult := lowercase(SDEvaluateExpr(sCondition)) = 't';
            //bResult := (SDEvaluateExpr(sCondition)) = '1';
            // Parser.Evaluate(sCondition); bResult := Parser.Value='1';
            bSkip := bResult;
          end;
        end
        else if (sCommand = 'else') then
        begin
          if bSkip then
            bResult := False
          else
          begin
            bResult := Not bResult;
            bSkip := bResult;
          end;
        end
        else if (sCommand = 'end') then
        begin
          bResult := True;
          bSkip := False;
        end
        else if (sCommand = 'break') then
        begin
          bBreak := True;
          bResult := True;
          bSkip := False;
        end
        else if (bResult) or (Not bResult) then
        begin
          if (Not bIsTaskAdded) or ((sGrouping = '') or (sGrouping='t'{'with prior'})) then
          begin
            if (sGrouping = 'f') then
              sAxGroupWithPriorIndex := pPegXDS.CDS.FieldByName('IndexNo').AsString;
            sProcessName := pPegXDS.CDS.FieldByName('ProcessName').AsString;
            sTaskName := pPegXDS.CDS.FieldByName('TaskName').AsString;
            if Trim(sTaskName) <> '' then
            begin
              sTaskType := pPegXDS.CDS.FieldByName('TaskType').AsString;

              //SubTasks check starts
              sParentTask := pPegXDS.CDS.FieldByName('parenttaskname').AsString;
              bIsSubTask := (Trim(sParentTask) <> '');

              //SubTasks ends

              // sIndexNo := pPEGXDS.CDS.FieldByName('IndexNo').AsString;
              sKeyField := pPegXDS.CDS.FieldByName('KeyField').AsString;
              if bIsFirstMake then   //this can be moved to 'make' condition block
                 sPEGGlobalKeyValue := GetFieldValue(sKeyField, 1);
              structdef.axprovider.dbm.gf.DoDebug.msg
                ('EVALProcessSet/ProcessName : ' + sProcessName +
                '. TaskName : ' + sTaskName);

              //if SubTasks is true and SkipSubTasks is true then SKip and continue
              (*
              This case will come while process the parent task (When SubTasks are completed and the Active Task set to Parent Task)
              *)
              if (bIsSubTask) and (bSkipSubTasks) then
              begin
                structdef.axprovider.dbm.gf.DoDebug.msg
                  ('EVALProcessSet/ Skipping SubTask '+sTaskName);
                sStatus := 'skipped';
                sTaskId := '';
              end
              else if (bResult) then
              begin
                // Add Current record to ActiveTasks list.
                if (lowercase(sTaskType) = 'make') and (bIsFirstMake) then //if lowercase(sCommand) = 'make' then
                begin
                  bIsCurrentPEGTask := True;
                  bCurMakeIsSubTask := bIsSubTask; //bCurMakeIsSubTask - Current make task
                  sCurMakeTasksParent := sParentTask; //Parent TaskName

//                  (*
//                    If current make is not a subtask then check for Active Subtasks for the current tasks
//                    If we add this condition then nested subtask is not possible.If req it has to be handled accordingly.
//                  *)
//
//                  if (Not bCurMakeIsSubTask) then
//                    bHasActiveSubTasks := HasActiveSubTasks(sProcessName,sTaskName);

                  structdef.axprovider.dbm.gf.DoDebug.msg
                    ('EVALProcessSet/ Calling AddRecToAxActiveTasks / PEG init for this transaction.');
                  //Checking indexno condition not required since we have added bIsFirstMake flag. | Internal test done | need to confirm
                  (*
                  if (sIndexNo = '1') and (sSubIndexNo = '1') then //if same indexno comes then subindex need to be considered here. as of now adding subindex also
                    sTaskId := AddRecToAxActiveTasks(pPegXDS, { sIndexNo } {'0'}pPriorIndex,{ sTaskName } {''}pPriorTask)
                  else
                    sTaskId := ''; // empty taskid handled in AddRecToAxActiveTaskStatus func
                  *)
                  sTaskId := AddRecToAxActiveTasks(pPegXDS, { sIndexNo } {'0'}pPriorIndex,{ sTaskName } {''}pPriorTask);
                  bIsCurrentPEGTask := False;
                  sStatus := 'made';
                  //bIsFirstMake := False;
                end
                else
                begin
                  (*
                  bCurMakeIsSubTask - Current Make type task
                  bIsSubTask - Next task

                  If current task is subtask And next task is not subtask
                  then add parent task to ActiveTasks (with recid)
                  (can be tasken from AxActiveTasks and insert into same table with diff taskid)
                  *)
                  if (bCurMakeIsSubTask) and (Not bIsSubTask) then
                  begin
                    structdef.axprovider.dbm.gf.DoDebug.msg
                    ('EVALProcessSet/ Getting parent tasks XDS.');
                    bIsParentTask := True;
                    sTaskId := AddRecToAxActiveTasks(
                      GetParentTaskXDSOfSubTask(sProcessName,sCurMakeTasksParent, sPEGGlobalKeyValue)
                      , pPriorIndex,pPriorTask);
                    bIsParentTask := False;
                    bBreak := True;
                  end
                  else if HasSubTasks(sProcessName,{sCurMakeTasksParent}sParentTask{sTaskName},sPEGGlobalKeyValue,sSubTaskNames) then
                  begin
                    //If the task is a parent task and it has active subtasks then do not do anything just exit from this process.
                    if HasActiveSubTasks(sProcessName,{sCurMakeTasksParent}sParentTask{sTaskName},sPEGGlobalKeyValue,sSubTaskNames) then
                      bBreak := True
                    else if HaveSubTasksCompleted(sProcessName,sTaskName,sPEGGlobalKeyValue) then// if there is no active subtasks then Get NextTask for
                      bSkipSubTasks := True
                    else
                      sTaskId := AddRecToAxActiveTasks(pPegXDS,pPriorIndex,pPriorTask);
                  end
                  else
                    sTaskId := AddRecToAxActiveTasks(pPegXDS,pPriorIndex,pPriorTask);
                end;
                //If TaskId <> '' then only Task is added to the activetasks
                if (sTaskId <> '') Then bIsTaskAdded := True;
              end
              else
              begin
                structdef.axprovider.dbm.gf.DoDebug.msg
                  ('EVALProcessSet/ Skipping PEG init for this transaction.');
                sStatus := 'skipped';
                sTaskId := '';
              end;
              if (lowercase(sTaskType) = 'make') and (bIsFirstMake) then  //if lowercase(sCommand) = 'make' then
              begin
              sTaskId := AddRecToAxActiveTaskStatus(pPegXDS, sTaskId, sStatus);
              //RegisterAxTaskParams before proceeding | RegisterAxActiveParams called in two places need to check
              RegisterAxActiveParams(sProcessName,sTaskName,sPEGGlobalKeyValue,TransType);
                if sStatus = 'made' then
                begin
                  bIsFirstMake := False; //After first make - completed(made) set value as false to handle multiple make
                  PegInit_PEGV2(pPegXDS);//PegInit(pPegXDS);
                  AddRecToAxProcess(pPegXDS,sTaskId,sStatus);
                  //Auto forward the task if presence of the same "To user" in both the current and next levels.
                  DoAutoForwardForSameUser(sTaskId);
                  Exit;// PegInit_PEGV2 itself process all tasks so the further looping can be skipped.
                end
                //This condition need to be checked, if it fails it has to be removed
                else if sStatus = 'skipped' then
                  bBreak := True; //If firstmake , tasktype = made and its skipped then break
              end;
            end;
          end
          else
          begin
            // sGrouping='after prior'
            bBreak := True;
          end;
        end;
        pPegXDS.CDS.Next;
        //pPegXDS.CDS.Refresh;
      end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('EVALProcessSet ends.');
  Except
    on E: Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in EVALProcessSet ' +
        E.Message);
  End;
end;

//GetAxProcessDef
function TAxPEG.GetAxProcessDef(transtype : string;pProcessName : String = '') : TXDS;
var
  pegXDS : TXDS;
  sSQLQuery,sWhrStr,sOrderBy : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetAxProcessDef starts...');
  pegXDS := nil;
  try
    pegXDS := structdef.axprovider.dbm.GetXDS(nil);
    pegXDS.buffered := True;
    //The below code commented since we need to refer processowner and processownerflg from process master
//    pegXDS.cds.CommandText := 'select * from axprocessdefv2 where '+structdef.axprovider.dbm.gf.sqllower+
//                              '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
//                              structdef.axprovider.dbm.gf.sqllower+
//                              '(processname)='+QuotedStr(lowercase(pProcessName))+ ' and '+
//                              structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' '
//                              +' order by IndexNo ';//+' order by IndexNo,SubIndexNo ';
//                              //+' and '+structdef.axprovider.dbm.gf.sqllower+'(tasktype)=''make'' ';

     sSQLQuery :=
    //'SELECT pdv.*, ppm.powner as processowner , ppm.pownerflg as processownerflg '+
    'SELECT ppm.powner as processowner , ppm.pownerflg as processownerflg, ppm.amendment, pdv.* '+
    ' FROM AxprocessDefV2 pdv '+
    ' JOIN axpdef_peg_processmaster ppm ON pdv.processname = ppm.caption ';
    sWhrStr := ' WHERE '+ structdef.axprovider.dbm.gf.sqllower+
    '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
    structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' ';
	
	if pProcessName <> '' then
      sWhrStr := sWhrStr +' and '+ structdef.axprovider.dbm.gf.sqllower+
                              '(processname)='+QuotedStr(lowercase(pProcessName));
    //added pProcessName since from the calling point for amendment we are not passing
    //processname, it has to be handled properly with flags to idnetify whether the call is from PEG / Amendment
	  if (structdef.IsAmendmentEnabled) and (pProcessName = '') then
      //sWhrStr := sWhrStr +' and '+structdef.axprovider.dbm.gf.sqllower+'(amendment)=''t'' '
      sWhrStr := sWhrStr +' and '+structdef.axprovider.dbm.gf.sqllower+'(ppm.amendment)=''t'' '
    else
      //sWhrStr := sWhrStr +' and '+structdef.axprovider.dbm.gf.sqllower+'(amendment)<>''t'' ';
      sWhrStr := sWhrStr +' and (ppm.amendment is null or ppm.amendment = '''' or '+
                 structdef.axprovider.dbm.gf.sqllower+'(ppm.amendment)<> ''t'')';
    sOrderBy := ' order by IndexNo ';
    pegXDS.cds.CommandText := sSQLQuery + sWhrStr + sOrderBy;
    pegXDS.open;
    result := pegXDS
  Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\GetAxProcessDef - '+e.Message);
      if Assigned(pegXDS) then
      begin
        if pegXDS.Active then pegXDS.close;
        FreeAndnil(pegXDS);
      end;
      result := pegXDS;
      structdef.axprovider.dbm.gf.DoDebug.msg('GetAxProcessDef Error : ' +e.Message);
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetAxProcessDef ends.');
end;


//CheckAxProcessDef_PEGV2
(*
Command based
*)
Procedure TAxPEG.CheckAxProcessDef_PEGV2;
var
  pegXDS,pegProcessXDS : TXDS;
  sApplicabilityExpr,sProcessName,sTaskName,sIndexNo,sStatus,sKeyField,sTaskId : String;
  bApplicability : Boolean;
begin
  try
    //If the transaction is peg attached transaction then continue or exit.
    structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2 starts...');
    pegXDS := nil;
    pegProcessXDS := nil;
    try
      pegXDS := structdef.axprovider.CheckAxProcessDef(transtype,'v2'); // check for maketype records
      if PegXDS.CDS.RecordCount > 0 then
      begin
        PegXDS.CDS.First;
        while Not PegXDS.CDS.Eof do
        begin
          sProcessName := pegXDS.CDS.FieldByName('ProcessName').AsString;
          pegProcessXDS := GetAxProcessDef(transtype,sProcessName);
          pegProcessXDS.CDS.First;
          bIsFirstMake := True;//For each process it will be set to true
          EVALProcessSet(pegProcessXDS);
          PegXDS.CDS.Next;
        end;
      end
      else
        structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2/Process not found for this transaction.');
      (*
      if pegXDS.CDS.RecordCount > 0 then
      begin
        pegXDS.CDS.First;
        while Not pegXDS.CDS.EOF do
        begin
          sProcessName := pegXDS.CDS.FieldByName('ProcessName').AsString;
          sTaskName := pegXDS.CDS.FieldByName('TaskName').AsString;
          sIndexNo := pegXDS.CDS.FieldByName('IndexNo').AsString;
          sKeyField := pegXDS.CDS.FieldByName('KeyField').AsString;
          sPEGGlobalKeyValue  := GetFieldValue(sKeyField,1);
          structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2/ProcessName '+sProcessName);
          //Check applicablity for make type record
          bApplicability := False;
          sApplicabilityExpr := pegXDS.CDS.FieldByName('Applicability').AsString;
          if sApplicabilityExpr <> '' then
          begin
            structdef.axprovider.dbm.gf.DoDebug.msg
              ('GetNextTask/ Evaluating  Applicability expression ' +
              sApplicabilityExpr);
            if Assigned(SDEvaluateExpr) then
              bApplicability := lowercase(SDEvaluateExpr(sApplicabilityExpr)) = 't'
            else
              raise exception.Create('SDEvaluateExpr is not assigned.');
          end
          else
            bApplicability := True;
          // If Applicability is empty('') then set bApplicability value as true
          if Not bApplicability then
          begin
             structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2/Applicablity is false, so Skipping PEG init for this transaction.');
             sStatus := 'skipped';
          end
          else
          begin
            bIsCurrentPEGTask := True;
            sTaskId := AddRecToAxActiveTasks(pegXDS,{sIndexNo}'0',{sTaskName}'');
            bIsCurrentPEGTask := False;
            sStatus := 'made';
          end;
          AddRecToAxActiveTaskStatus(pegXDS,sTaskId,sStatus);
          if sStatus = 'made' then
            PegInit(pegXDS);
          pegXDS.CDS.Next;
        end;
      end;
      *)
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\CheckAxProcessDef_PEGV2 - '+e.Message);
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\CheckAxProcessDef_PEGV2 - '+e.Message);
    end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2 ends.');
  finally
    if Assigned(pegXDS) then
    begin
      //if pegXDS.Active then pegXDS.close;
      FreeAndnil(pegXDS);
    end;
    if Assigned(pegProcessXDS) then
      FreeAndNil(pegProcessXDS);
  end;
end;


//GetNextTask_PEGV2
Procedure TAxPEG.GetNextTask_PEGV2(pCurTaskName, pCurProcessName,pKeyValue,
  pTransid: String);
var
   PegXDS : TXDS;
   iCurrentRecNo : Integer;
   sPriorTaskName,sPriorIndexNo,sMaxIndexNo,sGroupWithPriorIndex : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2 starts...');
  try
    iCurrentRecNo := 0;
    PegXDS := nil;
    PegXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegXDS.buffered := true;
    //The below code commented since we need to refer processowner and processownerflg from process master
//    PegXDS.CDS.CommandText := 'select * from axprocessdefv2 where ' +
//      structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
//      (quotedstr(lowercase(pCurProcessName))) + ' and '+
//      structdef.axprovider.dbm.gf.sqllower + '(active)=' + (quotedstr('t')) +
//      ' order by IndexNo,SubIndexNo asc';

    PegXDS.CDS.CommandText :=
    //'SELECT pdv.*, ppm.powner as processowner , ppm.pownerflg as processownerflg '+
    'SELECT ppm.powner as processowner , ppm.pownerflg as processownerflg,pdv.*  '+
    ' FROM AxprocessDefV2 pdv '+
    ' JOIN axpdef_peg_processmaster ppm ON pdv.processname = ppm.caption '+
    ' WHERE '+ structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
      (quotedstr(lowercase(pCurProcessName))) + ' and '+
      structdef.axprovider.dbm.gf.sqllower + '(active)=' + (quotedstr('t')) +
      ' ORDER BY IndexNo asc';

    PegXDS.open;
    if PegXDS.CDS.RecordCount > 0 then
    begin
      (*
      PegXDS.CDS.First;
      PegXDS.CDS.Filtered := false;
      PegXDS.CDS.Filter := structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +
          quotedstr(lowercase(pCurTaskName));
      PegXDS.CDS.Filtered := true;
      *)
      PegXDS.CDS.First;
      if PegXDS.CDS.Locate('TaskName',pCurTaskName,[loCaseInsensitive]) then
      //if PegXDS.CDS.RecordCount > 0 then
      begin
        if IsSameGroupedIndexTaskExistsAndActive(pCurProcessName,pCurTaskName,pTransId,sGroupWithPriorIndex) then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ Parallel taks found and the task is active. So skipping the GetNextTask process now.');
          exit;
        end;

        sMaxIndexNo := GetMaxIndexNo(pCurProcessName,sGroupWithPriorIndex);
        if PegXDS.CDS.Locate('IndexNo',sMaxIndexNo,[loCaseInsensitive]) then
        begin
          iCurrentRecNo := PegXDS.CDS.RecNo;
          //
          sPriorTaskName := PegXDS.CDS.FieldByName('TaskName').AsString;
          sPriorIndexNo := PegXDS.CDS.FieldByName('IndexNo').AsString;
          PegXDS.CDS.Filtered := false;
          iCurrentRecNo := iCurrentRecNo+1;//Move to Next record [Current record already processed record]
          if iCurrentRecNo <= PegXDS.CDS.RecordCount then
          begin
            PegXDS.CDS.RecNo := iCurrentRecNo;
            structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/Calling EVALProcessSet...');
            //RegisterAxTaskParams before Calling Eval in GetNextTask_PEGV2
            RegisterAxActiveParams(pCurProcessName,pCurTaskName,pKeyValue,pTransid);
            EVALProcessSet(PegXDS,sPriorIndexNo,sPriorTaskName);
          end;
        end;
      end
      else
        structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2/Task not found for this transaction.');
    end
    else
      structdef.axprovider.dbm.gf.DoDebug.msg('CheckAxProcessDef_PEGV2/Process not found for this transaction.');
    (*
    if result.CDS.RecordCount > 0 then
      result.CDS.First;
    While Not result.Eof do // if getNextTaskXDS.CDS.RecordCount > 0 then
    begin
      result.CDS.Filtered := false;
      result.CDS.Filter := structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +
        quotedstr(lowercase(pCurTaskName));
      result.CDS.Filtered := true;

      sNextTaskExpr := result.CDS.FieldByName('NextTask').AsString;
      iCurIndexNo := result.CDS.FieldByName('IndexNo').AsInteger;
      if sNextTaskExpr <> '' then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ Evaluating next task expression : ' +
          sNextTaskExpr);
        if Assigned(SDEvaluateExpr) then
        begin
          sNextTask := SDEvaluateExpr(sNextTaskExpr);
          if sNextTask <> '' then
          begin
            result.CDS.Filtered := false;
            // if required TaskType filter has to be added.
            result.CDS.Filter := structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +
              quotedstr(lowercase(sNextTask));
            result.CDS.Filtered := true;
            if result.CDS.RecordCount > 0 then
              bNextTaskFound := true
            else
              raise exception.Create('Task ' + sNextTask + ' not found.');
          end;
        end
        else
          raise exception.Create('SDEvaluateExpr is not assigned.');
      end;
      if Not bNextTaskFound then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ Finding next task using indexno.');
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ reading subindexno.');
          //Get Current SubIndexNo
          iCurSubIndexNo := result.CDS.FieldByName('SubIndexNo').AsInteger;

          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ Finding next task using indexno.'+inttostr(iCurIndexNo));
          structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2/ Finding next task using subindexno.'+inttostr(iCurSubIndexNo));

          //if CurrentIndex Has Two More records (same index with diff subindex) then process it here
          result.CDS.Filtered := false;
          result.CDS.Filter := 'IndexNo = ' + inttostr((iCurIndexNo))+' and SubIndexNo = '+InttoStr((iCurSubIndexNo+1));
          result.CDS.Filtered := true;
          if result.CDS.RecordCount > 0 then
            bNextTaskFound := true
          else
          begin
            // Check record for CurrentIndex + 1
            result.CDS.Filtered := false;
            result.CDS.Filter := 'IndexNo = ' + inttostr((iCurIndexNo + 1));
            result.CDS.Filtered := true;
            if result.CDS.RecordCount > 0 then
              bNextTaskFound := true;
          end;
        end;
      end;
      if bNextTaskFound then
      begin
        sApplicabilityExpr := result.CDS.FieldByName('Applicability').AsString;
        if sApplicabilityExpr <> '' then
        begin
          structdef.axprovider.dbm.gf.DoDebug.msg
            ('GetNextTask_PEGV2/ Evaluating  Applicability expression ' +
            sApplicabilityExpr);
          if Assigned(SDEvaluateExpr) then
          begin
            bApplicability := lowercase(SDEvaluateExpr(sApplicabilityExpr)) = 't';
          end
          else
            raise exception.Create('SDEvaluateExpr is not assigned.');
        end
        else
          bApplicability := true;
        // If Applicability is empty('') then set bApplicability value as true
        if bApplicability then
        begin
          break; // Exit;
        end
        else
        begin
          pCurTaskName := result.CDS.FieldByName('TaskName').AsString;
          //Refer PEGREST GETNEXTTASK
          //UpdateSkippedTask({result.CDS.FieldByName('TaskId').AsString}sTaskId,result.CDS.FieldByName('KeyField').AsString);
          result.CDS.Filtered := false;
          bNextTaskFound := false;
        end;
      end
      else
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2 : Next task not found.');
        // raise Exception.Create('GetNextTask : Next task not found.');
        exit;
      end;
    end;
    if Not bNextTaskFound then
      structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2 : Next task not found.');
    *)
    structdef.axprovider.dbm.gf.DoDebug.msg('GetNextTask_PEGV2 ends.');
  finally
    if Assigned(PegXDS) then
      FreeAndNil(PegXDS);
  end;
end;

//PegInit_PEGV2
Procedure TAxPEG.PegInit_PEGV2(pPegXDS : TXDS);
var
  sCurProcIndexNo,sNextProcIndexNo,sCurProcTaskName : String;
  sCurProcessname,sKeyField,sKeyValue : String;
  PegGetActiveXDS : TXDS;
begin
  PegGetActiveXDS := nil;
  if Not Assigned(pPegXDS) then
    Exit;
  structdef.axprovider.dbm.gf.DoDebug.msg('PegInit_PEGV2 starts...');
  try
  PegGetActiveXDS := structdef.axprovider.dbm.GetXDS(nil);
  begin
    sCurProcIndexNo := pPegXDS.cds.Fieldbyname('IndexNo').AsString;
    sCurProcTaskName := pPegXDS.cds.Fieldbyname('Taskname').AsString;
    sCurProcessname := pPegXDS.cds.Fieldbyname('ProcessName').AsString;

    sKeyField := pPegXDS.cds.Fieldbyname('KeyField').AsString;
    sKeyValue := GetFieldValue(sKeyField,1);
    sNextProcIndexNo :=  InttoStr(StrtoInt(sCurProcIndexNo)+1); //CurrentIndexNo + 1

    //Add record to AxActiveTasks | All Same index make type data processed or not
    if CanInitiatePEG(sCurProcessname,sCurProcTaskName,sCurProcIndexNo,sKeyValue) then
    begin
      GetNextTask_PEGV2(sCurProcTaskName,pPegXDS.cds.Fieldbyname('ProcessName').AsString,sKeyValue,transtype);
      (*
      PegGetActiveXDS := GetNextTask(sCurProcTaskName,pPegXDS.cds.Fieldbyname('ProcessName').AsString,transtype);
      if Assigned(PegGetActiveXDS) and (PegGetActiveXDS.CDS.RecordCount > 0) then
      begin
        PegGetActiveXDS.CDS.First;
        while Not PegGetActiveXDS.CDS.EOF do
        begin
          AddRecToAxActiveTasks(PegGetActiveXDS,sCurProcIndexNo,sCurProcTaskName);
          PegGetActiveXDS.CDS.Next;
        end;
      end;
      *)
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('PegInit_PEGV2 ends.');
  finally
    if Assigned(PegGetActiveXDS) then
    begin
      if PegGetActiveXDS.Active then
        PegGetActiveXDS.close;
      FreeAndNil(PegGetActiveXDS);
    end;
  end;
end;


//function to delete a single character from a string at a specified index position:
function DeleteCharAtIndex(const S: string; Index: Integer): string;
begin
  if (Index < 1) or (Index > Length(S)) then
    Result := S
  else
    Result := Copy(S, 1, Index - 1) + Copy(S, Index + 1, Length(S) - Index);
end;



//RegsiterIntoParser
Procedure TAxPEG.RegisterToParser(pVarName,pVarType,pVarValue : String);
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('RegisterToParser starts... ');
  if Assigned(SDRegVarToParser) then
    SDRegVarToParser(pVarName,pVarType,pVarValue)
  else if Assigned(Parser) then
    Parser.RegisterVar(pVarName,pVarType[1],pVarValue)
  else
    structdef.axprovider.dbm.gf.DoDebug.msg('RegisterToParser/unable register variable '+pVarName);

  structdef.axprovider.dbm.gf.DoDebug.msg('RegisterToParser ends. ');
end;


//RegsiterIntoParser
Function TAxPEG.EvalExpr(pExpr : String):String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('EvalExpr starts... ');
  result := '';
  if Assigned(SDEvaluateExpr) then
    result := SDEvaluateExpr(pExpr)
  else if Assigned(Parser) then
  begin
    Parser.Evaluate(pExpr);
    result := Parser.Value;
  end
  else
    structdef.axprovider.dbm.gf.DoDebug.msg('EvalExpr/unable evaluate Expr '+pExpr);
  structdef.axprovider.dbm.gf.DoDebug.msg('Result of EvalExpr : '+result);
  structdef.axprovider.dbm.gf.DoDebug.msg('EvalExpr ends. ');
end;


//RegisterAxActiveParams
Procedure TAxPEG.RegisterAxActiveParams(pProcessName,pTaskName,pKeyValue,pTransId : String);
var
  sTaskParams,sTaskParam,sParamName : String;
  sTransId,sFieldName,sParamValue : String;
  slTaskParamList : TStringList;
  I ,iDOTIdx: Integer;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams starts... ');
  try
  slTaskParamList := nil;
  try
    slTaskParamList := TStringList.Create;
    slTaskParamList.Delimiter := ',';
    slTaskParamList.StrictDelimiter := True;

    sTaskParams := GetTaskParams(pProcessName,pTaskName,pKeyValue,pTransId,0);
    slTaskParamList.DelimitedText := sTaskParams;
    //if same taskparam used at different level(index) then it will be overwritten by the latest one
    for I := 0 to slTaskParamList.count-1 do
    begin
      sTaskParam := slTaskParamList[I];
      sParamName := structdef.axprovider.dbm.gf.GetNthString(sTaskParam,1,'=');
      sParamValue := structdef.axprovider.dbm.gf.GetNthString(sTaskParam,2,'=');

      structdef.axprovider.dbm.gf.DoDebug.msg('Task Param name : ' + sParamName);
      structdef.axprovider.dbm.gf.DoDebug.msg('Task Param value : ' + sParamValue);
      if {Assigned(SDRegVarToParser) and} (sParamName <> '') then
      begin
        //SDRegVarToParser(sParamName,'c',sParamValue);
        RegisterToParser(sParamName,'c',sParamValue);
        (*
        TaskParams name will be in the below format
        transid.datatype+fieldname
        But when we use this in actor it will not work, since actor conditions
        will be having field name like transid+.fieldname, to handle this we are
        registering without datatype also in parser.
        *)
        //SDRegVarToParser(DeleteCharAtIndex(sParamName,pos('.',sParamName)+1),'c',sParamValue);
        RegisterToParser(DeleteCharAtIndex(sParamName,pos('.',sParamName)+1),'c',sParamValue);
      end;
      (*
      iDOTIdx := Pos('.',sParamName);
      if (iDOTIdx > 0) then //As per new change, transaction fields prefixed with "transid."
      begin
        sTransId := Copy(sParamName,1,iDOTIdx-1);
        sFieldName := Copy(sParamName,iDOTIdx+1,Length(sParamName));
        sFieldName := Copy(sFieldName,2,Length(sFieldName));//Fieldname prefixedwith datatype
        structdef.axprovider.dbm.gf.DoDebug.msg('TransId : ' + sTransId);
        structdef.axprovider.dbm.gf.DoDebug.msg('FieldName : ' + sFieldName);
        //if same transid
        if Lowercase(TransType) = LowerCase(sTransId) then
          sParamValue := sParamValue+','+sParamName + '=' +GetFieldValue(sFieldName,1)
        else
          sParamvalue := sParamValue+','+sTaskParam;
      end;
      *)
    end;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetTaskParams : '+E.Message);
  end;
  finally
    if Assigned(slTaskParamList) then
      FreeAndNil(slTaskParamList);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams ends. ');
end;


//GetTaskParams
(*
pParamsFrom
0 - AxActiveTaskParams
1 - AxProcessDef
*)

Function TAxPEG.GetTaskParams(pProcessName,pTaskName,pKeyValue,pTransId : String;pParamsFrom : Integer):String;
var
  GetTaskParamsXDS : TXDS;
  sSQLText,sTaskParams : String;
begin
  result := '';
  sTaskParams := '';
  GetTaskParamsXDS := nil;
  try
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams starts... ');
  try
    GetTaskParamsXDS :=  structdef.axprovider.dbm.GetXDS(nil);
    GetTaskParamsXDS.buffered := true;
    if pParamsFrom = 0 then
      sSQLText := 'select TaskParams from AxActiveTaskParams where '+
                structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
                (quotedstr(lowercase(pProcessName))) + ' and '+
                structdef.axprovider.dbm.gf.sqllower + '(KeyValue)=' +
                (quotedstr(lowercase(pKeyValue))) +{ ' and '+
                structdef.axprovider.dbm.gf.sqllower + '(Transid)=' +
                (quotedstr(lowercase(pTransId))) +} //As of now skipping the transid if multiple make is there then its hard to get previour params
                ' order by eventdatetime desc'
    else
      sSQLText := 'select TaskParams from axprocessdefv2 where '+
                structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
                (quotedstr(lowercase(pProcessName))) + ' and '+
                structdef.axprovider.dbm.gf.sqllower + '(TaskName)=' +
                (quotedstr(lowercase(pTaskName))) + ' and '+
                structdef.axprovider.dbm.gf.sqllower + '(Transid)=' +
                (quotedstr(lowercase(pTransId)));

    GetTaskParamsXDS.CDS.CommandText := sSQLText;
    GetTaskParamsXDS.open;
    if GetTaskParamsXDS.cds.RecordCount > 0 then
      sTaskParams := GetTaskParamsXDS.CDS.FieldByName('TaskParams').AsString;

    result := sTaskParams;
  Except on E:Exception do
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\GetTaskParams - '+e.Message);
    structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\GetTaskParams - '+e.Message);
  end;
  end;
  finally
    if Assigned(GetTaskParamsXDS) then
    begin
      if GetTaskParamsXDS.Active then
        GetTaskParamsXDS.close;
      FreeAndNil(GetTaskParamsXDS);
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams ends. ');
end;

(*
Function TAxPEG.GetTaskParams(pProcessName,pTaskName,pKeyValue,pTransId : String;pParamsFrom : Integer):String;
var
  GetTaskParamsXDS : TXDS;
  sSQLText,sTaskParams : String;
begin
  result := '';
  sTaskParams := '';
  GetTaskParamsXDS := nil;
  try
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams starts... ');
  try
  GetTaskParamsXDS :=  structdef.axprovider.dbm.GetXDS(nil);
  GetTaskParamsXDS.buffered := true;
  sSQLText := 'select TaskParams from AxActiveTaskParams where '+
              structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
              (quotedstr(lowercase(pProcessName))) + ' and '+
              structdef.axprovider.dbm.gf.sqllower + '(KeyValue)=' +
              (quotedstr(lowercase(pKeyValue))) + ' and '+
              structdef.axprovider.dbm.gf.sqllower + '(Transid)=' +
              (quotedstr(lowercase(pTransId))) +
              ' order by eventdatetime desc';

  GetTaskParamsXDS.CDS.CommandText := sSQLText;
  GetTaskParamsXDS.open;
  if GetTaskParamsXDS.cds.RecordCount > 0 then
  begin
    sTaskParams := GetTaskParamsXDS.CDS.FieldByName('TaskParams').AsString;
  end
  else
  begin
    GetTaskParamsXDS.close;
    GetTaskParamsXDS.buffered := true;
    sSQLText := 'select TaskParams from AxProcessDef where '+
              structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +
              (quotedstr(lowercase(pProcessName))) + ' and '+
              structdef.axprovider.dbm.gf.sqllower + '(TaskName)=' +
              (quotedstr(lowercase(pTaskName))) + ' and '+
              structdef.axprovider.dbm.gf.sqllower + '(Transid)=' +
              (quotedstr(lowercase(pTransId)));

    GetTaskParamsXDS.CDS.CommandText := sSQLText;
    GetTaskParamsXDS.open;
    if GetTaskParamsXDS.cds.RecordCount > 0 then
    begin
      sTaskParams := GetTaskParamsXDS.CDS.FieldByName('TaskParams').AsString;
    end;
  end;
  result := sTaskParams;
  Except on E:Exception do
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\GetTaskParams - '+e.Message);
    structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\GetTaskParams - '+e.Message);
  end;
  end;
  finally
    if Assigned(GetTaskParamsXDS) then
    begin
      if GetTaskParamsXDS.Active then
        GetTaskParamsXDS.close;
      FreeAndNil(GetTaskParamsXDS);
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParams ends. ');
end;
*)

//GetTaskParamsValues
Function TAxPEG.GetTaskParamsValues(pTaskParams : String):String;
var
  sTaskParamsList : TStringList;
  sTaskParam,sParamName,sParamValue,sTransId,sFieldName,sFieldValue : String;
  I,iDOTIdx : Integer;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParamsValues starts... ');
  try
    sTaskParamsList := nil;
    sParamValue := '';
    sTaskParamsList := TStringList.Create;
    sTaskParamsList.Delimiter := ',';
    sTaskParamsList.StrictDelimiter := True;
    sTaskParamsList.DelimitedText := pTaskParams;
    for I := 0 to sTaskParamsList.count-1 do
    begin
      //If data comes from axprecessdef , only comma separated taskparams name comes
      //if data comes from AxTaskParams then fieldname with value it comes.
      //sParamName := sTaskParamsList.Names[I]; //sTaskParamsList[I];
      sFieldValue := '';
      sTaskParam := sTaskParamsList[I];
      sParamName := structdef.axprovider.dbm.gf.GetNthString(sTaskParam,1,'=');
      structdef.axprovider.dbm.gf.DoDebug.msg('Task Param name: ' + sParamName);
      structdef.axprovider.dbm.gf.DoDebug.msg('Task Param : ' + sTaskParam);

      //if param is date of initiation or date of notification then continue.
      //if (lowercase(sParamName) = 'static.ax__doi')
      //  or (lowercase(sParamName) = 'static.ax__don') then
      //    Continue;

      iDOTIdx := Pos('.',sParamName);
      if (iDOTIdx > 0) then //As per new change, transaction fields prefixed with "transid."
      begin
        sTransId := Copy(sParamName,1,iDOTIdx-1);
        sFieldName := Copy(sParamName,iDOTIdx+1,Length(sParamName));
        sFieldName := Copy(sFieldName,2,Length(sFieldName));//Fieldname prefixedwith datatype
        structdef.axprovider.dbm.gf.DoDebug.msg('TransId : ' + sTransId);
        structdef.axprovider.dbm.gf.DoDebug.msg('FieldName : ' + sFieldName);
        //if same transid
        if Lowercase(TransType) = LowerCase(sTransId) then
        begin
          sFieldValue := GetFieldValue(sFieldName,1);
          sParamValue := sParamValue+','+sParamName + '=' + sFieldValue
        end
        else
          sParamvalue := sParamValue+','+sTaskParam;
        //if Assigned(SDRegVarToParser) then
          //SDRegVarToParser(sParamName,'c',sFieldValue);
          RegisterToParser(sParamName,'c',sFieldValue);
      end;
    end;
    if sParamValue <> '' then
      Delete(sParamValue,1,1);
    result := sParamValue;
  finally
    if Assigned(sTaskParamsList) then
      FreeAndNil(sTaskParamsList);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTaskParamsValues ends. ');
end;


//ConvertTimestampToDateTime
function TAxPEG.ConvertTimestampToDateTime(const timestamp: string): string;
var
  year, month, day, hour, minute, second, ms: Word;
begin
  // Extract the individual date and time components from the timestamp
  year := StrToInt(Copy(timestamp, 1, 4));
  month := StrToInt(Copy(timestamp, 5, 2));
  day := StrToInt(Copy(timestamp, 7, 2));
  hour := StrToInt(Copy(timestamp, 9, 2));
  minute := StrToInt(Copy(timestamp, 11, 2));
  second := StrToInt(Copy(timestamp, 13, 2));
  ms := StrToInt(Copy(timestamp, 15, 3));

  // Create a TDateTime value using the extracted components
  //Result := Format('%4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d.%3.3d', [year, month, day, hour, minute, second, ms]);
  Result := Format('%4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d', [year, month, day, hour, minute, second]);
  try
    //Result := formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.ShortDateFormat,StrtoDateTime(Result));
    Result := formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.ShortDateFormat,EncodeDate(year,month,day)) +' '+
    formatdatetime(structdef.axprovider.dbm.gf.ShortDateFormat.LongTimeFormat,EncodeTime(hour,minute,second,ms))
  except
  end;
end;

//GetTransInitDateTime
Function TAxPEG.GetTransInitDateTime(pProcessName,pKeyValue : String):String;
var
  PegGetTaskIDXDS: TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTransInitDateTime starts...');
  Result := '';
  PegGetTaskIDXDS := nil;
  try
    try
    PegGetTaskIDXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegGetTaskIDXDS.buffered := True;
    PegGetTaskIDXDS.CDS.CommandText := 'Select eventdatetime from AxActiveTasks a where '+
                'lower(ProcessName)='+QuotedStr(lowercase(pProcessName))+ ' and '+
                //'lower(Taskname)='+QuotedStr(lowercase(sTaskName))+ ' and '+
                'lower(TaskType)='+QuotedStr('make')+ ' and '+
                'lower(KeyValue)='+QuotedStr(lowercase(pKeyValue))+ ' and '+
                //'lower(Transid)='+QuotedStr(lowercase(sTransId))+ ' and '+
                ' IndexNo = 1 '+ //index 1
                ' order by eventdatetime,IndexNo asc';

    PegGetTaskIDXDS.open;
    if PegGetTaskIDXDS.CDS.RecordCount > 0 then
       Result := PegGetTaskIDXDS.CDS.FieldByName('eventdatetime').AsString;
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetTransInitDateTime '+E.Message);
    end;
    end;
  finally
    if Assigned(PegGetTaskIDXDS) then
      FreeAndNil(PegGetTaskIDXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetTransInitDateTime ends.');
end;

//ReplaceValueInString
//replace the value of static.ax__don while keeping the rest of the string unchanged
function ReplaceValueInString(const originalStr, variableName, newValue: string): string;
var
  startIndex, endIndex: Integer;
begin
  // Find the starting index of the variableName
  startIndex := Pos(variableName, originalStr);

  if startIndex > 0 then
  begin
    // Find the ending index of the variable (search for the next comma)
    endIndex := PosEx(',', originalStr, startIndex);

    if endIndex = 0 then
      endIndex := Length(originalStr) + 1; // If no comma found, use the end of the string

    // Replace the value between startIndex and endIndex
    Result := Copy(originalStr, 1, startIndex - 1) + variableName + '=' + newValue +
              Copy(originalStr, endIndex, Length(originalStr));
  end
  else
  begin
    // If the variableName is not found, return the original string  with var and value
    Result := variableName+'='+newValue+','+originalStr;
  end;
end;


//AddRecToAxActiveTaskParams
Procedure TAxPEG.AddRecToAxActiveTaskParams(inpXDS: TXDS;pTaskId,pStatus : String);
var
  PegActiveTaskXDS: TXDS;
  sTaskId,sSubIndexNo,sKeyField,sKeyValue : String;
  sProcessName,sTaskName,sIndexNo,sTaskType,sTaskParams,
  sTaskParamsValue,sPrevTaskParamsValue : String;
  sDateOfInitiation,sDateOfNotification : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTaskParams starts...');
  PegActiveTaskXDS := nil;
  if Not Assigned(inpXDS) or (inpXDS.CDS.RecordCount = 0) then
    exit;
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('Adding recrod to AddRecToAxActiveTaskParams');

    sProcessName := inpXDS.CDS.FieldByName('ProcessName').AsString;
    sTaskName := inpXDS.CDS.FieldByName('TaskName').AsString;
    sTaskType := inpXDS.CDS.FieldByName('TaskType').AsString;
    sKeyField := inpXDS.CDS.FieldByName('KeyField').AsString;
    sKeyValue := GetFieldValue(sKeyField,1);
    sIndexNo := inpXDS.CDS.FieldByName('IndexNo').AsString;
    sSubIndexNo := inpXDS.CDS.FieldByName('SubIndexNo').AsString;
    //get TaskParams
    (*
    GetTaskParams from AxActiveTaskParams desc on eventdatetime to get latest updated taskparams
    if not exists then get it from AxProcessDef(V2 table)
    *)

    (*
    pParamsFrom
    0 - AxActiveTaskParams
    1 - AxProcessDef
    *)
    sTaskParams := GetTaskParams(sProcessName,sTaskName,sKeyValue,TransType,1);//inpXDS.CDS.FieldByName('TaskParams').AsString;
    if sTaskParams <> '' then
    begin
      sTaskParamsValue := GetTaskParamsValues(sTaskParams);
      //Curr TransId with replaced field bvalues will be returned.
      //That needs to be updated with existing TaskParam values. before adding into AxActiveTaskParams
    end;
    sPrevTaskParamsValue := GetTaskParams(sProcessName,sTaskName,sKeyValue,TransType,0);//inpXDS.CDS.FieldByName('TaskParams').AsString;

    if sPrevTaskParamsValue <> '' then
    begin
      if sTaskParamsValue <> '' then
        sTaskParamsValue := sPrevTaskParamsValue+','+sTaskParamsValue
      else
        sTaskParamsValue := sPrevTaskParamsValue;
    end;

    //These static values can exists in the previous tasks as well , to eleminate and avoid duplicates we have added the below
    //statements here, This cannot be handled in GetTaskParamsValues , since GetTaskParamsValues will be having curent task params only.
    //if DOI exists in TaskParam | Date of initiation will be same for transaction
    //if Pos('static.ax__doi',lowercase(sTaskParams)) > 0 then
    begin
      //Add date of initiation only if it doesn't exists
      if Pos('static.ax__doi', lowercase(sTaskParamsValue)) = 0 then
      begin
        sDateOfInitiation := ConvertTimestampToDateTime(GetTransInitDateTime(sProcessName,sKeyValue));
        if sTaskParamsValue <> '' then
          sTaskParamsValue := 'static.ax__doi'+'='+sDateOfInitiation+','+sTaskParamsValue
        else
          sTaskParamsValue := 'static.ax__doi'+'='+sDateOfInitiation;
      end;
    end;

    //if DON exists in TaskParam or it exists in TaskParamsValue | Date of notification will change for each task
    //if (Pos('static.ax__don',lowercase(sTaskParams)) > 0) or (Pos('static.ax__don',lowercase(sTaskParamsValue)) > 0) then
    begin
      //Add date of notification | replace value if it exists
      sDateOfNotification := ConvertTimestampToDateTime(GetPEGTaskEventDateTime);
      sTaskParamsValue := ReplaceValueInString(sTaskParamsValue,'static.ax__don',sDateOfNotification);
    end;

    //if pTaskId = '' then
    //  pTaskId := GetTaskId(TransType,sProcessName,sTaskName,sTaskType,sKeyValue,sIndexNo);

    if pTaskId = '' then
      sTaskId := floatTostr(structdef.axprovider.dbm.Gen_id(structdef.axprovider.dbm.connection))
    else
      sTaskId := pTaskId;

    PegActiveTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegActiveTaskXDS.Append('AxActiveTaskParams');
    PegActiveTaskXDS.submit('EventDateTime', GetPEGTaskEventDateTime{structdef.axprovider.dbm.gf.GetDateTimeStampString}, 'c');

    PegActiveTaskXDS.submit('TaskId',sTaskId,'c') ;
    PegActiveTaskXDS.submit('Transid', TransType, 'c');

    PegActiveTaskXDS.submit('KeyField', sKeyField, 'c');
    PegActiveTaskXDS.submit('KeyValue', sKeyValue, 'c');
    PegActiveTaskXDS.submit('RecordId',FloattoStr(LastSavedRecordId), 'n');
    PegActiveTaskXDS.submit('TaskStatus', pStatus, 'c');
    PegActiveTaskXDS.submit('Username', structdef.axprovider.dbm.gf.UserName, 'c');
    PegActiveTaskXDS.submit('ProcessName', sProcessName, 'c');
    PegActiveTaskXDS.submit('TaskName', sTaskName, 'c');
    PegActiveTaskXDS.submit('TaskType', sTaskType, 'c');
    PegActiveTaskXDS.submit('IndexNo', sIndexNo, 'n');
    if sSubIndexNo = '' then
      sSubIndexNo := '1';
    PegActiveTaskXDS.submit('SubIndexNo', sSubIndexNo, 'n');
    PegActiveTaskXDS.submit('PriorIndex', '0', 'n');
    PegActiveTaskXDS.submit('TaskParams', sTaskParamsValue, 'c');
    PegActiveTaskXDS.post;
  finally
    if Assigned(PegActiveTaskXDS) then
      FreeAndNil(PegActiveTaskXDS);
  end;

  structdef.axprovider.dbm.gf.DoDebug.msg('AddRecToAxActiveTaskParams ends.');
end;

//GetSameGroupedIndexTaskNames | GroupWithPrior
Function TAxPEG.GetSameGroupedIndexTaskNames(pCurProcessName,pCurTaskname,
  pTransid,pGroupWithPriorIndex: String):String;
var
  getTaskNameXDS : TXDS;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSameGroupedIndexTaskNames starts...');
  try
  Result := '';
  getTaskNameXDS := nil;
  try
    getTaskNameXDS := structdef.axprovider.dbm.GetXDS(nil);
    getTaskNameXDS.buffered := true;
    getTaskNameXDS.CDS.CommandText := 'select Taskname from AxActiveTasks where ' +
       //Transid filter may not be required, it may vary for tasks .Need to be removed if its not required.
       //Commenting Transid check
       //structdef.axprovider.dbm.gf.sqllower+'(transid)='+QuotedStr(lowercase(pTransid))+ ' and '+
       structdef.axprovider.dbm.gf.sqllower + '(ProcessName)=' +(quotedstr(lowercase(pCurProcessName))) +' and '+
       structdef.axprovider.dbm.gf.sqllower+'(Taskname)<>'+QuotedStr(lowercase(pCurTaskname))+ ' and '+
       structdef.axprovider.dbm.gf.sqllower+'(KeyValue)='+QuotedStr(lowercase(sPEGGlobalKeyValue))+ ' and '+
       //structdef.axprovider.dbm.gf.sqllower+'(active)=''t'' and '+
       'groupwithpriorindex = ' + pGroupWithPriorIndex;
    getTaskNameXDS.open;
    if (getTaskNameXDS.CDS.RecordCount > 0) then //if rec found with same index
    begin
       Result := '';
       getTaskNameXDS.First;
       while Not getTaskNameXDS.CDS.Eof do
       begin
         Result := Result+','+QuotedStr(getTaskNameXDS.CDS.FieldByName('TaskName').AsString);
         getTaskNameXDS.CDS.Next;
       end;
       Delete(Result,1,1);
    end;
  Except on E:Exception do
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetSameGroupedIndexTaskNames '+E.Message);
  end;
  finally
    if Assigned(getTaskNameXDS) then
      FreeAndNil(getTaskNameXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetSameGroupedIndexTaskNames ends.');
end;


//GetMaxIndexNo
Function TAxPEG.GetMaxIndexNo(pProcessName,pGroupedIndexNo:String): String;
var
  getMaxSubIdxXDS : TXDS;
begin
  try
  result := pGroupedIndexNo;
  getMaxSubIdxXDS := nil;
    try
      getMaxSubIdxXDS :=structdef.axprovider.dbm.GetXDS(nil);
      getMaxSubIdxXDS.buffered := true;
      getMaxSubIdxXDS.CDS.CommandText :=
           'select indexno,eventdatetime from axactivetasks a where '+
           structdef.axprovider.dbm.gf.sqllower + '(ProcessName) = ' +(quotedstr(lowercase(pProcessName))) +' and '+
           structdef.axprovider.dbm.gf.sqllower + '(Keyvalue) = ' +(lowercase(QuotedStr(sPEGGlobalKeyValue)))+' and '+
           ' groupwithpriorindex='+pGroupedIndexNo+' '+  //--tasktype = 'make'
           ' order by eventdatetime desc,indexno desc'; //To handle return rec , eventdatetime handled
      getMaxSubIdxXDS.open;
      if getMaxSubIdxXDS.CDS.RecordCount > 0 then
      begin
       getMaxSubIdxXDS.CDS.First;
       result := getMaxSubIdxXDS.CDS.FieldByName('indexno').AsString;
      end;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetMaxIndexNo '+E.Message);
    end;
  finally
    if Assigned(getMaxSubIdxXDS) then
      FreeAndNil(getMaxSubIdxXDS);
  end;
end;


//GetMaxSubIndexNo
Function TAxPEG.GetGroupWithPriorIndexNo(pProcessName,pTaskName,pTransid:String):String;
var
  getGroupWithPriorIdxXDS : TXDS;
begin
  try
  result := '';
  getGroupWithPriorIdxXDS := nil;
    try
      getGroupWithPriorIdxXDS :=structdef.axprovider.dbm.GetXDS(nil);
      getGroupWithPriorIdxXDS.buffered := true;
      getGroupWithPriorIdxXDS.CDS.CommandText :=
           'select groupwithpriorindex,eventdatetime from axactivetasks a where '+
           structdef.axprovider.dbm.gf.sqllower + '(ProcessName) = ' +(quotedstr(lowercase(pProcessName))) +' and '+
           structdef.axprovider.dbm.gf.sqllower + '(TaskName) = ' +(quotedstr(lowercase(pTaskName))) +' and '+
           structdef.axprovider.dbm.gf.sqllower + '(Transid) = ' +(quotedstr(lowercase(pTransid))) +' and '+
           structdef.axprovider.dbm.gf.sqllower + '(Keyvalue) = ' +(lowercase(QuotedStr(sPEGGlobalKeyValue)))+//+' and '+
           //' IndexNo='+pCurIndexNo+' '+  //--tasktype = 'make'
           ' order by eventdatetime desc'; //To get latest rec
      getGroupWithPriorIdxXDS.open;
      if getGroupWithPriorIdxXDS.CDS.RecordCount > 0 then
      begin
       getGroupWithPriorIdxXDS.CDS.First;
       result := getGroupWithPriorIdxXDS.CDS.FieldByName('groupwithpriorindex').AsString;
      end;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetGroupWithPriorIndexNo '+E.Message);
    end;
  finally
    if Assigned(getGroupWithPriorIdxXDS) then
      FreeAndNil(getGroupWithPriorIdxXDS);
  end;
end;



//SameGroupedIndexTaskExists
{
GroupWithPrior Tasks will have same grouped index
- SameGroupedIndex -  All same index should get complete before moving to Next Task
- If applicabilty F for one Task - and another task is completed then move to Next Task | Not possible to check applicabloty for parallel tasks
}
Function TAxPEG.IsSameGroupedIndexTaskExistsAndActive(pCurProcessName,pTaskname,
  pTransid: String;var pGroupWithPriorIndex : String):Boolean;
var
  CheckStatusXDS : TXDS;
  sTaskId,sTaskName,sProcessName,sGroupWithPriorIndex : String;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('IsSameGroupedIndexTaskExistsAndActive starts...');
  try
    Result := False;
    CheckStatusXDS := nil;
    try
    //The below functions can be merged into one by handling the functionality in sql query
    sGroupWithPriorIndex := GetGroupWithPriorIndexNo(pCurProcessName,pTaskname,pTransid);
    pGroupWithPriorIndex := sGroupWithPriorIndex;
    structdef.axprovider.dbm.gf.DoDebug.msg('IsSameGroupedIndexTaskExistsAndActive/ GroupWithPriorIndexNo : '+sGroupWithPriorIndex);
    sTaskName := GetSameGroupedIndexTaskNames(pCurProcessName,pTaskname,pTransid,sGroupWithPriorIndex);
    if sTaskName <> '' then
    begin
       CheckStatusXDS := structdef.axprovider.dbm.GetXDS(nil);
       CheckStatusXDS.buffered := true;
       CheckStatusXDS.CDS.CommandText :=
       'select TaskId from AxActiveTasks a where '+
       structdef.axprovider.dbm.gf.sqllower + '(ProcessName) = ' +(quotedstr(lowercase(pCurProcessName))) +' and '+
       //Transid filter may not be required, it may vary for tasks .Need to be removed if its not required.
       //same level tasks must have same trainsid also [not sure] - need to check
       //Commenting transid check since parallel tasks may have diff transids
       //structdef.axprovider.dbm.gf.sqllower+'(transid)='+QuotedStr(lowercase(pTransid))+ ' and '+
       structdef.axprovider.dbm.gf.sqllower + '(TaskName) in (' +(lowercase(sTaskName))+') and '+
       structdef.axprovider.dbm.gf.sqllower + '(Keyvalue) = ' +(lowercase(QuotedStr(sPEGGlobalKeyValue)))+' and '+
       ' not exists(select taskid from AxActiveTaskStatus b where a.taskid=b.taskid )';
       CheckStatusXDS.open;
       if CheckStatusXDS.CDS.RecordCount > 0 then //If same index record is pending with action
        Result := True;
    end
    else
      Exit;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in IsSameGroupedIndexTaskExistsAndActive '+E.Message);
    end;
  finally
    if Assigned(CheckStatusXDS) then
      FreeAndNil(CheckStatusXDS);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsSameGroupedIndexTaskExistsAndActive ends.');
end;


//DoAutoApprovalForOrphanTasksC
Procedure TAxPEG.DoAutoApprovalForOrphanTasks(pTransid,pTaskId,pProcessName,pTaskName,pKeyField,pKeyValue : String);
var
  AxPEGActions : TAxPEGActions;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('DoAutoApprovalForOrphanTasks starts...');
  try
    try
    	   AxPEGActions := nil;
         AxPEGActions := TAxPEGActions.Create;
         AxPEGActions.AxProvider := structdef.axprovider;
         AxPEGActions.Object_ASBDataObj := Object_ASBDataObj;
         //AxPEGActions.ASBDataObj := ASBDataObj;
         //AxPEGActions.dbm := {Axprovider}ASBDataObj.dbm;
         //Newly added to handle importdata
         AxPEGActions.dbm := structdef.axprovider.dbm; //for testing purpose | importdata
         AxPEGActions.TransType := pTransid;
         AxPEGActions.Init;

         AxPEGActions.DoAutoApprovalForOrphanTasks(pTransid,pTaskId,pProcessName,pTaskName,pKeyField,pKeyValue);
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in DoAutoApprovalForOrphanTasks '+E.Message);
    end;
  finally
    if Assigned(AxPEGActions) then
      FreeAndNil(AxPEGActions);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('DoAutoApprovalForOrphanTasks ends.');
end;

//PushSaveDataToQueue
Procedure TAxPEG.PushSaveDataToQueue(sQueueName,sAPIPayload: String);
var
  PublishToRMQ : TPublishToRMQ;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('PushSaveDataToQueue starts...');
  try
    PublishToRMQ := nil;
    try
      PublishToRMQ := TPublishToRMQ.create(structdef);
      PublishToRMQ.bIsPEGV2 := bIsPEGV2;
      PublishToRMQ.Parser := nil;//Parser;
      PublishToRMQ.SDEvaluateExpr := SDEvaluateExpr;
      if Assigned(SDEvaluateExpr) then
      begin
        //Variables return var name when its not found/empty it has to be handled.
        PublishToRMQ.sRMQ_APIURL := SDEvaluateExpr('AxRMQAPIURL');
        PublishToRMQ.sScripts_APIURL := SDEvaluateExpr('AxRapidSaveURL');
        PublishToRMQ.sNotifyQueueName := sQueueName;
      end;
      PublishToRMQ.jsonPayloadRequest := TJSONObject.ParseJSONValue(TEncoding.ASCII.GetBytes(sAPIPayload),
          0) as TJSONObject;
      PublishToRMQ.bScriptJobs := False;
      PublishToRMQ.PushMessageToRMQ(sAPIPayload,'0');
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in PushSaveDataToQueue : '+E.Message);
    end;
    end;
  finally
    if bAddPublishRMQObjtoList then
      PublishToRMQ := nil
    else
    begin
      if Assigned(PublishToRMQ) then
        FreeAndNil(PublishToRMQ);
    end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('PushSaveDataToQueue ends.');
end;


//

//IsPegActiveTaskExists
function TAxPEG.IsPegActiveTaskExists(sKeyField : String = ''): Boolean;
var
  CheckTaskXDS : TXDS;
  {sKeyField,}sKeyValue : String;
begin
  Result := False;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPegActiveTaskExists starts...');
  try
    if sKeyField = '' then
      sKeyField := GetKeyField;
    if sKeyField = '' then
    begin
       structdef.axprovider.dbm.gf.DoDebug.msg('Invalid KeyField.');
       Exit;
    end;
    sKeyValue := GetFieldValue(sKeyField,1);
    CheckTaskXDS := nil;
    try
       CheckTaskXDS := structdef.axprovider.dbm.GetXDS(nil);
       CheckTaskXDS.buffered := true;
       CheckTaskXDS.CDS.CommandText :=
        'SELECT a.taskid, a.taskname, a.processname, a.transid, a.keyfield, a.keyvalue ' +
        'FROM AxActiveTasks a ' +
        'LEFT JOIN AxActiveTaskStatus s ON a.taskid = s.taskid ' +
        '                               AND a.transid = s.transid ' +
        '                               AND a.keyfield = s.keyfield ' +
        '                               AND a.keyvalue = s.keyvalue ' +
        'WHERE a.transid = '+QuotedStr(TransType)+' ' +
        '  AND a.keyvalue = '+QuotedStr(sKeyValue)+' ' +
        '  AND s.taskstatus IS NULL';

      CheckTaskXDS.Open;
      Result := not CheckTaskXDS.CDS.IsEmpty;
    finally
      if Assigned(CheckTaskXDS) then
        FreeAndNil(CheckTaskXDS);
    end;
  Except on E:Exception do
  begin
    structdef.axprovider.dbm.gf.DoDebug.msg('Error in IsPegActiveTaskExists : '+E.Message);
  end;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('IsPegActiveTaskExists ends.');
end;


//DoAutoForwardForSameUser
Procedure TAxPEG.DoAutoForwardForSameUser(pTaskId : String);
var
  AxPEGActions : TAxPEGActions;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('DoAutoForwardForSameUser starts...');
  try
    try
         bIsPEGAttached := structdef.IsPegAttached;
    	   AxPEGActions := nil;
         AxPEGActions := TAxPEGActions.Create;
         AxPEGActions.AxProvider := structdef.axprovider;
         //if cur transid and next task transid are diff then it cause issue since dbcall stick with cur transid
         AxPEGActions.Object_ASBDataObj := nil;//Object_ASBDataObj;
         //AxPEGActions.ASBDataObj := ASBDataObj;
         //AxPEGActions.dbm := {Axprovider}ASBDataObj.dbm;
         //Newly added to handle importdata
         AxPEGActions.dbm := structdef.axprovider.dbm; //for testing purpose | importdata
         AxPEGActions.TransType := TransType;
         AxPEGActions.bIsAmendment := bIsAmendment;
         AxPEGActions.bIsPEGAttached := bIsPEGAttached;
         AxPEGActions.Init;

         AxPEGActions.DoAutoForwardForSameUser(pTaskId);
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in DoAutoForwardForSameUser '+E.Message);
    end;
  finally
    if Assigned(AxPEGActions) then
      FreeAndNil(AxPEGActions);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('DoAutoForwardForSameUser ends.');
end;


//CallPEGApproveUsingTaskId
Procedure TAxPEG.CallPEGApproveUsingTaskId(pTaskId : String);
var
  AxPEGActions : TAxPEGActions;
begin
  structdef.axprovider.dbm.gf.DoDebug.msg('CallPEGApproveUsingTaskId starts...');
  try
    try
         //AXPEGAction object creation need to be written as common funtion
         bIsPEGAttached := structdef.IsPegAttached;
    	   AxPEGActions := nil;
         AxPEGActions := TAxPEGActions.Create;
         AxPEGActions.AxProvider := structdef.axprovider;
         if bautoapproval then
         //Assigning it to nil to recreate ASBDataObj during auto approval for the curr transid
         //Diuring auto approval previous level and current level transid may differ.
          AxPEGActions.Object_ASBDataObj := nil
         else
          AxPEGActions.Object_ASBDataObj := Object_ASBDataObj;
         //AxPEGActions.ASBDataObj := ASBDataObj;
         //AxPEGActions.dbm := {Axprovider}ASBDataObj.dbm;
         //Newly added to handle importdata
         AxPEGActions.dbm := structdef.axprovider.dbm; //for testing purpose | importdata
         AxPEGActions.TransType := TransType;
         AxPEGActions.bIsAmendment := bIsAmendment;
         AxPEGActions.bIsPEGAttached := bIsPEGAttached;
         AxPEGActions.bautoapproval := bautoapproval;
         AxPEGActions.bIsPEGApprovalOnSave := bIsPEGApprovalOnSave;
         AxPEGActions.Init;

         AxPEGActions.CallPEGApproveUsingTaskId(pTaskId);
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in CallPEGApproveUsingTaskId '+E.Message);
    end;
  finally
    if Assigned(AxPEGActions) then
      FreeAndNil(AxPEGActions);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('CallPEGApproveUsingTaskId ends.');
end;

//Amendment

//GetNextProcessAmendmentTask
Procedure TAxPEG.GetNextProcessAmendmentTask;
var
  pegXDS : TXDS;
begin
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetNextProcessAmendmentTask starts...');
    try
      //Loop with process not needed for amendment ,since One transaction can have only
      //one Amendment process | It req it needs to be handled accordingly
      PegXDS := GetAxProcessDef(transtype); //Gets all AxProcessDef records for the amendment process
      if PegXDS.CDS.RecordCount > 0 then
      begin
        PegXDS.CDS.First;
        EVALProcessSet(pegXDS);
      end
      else
        structdef.axprovider.dbm.gf.DoDebug.msg('GetNextProcessAmendmentTask/Process not found for this transaction.');
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('\uAxPEG\GetNextProcessAmendmentTask - '+e.Message);
      structdef.axprovider.dbm.gf.DoDebug.Log(structdef.axprovider.dbm.gf.Axp_logstr+'\uAxPEG\GetNextProcessAmendmentTask - '+e.Message);
    end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('GetNextProcessAmendmentTask ends.');
  finally
    if Assigned(pegXDS) then
    begin
      FreeAndnil(pegXDS);
    end;
  end;
end;


//SaveAmend
Procedure TAxPEG.SaveAmend;
var
  AxAmend : TAxAmend;
begin
  AxAmend := nil;
  try
  structdef.axprovider.dbm.gf.DoDebug.msg('AxPEG/SaveAmend starts...');
    try
      //Create AxAmend object and Initialize
      AxAmend := TAxAmend.Create(structdef);
      if Assigned(AxAmend) then
      begin
        if Assigned(StoreDataObject) then
        begin
          bIsAmendment := True;
          bIsPEGAttached := structdef.IsPegAttached;
          AxAmend.StoreDataObject := StoreDataObject;
          AxAmend.ParserObject := ParserObject;
          AxAmend.Object_ASBDataObj := Object_ASBDataObj;
          AxAmend.delrowsnode := delrowsnode;
          AxAmend.SaveAmend;
          GetNextProcessAmendmentTask;
        end
        else
          structdef.axprovider.dbm.gf.DoDebug.msg('Storedata/SaveAmend/ StoreDataObject is not assigned.');
      end
      else
        structdef.axprovider.dbm.gf.DoDebug.msg('Storedata/SaveAmend/ AxAmend is not assigned.');
    Except on E:Exception do
    begin
      structdef.axprovider.dbm.gf.DoDebug.msg('Storedata/SaveAmend/ Error : '+E.Message);
      raise Exception.Create(E.Message);
    end;
    end;
  finally
    if Assigned(AxAmend) then
      FreeAndNil(AxAmend);
    bIsAmendment := False;
    bIsPEGAttached := False;
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('AxPEG/SaveAmend ends.');
end;



//GetProcessStatusForAmend
function TAxPEG.GetProcessStatusForAmend(pTransid,pKeyValue:string):string;
var dQry :TXds;
    s:String;
begin
  dQry := nil;
  Result := '';
  try
    structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessStatusForAmend starts...');
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := True;
      dQry.CDS.CommandText:='Select TaskName,TaskStatus,StatusReason,StatusText from AxActiveTaskStatus where Transid = :sTransid and KeyValue = :sKeyValue '
                            +' order by eventdatetime desc';
      dQry.AssignParam(0,pTransid,'c');
      dQry.AssignParam(1,pKeyValue,'c');
      dQry.Open;
      if not dQry.CDS.IsEmpty then
        Result :=dQry.CDS.FieldByName('TaskName').AsString +'##'+dQry.CDS.FieldByName('TaskStatus').AsString +'##'+dQry.CDS.FieldByName('StatusReason').AsString +'##'+dQry.CDS.FieldByName('StatusText').AsString
      else Result := '';
      dQry.Close;
    Except on E:Exception do
      structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetProcessStatusForAmend '+E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetProcessStatusForAmend ends.');
end;

// GetAmendmentConfirmation
Function TAxPEG.GetAmendmentConfirmation(pProcessName : String): String;
var
  dQry: TXDS;
begin
  result := '';
  structdef.axprovider.dbm.gf.DoDebug.msg('GetAmendmentConfirmation starts...');
  try
    try
      dQry := structdef.axprovider.dbm.GetXDS(nil);
      dQry.buffered := true;
      dQry.CDS.CommandText :=
              'select amendconfirmmsg from axpdef_peg_processmaster app '+
        ' where lower(caption) = '+ (quotedstr(LowerCase(pProcessName)))+
        ' and lower(amendment) = ''t'' and lower(amendconfirm) = ''t'' ';
      dQry.open;
      if not dQry.CDS.IsEmpty then
      begin
        result := dQry.CDS.FieldByName('amendconfirmmsg').AsString;
      end
      else
        result := '';
      dQry.close;
    Except
      on E: exception do
        structdef.axprovider.dbm.gf.DoDebug.msg('Error in GetAmendmentConfirmation ' + E.Message);
    end;
  finally
    if Assigned(dQry) then
      FreeAndNil(dQry);
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('GetAmendmentConfirmation ends.');
end;


(*
Read from AxTaskStatus table. If there is atleast one record for which there is a record in AxTaskStatusStatus table, then load in read only mode.
*)
Procedure TAxPEG.FetchAmendForLoadData;
var
  PegGetTasksXDS,PegGetAmendXDS : TXDS;
  sProcessName,sKeyField,sKeyValue,sAmendConfirmMsg ,sEnablePEGWithdraw: String;
  bEnableAmendActions,bGetLastStatusOfAmend : Boolean;
  //tmpTransid,tmpTaskid,tmpTaskname,tmpProcessname,tmpKeyfield,tmpKeyvalue : String;
  sAmendDataJson,tmpStatus,sToUsers,sLastStatus,AmendStatus,ApproverComments,sAmendRecordFieldList : String;
  sAmendInitiator,sLastActUser : String;

function SplitString({const} str, delimiter: string): TArray<string>;
var
  startPos, endPos, delimiterLength, strLength: Integer;
  subStr: string;
begin
  //Seems this function have issues , when last data is empty then it takes junk chars
  //To avoid add dummy delimiter at the end only for '~' delimited records
  //This is bieng used in  FetchAmendForLoadData only.
  // This can be modified using getnthstring | need to check later
  if delimiter = '~' then
  begin
    str := str+'~';
  end;

  delimiterLength := Length(delimiter);
  strLength := Length(str);
  startPos := 1;
  endPos := PosEx(delimiter, str, startPos);

  while endPos > 0 do
  begin
    subStr := Copy(str, startPos, endPos - startPos);
    SetLength(Result, Length(Result) + 1);
    Result[High(Result)] := subStr;
    startPos := endPos + delimiterLength;
    endPos := PosEx(delimiter, str, startPos);
  end;

  if startPos <= strLength then
  begin
    subStr := Copy(str, startPos, strLength - startPos + 1);
    SetLength(Result, Length(Result) + 1);
    Result[High(Result)] := subStr;
  end;
end;


  //the SplitString function uses a TStringList to split the string into an array of substrings.
  //The substrings are then assigned to the Result array.
  function ConvertDataStringToJson(const dataString: string): string;
  var
    rows: TArray<string>;
    rowdata: string;
    columns: TArray<string>;
    columnName, rowValue, oldValue, newValue: string;
    FieldCaption,ActualRowNo,DCName,DCCaption,DataMode : String;
    DeletedRows,DeletedDcs : String;
    json,columnObj: TJSONObject;
    axdeleterows: TJSONObject;

    rowPair,oldValuePair,newValuePair : TJSONPair;
    tmprowValue,pairIndex : Integer;

    pair: TJSONPair;
    pairName: string;
    pairExists,bIsValueChanged: Boolean;
  begin
    try
      structdef.axprovider.dbm.gf.DoDebug.msg('ConvertDataStringToJson starts...');
      // Create the main JSON object
      json := TJSONObject.Create;

      // Split the data string into rows
      //rows := SplitString(dataString, '$$');
      rows := SplitString(Trim(dataString), '$$');
      tmprowValue := -1;
      // Iterate through each row
      for rowdata in rows do
      begin
        // Split the row into columns
        //columns := SplitString(row, '~');
        structdef.axprovider.dbm.gf.DoDebug.msg('row : '+rowdata);
        // Clearing the array
        SetLength(columns, 0);
        columns := SplitString(Trim(rowdata), '~');
        //structdef.axprovider.dbm.gf.DoDebug.msg('columns : '+columns);
        // Check if the row has the required number of columns
        if Length(columns) >= 12 then
        begin
          // Extract the column values
          columnName := columns[0];
          structdef.axprovider.dbm.gf.DoDebug.msg('columnName : '+columnName);
          rowValue := columns[1];
          structdef.axprovider.dbm.gf.DoDebug.msg('rowValue : '+rowValue);
          oldValue := columns[4];
          structdef.axprovider.dbm.gf.DoDebug.msg('oldValue : '+oldValue);
          newValue := columns[5];
          structdef.axprovider.dbm.gf.DoDebug.msg('newValue : '+newValue);

          ActualRowNo := columns[2];//columns[7];
          structdef.axprovider.dbm.gf.DoDebug.msg('ActualRowNo : '+ActualRowNo);
          FieldCaption := columns[8];
          structdef.axprovider.dbm.gf.DoDebug.msg('FieldCaption : '+FieldCaption);
          DCName := columns[9];
          structdef.axprovider.dbm.gf.DoDebug.msg('DCName : '+DCName);
          DCCaption := columns[10];
          structdef.axprovider.dbm.gf.DoDebug.msg('DCCaption : '+DCCaption);
          DataMode := columns[11];
          structdef.axprovider.dbm.gf.DoDebug.msg('DataMode : '+DataMode);

          DeletedRows := Trim(columns[12]);
          structdef.axprovider.dbm.gf.DoDebug.msg('DeletedRows : '+DeletedRows);
          DeletedDcs := Trim(columns[13]);
          structdef.axprovider.dbm.gf.DoDebug.msg('DeletedDcs : '+DeletedDcs);

          //We can check this by comapring oldvalue and newvalue also
          bIsValueChanged := lowercase(columns[7]) = 't';
          if Not bIsValueChanged then //if no change then continue
            Continue;

          // Create a sub-JSON object for the column
          columnObj := TJSONObject.Create;

          // Create the JSON pairs for the column properties
          //rowPair := TJSONPair.Create('row', rowValue);  //new adjusted row no after delete and update
          rowPair := TJSONPair.Create('row', ActualRowNo); //Actual row number before deleting row
          oldValuePair := TJSONPair.Create('oldvalue', oldValue);
          newValuePair := TJSONPair.Create('newvalue', newValue);

          // Add the JSON pairs to the sub-JSON object
          columnObj.AddPair(rowPair);
          columnObj.AddPair(oldValuePair);
          columnObj.AddPair(newValuePair);

          columnObj.AddPair(TJSONPair.Create('fieldcaption', FieldCaption));
          columnObj.AddPair(TJSONPair.Create('dcname', DCName));
          columnObj.AddPair(TJSONPair.Create('dccaption', DCCaption));
          columnObj.AddPair(TJSONPair.Create('datamode', DataMode));

          //by Assigning ActualRowNo instead of rowvalue we can avoid duplicate row object creation
          //Client side also to be handle accordingly
          pairName := columnName+'_'+rowValue;
          // Check if a specific pair name exists
          //pairIndex := json.IndexOfName(columnName);

          //pairName := columnName;
          pairExists := False;
          // Iterate over the JSON object's pairs
          for pair in json do
          begin
            if pair.JsonString.Value = pairName then
            begin
              pairExists := True;
              Break;
            end;
          end;

          //if pairIndex <> -1 then
          if pairExists then
          begin
            // Add the sub-JSON object to the main JSON object
            if rowValue = '-1' then
            begin
              //tmprowValue := Dec(tmprowValue, 1); // Decrement tmprowValue by 1;
              tmprowValue := tmprowValue - 1; // Decrement tmprowValue by 1
              rowValue := InttoStr(tmprowValue);
            end;
            //Suffix rownum to avoid duplicate keys
            //For -1 (deleted rows) dec(rowvalue) and add
            //columnName := columnName+'_'+rowValue;
          end;
          columnName := columnName+'_'+rowValue;
          json.AddPair(columnName, columnObj);
        end;
      end;

      axdeleterows := TJSONObject.Create;
      axdeleterows.AddPair(TJSONPair.Create('deletedrno', DeletedRows));
      axdeleterows.AddPair(TJSONPair.Create('deleteddcno', DeletedDcs));

      json.AddPair('axdeleterows', axdeleterows);
      structdef.axprovider.dbm.gf.DoDebug.msg('JSON convertion completed.');
      Result := json.ToString;
      structdef.axprovider.dbm.gf.DoDebug.msg('ConvertDataStringToJson result : '+Result);
    finally
      json.Free;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('ConvertDataStringToJson ends.');
  end;


begin
  PegGetTasksXDS := nil;
  PegGetAmendXDS := nil;
  bEnableAmendActions := False;
  sAmendDataJson := '';
  AmendStatus := '';
  sAmendInitiator := '';
  sLastActUser := '';
  //If the transaction is peg attached transaction then continue or exit.
  structdef.axprovider.dbm.gf.DoDebug.msg('FetchAmendForLoadData starts...');
  try
  sKeyField := GetKeyField;
  if sKeyField = '' then
  begin
     structdef.axprovider.dbm.gf.DoDebug.msg('Invalid KeyField.');
     Exit;
  end;
  sKeyValue := GetFieldValue(sKeyField,1);

  bGetLastStatusOfAmend := False;
  PegGetTasksXDS := structdef.axprovider.dbm.GetXDS(nil);
  PegGetTasksXDS.close;
  PegGetTasksXDS.buffered := True;
  if (structdef.axprovider.dbm.Connection.DbType = 'oracle') then
      PegGetTasksXDS.cds.CommandText :=
         ' WITH FilteredTasks AS ( '+
         ' SELECT a.* '+
         ' FROM AxActiveTasks a '+
         ' INNER JOIN axpdef_peg_processmaster p ON LOWER(a.processname) = LOWER(p.caption) '+
         ' WHERE '+
          '  LOWER(a.transid) = '+QuotedStr(lowercase(transtype))+
          '  AND LOWER(a.KeyField) = '+QuotedStr(lowercase(sKeyField))+
          '  AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
          '  AND LOWER(a.tasktype) <> ''make'' '+
          '  AND NOT EXISTS ( '+
           '   SELECT 1 '+
            '  FROM AxActiveTaskStatus b '+
            '  WHERE a.taskid = b.taskid  '+
            ' ) '+
           ' AND LOWER(p.amendment) = ''t'' '+
        ' ) '+
        ' SELECT * '+
        ' FROM FilteredTasks '+
        ' ORDER BY eventdatetime, IndexNo DESC'
  else
      //Check ActiveTasksStatus table
      PegGetTasksXDS.cds.CommandText :=
        //Modified query with amendment check
        ' SELECT a.* FROM AxActiveTasks a '+
        ' INNER JOIN axpdef_peg_processmaster p '+
         ' ON LOWER(a.processname) = LOWER(p.caption) '+
        ' WHERE LOWER(a.transid) = '+QuotedStr(lowercase(transtype))+
        ' AND LOWER(a.KeyField) = '+QuotedStr(lowercase(sKeyField))+
        ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
        ' AND LOWER(a.tasktype) <> ''make'' '+
        ' AND NOT EXISTS ( '+
           ' SELECT taskid FROM AxActiveTaskStatus b '+
           ' WHERE a.taskid = b.taskid '+
           ' ORDER BY eventdatetime, IndexNo DESC '+
          ' ) '+
          ' AND lower(p.amendment) = ''t''';

  PegGetTasksXDS.open;

  if PegGetTasksXDS.CDS.IsEmpty then
  begin
    bGetLastStatusOfAmend := True;
    PegGetTasksXDS.close;
    PegGetTasksXDS.buffered := True;
    PegGetTasksXDS.cds.CommandText :=
   ' SELECT a.*, s.taskstatus, s.statustext, s.username, s.eventdatetime FROM AxActiveTasks a '+
   ' INNER JOIN axpdef_peg_processmaster p ON LOWER(a.processname) = LOWER(p.caption) '+
   ' INNER JOIN AxActiveTaskStatus s ON a.taskid = s.taskid '+
   ' WHERE LOWER(a.transid) = '+QuotedStr(lowercase(transtype))+
   ' AND LOWER(a.KeyField) = '+QuotedStr(lowercase(sKeyField))+
   ' AND LOWER(a.KeyValue) = '+QuotedStr(lowercase(sKeyValue))+
   //Commenting current user check condition with initiator, This will be checked below to control ReadOnlyTrans for users.
   //If Current user is Initiator
   //' AND (a.Initiator) = '+QuotedStr(structdef.axprovider.dbm.gf.username)+
   ' AND LOWER(a.tasktype) <> ''make'' '+
   ' and EXISTS ( '+
   ' SELECT taskid '+
   ' FROM AxActiveTaskStatus b '+
   ' WHERE a.taskid = b.taskid '+
   //' ORDER BY eventdatetime, IndexNo DESC '+
  ' ) '+
  ' AND LOWER(p.amendment) = ''t'' '+
  ' ORDER BY s.eventdatetime DESC ';
    PegGetTasksXDS.open;
  end;


  structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := False;
  if PegGetTasksXDS.CDS.RecordCount > 0 then
  begin
    PegGetTasksXDS.CDS.First;
    sAmendInitiator := PegGetTasksXDS.CDS.FieldByName('Initiator').AsString;
    //Set readonly trans for Amendment/if active amendment found
    // if not over all status then set readonly ,
    // if we fetch over all status then amendment is not pending with any user except initiator
    if Not bGetLastStatusOfAmend then //If Amend process is in active  then for all users enabld readonly trans
      structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := True
    else if bGetLastStatusOfAmend then//If amend process completed (Approved/Rejected)
    begin
      sLastActUser := PegGetTasksXDS.CDS.FieldByName('username').AsString;
      //As discussed with sabarish sir on 28072023, we are making amendment trans readonly only for approver
      //In withdraw case, Initiator and LastActUser will be same, To control bAxPegReadOnlyTrans during that time we added condition
      if (sLastActUser=structdef.axprovider.dbm.gf.username) and (sLastActUser <> sAmendInitiator) then //If current loggedin user is Approver level user(Who acted on final level) then readonly true
        structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := True
      else //If current user is not Approval level user(Who acted on final level) then readonly true
        structdef.axprovider.dbm.gf.bAxPegReadOnlyTrans := False;
    end;

    //Check amend
    PegGetAmendXDS := structdef.axprovider.dbm.GetXDS(nil);
    PegGetAmendXDS.close;
    PegGetAmendXDS.buffered := True;
    //Whoever having access to this transaction can see the amend data also
    //so the 2nd query filtering record based on username has been commented

    //if Not bGetLastStatusOfAmend then
    //even if one process is in make for that transation then the while transaction will become editable
      PegGetAmendXDS.cds.CommandText :=
                  ' select amendedby,amendedon,fieldlist from AxAmend '+
                  ' where primaryrecordid = '+FloattoStr(LastSavedRecordId)+
                  //Add username filter if req
                  ' order by amendedon desc';
    (*
    else
      PegGetAmendXDS.cds.CommandText :=
                  ' select amendedby,amendedon,fieldlist from AxAmend '+
                  ' where primaryrecordid = '+FloattoStr(LastSavedRecordId)+
                  ' and amendedby = '+QuotedStr(structdef.axprovider.dbm.gf.username)+
                  ' order by amendedon desc';
    *)
    structdef.axprovider.dbm.gf.DoDebug.msg('Query to get latest amend record :'+PegGetAmendXDS.cds.CommandText);

    PegGetAmendXDS.open;
    if PegGetAmendXDS.CDS.RecordCount > 0 then
    begin
       PegGetAmendXDS.cds.First;
       structdef.axprovider.dbm.gf.DoDebug.msg('Amend record current RecNo :'+InttoStr(PegGetAmendXDS.cds.RecNo));
       sLastStatus := '';
       sAmendConfirmMsg := '';
       sToUsers := '';
       bEnableAmendActions := false;
       sEnablePEGWithdraw := 'false';

       sProcessName := PegGetTasksXDS.CDS.FieldByName('Processname').AsString;

       if Not bGetLastStatusOfAmend then
          sAmendConfirmMsg := GetAmendmentConfirmation(sProcessName)
       else
       begin
          sLastStatus := lowercase(PegGetTasksXDS.CDS.FieldByName('taskstatus').AsString);
          ApproverComments := (PegGetTasksXDS.CDS.FieldByName('statustext').AsString);
       end;

       sAmendRecordFieldList := PegGetAmendXDS.CDS.FieldByName('fieldlist').AsString;
       structdef.axprovider.dbm.gf.DoDebug.msg('Amend record FieldList :'+sAmendRecordFieldList);
       sAmendDataJson := ConvertDataStringToJson(sAmendRecordFieldList); //data
       //sAmendDataJson := CreatePEGorAmendDataJSON(PegGetTasksXDS, sAmendDataJson);

       if Not bGetLastStatusOfAmend then
       begin
         sToUsers:= GetTaskPendingWithUsers(sProcessName,transtype,sKeyValue,sAmendDataJson);

         if (sToUsers <> '') and (UserExists(sToUsers,structdef.axprovider.dbm.gf.username)) then
         begin
          sToUsers := DeleteAndAddValue(sToUsers,structdef.axprovider.dbm.gf.username,'you');
          bEnableAmendActions := true;
         end
         else
          bEnableAmendActions := false;

         //If PEG initiator and Current user are same then enable withdraw button
         if (sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username) then
          sEnablePEGWithdraw := 'true'
         else
          sEnablePEGWithdraw := 'false';

       end
       else
        sAmendDataJson := CreatePEGorAmendDataJSON(PegGetTasksXDS, sAmendDataJson);

        //Prepare status message if task pending / inprogress (except with initiator)
       if Not bGetLastStatusOfAmend then
       begin
        AmendStatus := 'Amendments done by '+
         ifthen(sCurrentPEGInitiator = structdef.axprovider.dbm.gf.username,'you', PegGetAmendXDS.CDS.FieldByName('amendedby').AsString)
         //+' on '+PegGetAmendXDS.CDS.FieldByName('amendedon').AsString+' are awaiting approval.';
         +' on '+PegGetAmendXDS.CDS.FieldByName('amendedon').AsString;
        tmpStatus := AmendStatus+' are awaiting approval with '+sToUsers+'.';
       end
       else
       begin
        //if sLastStatus = 'Approved' then
        begin
          AmendStatus := 'Amendments done by '+
              ifthen(sAmendInitiator=structdef.axprovider.dbm.gf.username,'you',sAmendInitiator)+
              ' on '+PegGetAmendXDS.CDS.FieldByName('amendedon').AsString;
          tmpStatus := AmendStatus+
            ' is '+sLastStatus+' by '+
            ifthen(sLastActUser=structdef.axprovider.dbm.gf.username,'you',sLastActUser);
        end;
       end;

       tmpStatus := 'true'+'$##$'+ //For Amendment
          tmpStatus+'$##$'; //Amendment Status;
       if bEnableAmendActions then
        tmpStatus := tmpStatus+
          'true'//+ //Peg actions
       else
        tmpStatus := tmpStatus+
          'false';//+ //Peg actions

       tmpStatus:= tmpStatus+'$##$'+ sAmendDataJson;//Data
       //Withdraw
       tmpStatus:= tmpStatus+'$##$'+ sEnablePEGWithdraw;
       //Amendment confirmation message
       //Replace dynamic params
       sAmendConfirmMsg := FillDynamicParams(sAmendConfirmMsg);
       tmpStatus:= tmpStatus+'$##$'+sAmendConfirmMsg;// Amendment Confirmation message.
       //AmendStatus
       tmpStatus:= tmpStatus+'$##$'+AmendStatus;//AmendStatus for display purpose on pop div
       //Approver Comments if exists
       tmpStatus:= tmpStatus+'$##$'+ApproverComments; //ApproverComments
       structdef.axprovider.dbm.gf.sAxPegStatus := tmpStatus;
    end
    else
      structdef.axprovider.dbm.gf.DoDebug.msg('StoreData/FetchAmendForLoadData/ Amend data not found.');
  end;
  structdef.axprovider.dbm.gf.DoDebug.msg('FetchAmendForLoadData ends.');
  finally
    if Assigned(PegGetTasksXDS) then
    begin
      if PegGetTasksXDS.Active then
        PegGetTasksXDS.close;
      FreeAndNil(PegGetTasksXDS);
    end;
    if Assigned(PegGetAmendXDS) then
    begin
      if PegGetAmendXDS.Active then
        PegGetAmendXDS.close;
      FreeAndNil(PegGetAmendXDS);
    end;
  end;
end;

//PEG |  HasPegActiveTasks
(*
This function checks the AxActiveTasks and AxActiveTaskStatus tables to determine
if there are any active PEG tasks for the current user and the current form
with the given value for the existing transaction. It returns true if tasks are found, otherwise, it returns false.
*)
Function TAxPEG.HasPegActiveTasks: Boolean;
var
  PegGetTasksXDS: TXDS;
  sKeyField, sProcessName, sKeyValue: String;
begin
  PegGetTasksXDS := nil;
  result := False;
  // If the transaction is peg attached transaction then continue or exit.
  structdef.axprovider.dbm.gf.DoDebug.msg('HasPegActiveTasks starts...');
  try
    try
      sKeyField := GetKeyField;
      if sKeyField = '' then
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('Invalid KeyField.');
        exit;
      end;
      sKeyValue := GetFieldValue(sKeyField, 1);
      sProcessName := GetProcessName(transtype, sKeyField, sKeyValue);
      PegGetTasksXDS := structdef.axprovider.dbm.GetXDS(nil);
      PegGetTasksXDS.close;
      PegGetTasksXDS.buffered := True;
      PegGetTasksXDS.CDS.CommandText := ' SELECT * FROM axactivetasks ' +
        ' WHERE lower(transid) = ' + quotedstr(lowercase(transtype)) +
        ' AND keyvalue = ' + quotedstr(sKeyValue) + ' AND lower(processname) = '
        + quotedstr(lowercase(sProcessName)) +
        ' AND lower(tasktype) = ''make'' ' + ' AND ' +
        quotedstr(structdef.axprovider.dbm.gf.UserName) + ' in (touser) ' +
        ' AND NOT EXISTS ( ' + ' SELECT 1 ' + ' FROM axactivetaskstatus a ' +
        ' WHERE a.taskid = axactivetasks.taskid ' + ')';

      PegGetTasksXDS.open;
      // if not empty then activetasks found (return true).
      // touser will be having user only when it's returned.
      if Not PegGetTasksXDS.CDS.IsEmpty then
        result := True
      else
      begin
        //if no return record found then check for withdraw record
        PegGetTasksXDS.close;
        PegGetTasksXDS.buffered := True;
        PegGetTasksXDS.CDS.CommandText :=
          'SELECT a.taskid,a.processname,a.keyvalue,s.taskstatus,s.eventdatetime '+
          ' FROM axactivetasks a JOIN axactivetaskstatus s '+
          ' ON a.taskid = s.taskid AND a.processname = s.processname '+
          ' AND a.keyvalue = s.keyvalue '+
          ' AND lower(s.taskstatus) = ''withdrawn'' WHERE '+
          ' lower(a.processname) = '+ quotedstr(lowercase(sProcessName)) +
          ' AND a.keyvalue = '+ quotedstr(sKeyValue) +
          ' ORDER BY s.eventdatetime DESC ';//LIMIT 1 ';

        PegGetTasksXDS.open;
        // if not empty then activetasks found (withdrawn true).
        //Checking for withdrawn record (latest record)
        if Not PegGetTasksXDS.CDS.IsEmpty then
           result := True;
      end;

    Except
      on E: Exception do
      begin
        structdef.axprovider.dbm.gf.DoDebug.msg('Error in HasPegActiveTasks : '
          + E.Message);
      end;
    end;
    structdef.axprovider.dbm.gf.DoDebug.msg('HasPegActiveTasks ends.');
  finally
    if Assigned(PegGetTasksXDS) then
    begin
      if PegGetTasksXDS.Active then
        PegGetTasksXDS.close;
      FreeAndNil(PegGetTasksXDS);
    end;
  end;
end;

//PEG VERSION 2.0 Ends here

// PEG functionality ends here //




end.
