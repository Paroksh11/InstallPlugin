unit uAxProvider;
{Copied from Axpert9-XE3\Ver 11.1}

interface
uses
  Windows, Messages, SysUtils, Variants, Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms,
  Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls, Vcl.ComCtrls, DateUtils, Vcl.Menus, XMLDoc, XMLIntf,DB,
  uDbManager, uGeneralFunctions, Grids, uXDS, udodebug,Types,uPropsXML,uCompress,
  MessageDigest_5,uLicMgr;

type

  headList=^TheadList;
  TheadList=record
    hnode : ixmlnode;
  end;

  TAxProvider=class
  private
    x, q , forcds,xTransCheck: TXDS;
    xnode : IXMLNode;
    CreatedOn, CreatedBy, ImportedOn, ImportedBy,prev_pwds  :String;
    function CreateAccessControlXML(cxml: ixmldocument): ixmldocument;
    procedure CreateMsgsTable(grpno: Integer);
    function GetParentNode(mNode: ixmlnode; pName: String): ixmlnode;
    procedure GetPageOrderXMLForAccCtrl(mNode: ixmlnode; sRole: String);
    procedure LoadListViewButtons(enode: ixmlnode; lvname: String);
    procedure AddBtns(tnode, dnode: ixmlnode);
    function NodeExists(enode: ixmlnode; sname, stype: String): Boolean;
    procedure LoadViewControl(cnode, enode: ixmlnode; vcFor: String);
    procedure LoadTransControl(cnode, enode: ixmlnode);
    function GetOperator(s: String): String;
    procedure updateaxuserlevelgroups(ug: ixmlnode ; uname : String);
    function findcountno: integer;
    procedure SavetoUserAccess(pagename : String);
    procedure RemoveUserAccess(fPageName: String);
//    procedure updatePageOrder(n: ixmlnode);
    procedure Deletemenuoption(name: String);
    procedure Addmenuoption(parent, posn, cap, url: String);
    procedure movemenu(ename: String; toorderno: integer);
    function GetParents(pgs : TStringList): String;
    function GetPrintTemplate(sname, pname, fname: String): String;
    function DeleteRole(rName: String): String;
    function ChangeSqlForUMPagination(orgSql: String): String;

//    function GetJoinStr(Fname, DType: String; Width, Dec: integer): String;
    procedure RemoteAddConstraint(TableName, Constraints: String);
    function RemoteEditField(TableName, FName, DType: String; FWidth, FDec: Integer): String;
    procedure RemoteDropConstraint(TableName, Constraints: String);
    procedure RemoteSetPrintTemplate(name, sname,printdoctype,filename,nm :String );
    function RemoteSetStructure(sname, name, caption,uname: String;xml: IXMLDocument) : String ;
    function GetProdCode(s: String): integer;
    function IsStructExists(sname, wcond: String): Boolean;
    procedure GetAxFastList(stransid,Formats: String;result: IXMLDocument);
    function LoadXMLDataFromWS(xml: WideString): IXMLDocument;
    function checkfor_prev_pwds(pwd, uname: string): boolean;
    function isOldCorrect(pwd, uname: string): Boolean;
    function ExtractFRname(Formname: string): string;
    function MakeFRCSVInQoutedStr(CommaSepVal: String): String;
    function CheckProduct(name: string; pxml: IXMLDocument): IXMLDocument;
    function GetHTMLOrdNo(tDBM: TDbManager): String;

  public
    dbm : TDbManager;
    GetStructName, GetStructCaption:String;
    GetPageName, GetPageCaption, GetPageImg, GetPageVisible,savedimages:String;
    GetPageOrdNo : Integer;
    bImportPrintDoc : Boolean;
    ErrorStr: String;
    lm : TLicMgr ;

    function GetPageOrderXML: IXMLDocument;
    function GetModuleWiseTStruct(head: String): IXMLDocument;
    constructor create(pdbm:TDbManager); virtual;
    destructor destroy; override;
    function GetStructure(sname, name, caption,purpose:String):IXMLDocument;overload;
    function GetStructure(sname, name, caption,purpose,uname:String):IXMLDocument; overload;
    function ExecSQL(SQLText, ParamValues, ParamTypes: String;
      WithData: Boolean): IXMLDocument;
    function GetBOMXML: IXMLDocument;
    function GetAllStructures(sname: String): IXMLDocument;
    function LoadImage(sname, fname , dtype, fldval  : String; recid: Extended): String;
    procedure RemoteSetPrefix(transid, fldname, prefix: String);
    function CheckStructureAccess(sname,name: String): ixmldocument;
    procedure SetStructure(sname, name, caption:String; xml:IXMLDocument; UpdSrcDate:Boolean=False); overload;
    procedure SetStructure(sname, name, caption , uname : String; xml:IXMLDocument; UpdSrcDate:Boolean=False); overload;
    procedure SetStructure(sname, name, caption, uname, transid: String;xml: IXMLDocument; UpdSrcDate: Boolean =False);overload;
    procedure SetStructure(sname, name, caption, uname, transid,purpose: String; xml: IXMLDocument;  UpdSrcDate:Boolean=false); Overload;


    function ViewAttachments(sessionid, sname, recordid,
      filename: String): String;
    function GetPDFs(stransid: String): IXMLDocument;
    function ViewAttachment(sname, recordid, filename: String): String;
    function TableFound(Tablename: String): Boolean;
    function GetPrintForms(sname: String): IXMLDocument;
//    function GetAttachmentList(sname, wrecid: String): IXMLDocument;
    procedure SetMailVars(n : ixmlnode)  ;
    procedure GetAttachments(transid:String;enode:ixmlnode;recid:Extended) ; overload;
    function  GetAttachments(sname,wrecid:String): IXMLDocument;overload;
    function SaveImage(sname , imgName: String; recid: Extended) : boolean; overload;
    function MenuHeadInfo(appname,mname,level : String): IXMLDocument;
    function RemoveAttachments(sname, recordid,filename: String): String;
    function MultiLevelMenuXML(headname,headlevel : String): IXMLDocument;
    function GetMultiLevelMenuInfo(head,level : String): IXMLDocument;
    function GetDetails: IXMLDocument;
    function GetUserGroupDetails(UserGrp: String): IXMLDocument;
    function GetUserDetails(sUser: String): IXMLDocument;
    function RemoveRole(rName: String): String;
    function RemoveUserGroup(gName: String): String;
    function RemoveUser(uName: String): String;
    function AddUserGroup(gName, sRoles,roletype,actflag: String): String;
    function UpdateUserGroup(gName, sRoles,roletype,actflag: String): String;
    function AddUser(uName: String; enode: ixmlnode): String;
    function UpdateUser(uName: String; enode: ixmlnode): String;
    procedure LoadItems(mNode: ixmlnode; sName, sRole: String);
    procedure LoadAccess(mNode: ixmlnode; sRole: String);
    function AddRoles(enode: ixmlnode): String;
    procedure LoadTstructDetails(enode: ixmlnode; transid: String);
    function RoleExists(rName: String): Boolean;
    procedure LoadAccControl(enode: ixmlnode; sName,sRole,sType: String;
      lview: Boolean);
    procedure LoadIviewDetails(enode: ixmlnode; ivname: String);
    function AddViewControlDetails(enode, vnode: ixmlnode): String;
    function AddTransControlDetails(enode, vnode: ixmlnode;transid:String): String;
    function AddListViewControlDetails(enode, vnode: ixmlnode): String;
    function SaveAccessDetails(pxml: ixmldocument; rName, sName,
      sType: String): String;
    procedure CreateField(TableName, FName, DType: String; FWidth, FDec: Integer);
    procedure CreateTable(TableName, FName: String);
    procedure DropTable(TableName: String);
    procedure AlterMenu(xml: ixmlnode);
    function MultiLevelFilterMenuXML: IXMLDocument;
    procedure Deletefields(TableName, FieldName: String);
    function GetAllWorkFlowTStructs: IXMLDocument;
    function CheckForPDF(stransid: String): boolean;
    function SetAppProps(enode: ixmlnode): String;
    function GetAppProps: IXMLDocument;
    function GetObject(sname, fname, where: String): String;
    function RemoteReadMemo(fname, table, where: String): String;
    procedure DownLoadFile(filename, tempfile: String);
    function RemoteServerDateTime() : String;
    procedure RemoteSaveWorkflow(name, caption: String; WXML: ixmldocument);
    function GetAttachmentAsStr(transid: String; recid: Extended): String;
    function GetResponsibilityList(resp,active, page,struct : String): IXMLDocument;
    function GetRolesList(roles, active, resp, page, struct: String): IXMLDocument;
    function GetUsersList(user , roles, active, resp, page, struct: String): IXMLDocument;
    function checkLicence: String;
    function MessageSent(fromwhom, towhom, msgstring: String): String;
    function GetAllMessages(loc,fs : String) : IXMLDocument;
    function MessageDelete(msgid: String): String;
    function GetMessage(msgid :String ):IXMLDocument;
    function GetPage(name, caption, purpose: String): IXMLDocument;
    function MessageSetReadStatus(msgid: String): String;
    function FieldFound(FldName, TblName: String): Boolean;
    function GetUserProfile: IXMLDocument;
    function SaveUserProfile(profilefile: String): String;

    procedure AddConstraint(TableName, Constraints: String);
    function GetJoinStr(Fname, DType: String; Width, Dec: integer;ToModify:Boolean=False): string;
    function EditField(TableName, FName, DType: String; FWidth, FDec: Integer):String;
    procedure DropConstraint(TableName, Constraints: String);
    procedure SetPrintTemplate(name, sname,printdoctype: String; PropsXML: IXMLDocument);
    procedure SaveImage(foldername,filename,tblname: String;recid:Extended);overload;
    procedure GetFontCDS(sname: String; fcds: TXDS);
    procedure SaveImage(sFolderName, sFileName, tFolderName, tFileName: String); overload;
    function SetAttachments(sname, recordid, filename: String): String;
    function FindPrintSourceFormat(strans,formname:String;OnlyPDF:Boolean):String;  // to find fast report template in axpertreports table
    procedure DeleteStructure(tName,cvName, transid: String);overload;
    procedure DeleteStructure(sname, name, caption, transid: String);overload;
    procedure DeleteStructure(tName, cvName: String);overload;
    procedure CopyFiles(sFolder, tFolder: String);
    procedure InitLicManager;
    function GetStructure(sname, name, caption, purpose, uname,
      transid: string): IXMLDocument;overload;
     function GetConstraintName(Tablenm: String): String;
     function ChangePassword(uname: string; enode: ixmlnode;FirstTime:String='F') : string;
    function CheckExistanceInTransControl(recid,
      transid: string): boolean;
    procedure DeleteTransControl;overload;
    procedure DeleteTransControl(recid,transid : string;suser:string='');overload;
    procedure InsertIntoTransControl(transid: String; recid: extended);
    function GetPrintDocs(stransid: String): IXMLDocument;
    function GetFastReportFileExt(stransid, Rname: String): String;
    function ExtractFilenameWithoutExtension(FRfileName: String): String;
    procedure InsertIntoTransCheck;
    procedure DeleteFromTransCheck;
    function ValidateTransCheck: Boolean;
    function GetStructureForScript(sname, name, caption,
      purpose: String): IXMLDocument;
    function GetDataFromAppDB(orgXDS : TXDS;TargetConnectionName:AnsiString='') : TXDS;
//    function GetOneRecord(SQLText, ParamValues, ParamTypes: String): IXMLDocument;
    function GetOneRecord(SQLText, ParamValues, ParamTypes: String; UniqueVal : String = ''): IXMLDocument;
    procedure CopyTableDataBetweenDBSchema(sTargetDBSchemaConnectionName,sSourceTable,sWhereCond : String;sTargetTable:String='');
    procedure UpdateAxpagesTableforHTMLPage(pHTMLPageNo,pHTMLPagecaption,transid:String;pIsNewPage : Boolean;targetDBM : TDBManager= nil);
    procedure ExecuteSQL(pSQLQuery : String;targetDBM : TDBManager= nil);
    function GetDBM(pTargetDBSchemaConnectionName: String): TDBManager;
    procedure CopyFlatTableDataBetweenDBSchema(sSourceTable : AnsiString ; sTargetDBSchemaConnectionName : AnsiString = '');
    function MenuXMLForArrangeMenu(headname, headlevel: String): IXMLDocument;
    procedure AlterDEFAULTConstraint(sTableName, sColumnName, sDataType: String;
      iWidth, iDec: integer; bToModify : Boolean = False; bIsNullable:Boolean=True;
      sDefaultValue: String = '');
    procedure AlterNOTNULLConstraint(sTableName, sColumnName, sDataType: String;
      iWidth, iDec: integer; bToModify : Boolean = False; bIsNullable: Boolean = True);
    procedure CopyFlatTableDataFromDefToApp(sSourceTable: AnsiString ;sTargetDBSchemaConnectionName : AnsiString = ''; sWhereCond : AnsiString = '');
    procedure CopyFlatTableDataBetweenSchema(sSourceTable,sPrimaryField : AnsiString;bDeleteIfExists : Boolean = True; sTargetDBSchemaConnectionName : AnsiString = '');
    function CheckAxProcessDef(transtype : string;PEGVersion:String='') : TXDS;
    function IsAmendmentEnabled(transtype: string): TXDS; //Amendment

  end;


implementation

{ TAxProvider }

constructor TAxProvider.create(pdbm: TDbManager);
begin
  inherited create;
  dbm := pdbm;
  x:=dbm.GetXDS(nil);
  q:=dbm.GetXDS(nil);
  forcds := dbm.GetXDS(nil);
  xTransCheck := dbm.GetXDS(nil);
  bImportPrintDoc := false;
  savedimages := '';
  lm := nil;
end;

destructor TAxProvider.destroy;
begin
  x.destroy;
  q.close;
  q.destroy;
  forcds.close;
  forcds.destroy;
  xTransCheck.Close;
  xTransCheck.Destroy;
  xTransCheck := nil;
  if assigned(lm) then FreeAndNil(lm);
  inherited;
end;

Procedure TAxProvider.InitLicManager;
begin
   lm := TLicMgr.Create(dbm);
   lm.init;
end;

function TAxProvider.GetStructure(sname, name, caption , purpose: String): IXMLDocument;
var s,w,p:String;
  stm,cstm : TStringStream;
  sfile,tfile : String;
begin
  result:=LoadXMLData('<root></root>');
  p := '';
  if name='' then
  begin
     w := 'caption= :name ';
     p := caption ;
  end else
  begin
     w := dbm.gf.sqllower+'(name)= :name ';
     p := lowercase(name);
  end;
    s :='';
    stm := TStringStream.Create(s);
    dbm.ReadMemo('props', sname, w, p,'c', stm);
    if stm.Size=0 then result:=LoadXMLData('<root/>')
    else begin
        if sname='tstructs' then
        begin
          cstm := TStringStream.Create('');
          stm.Position := 0;
          with TCompress.Create do begin
            cstm := DecompressStream(stm);
            destroy;
          end;
          cstm.Position := 0;
          result := LoadXMLDataFromWS(trim(cstm.DataString)) ;
          cstm.Free;
          result := CheckProduct(name,result);
        end
        else result:=LoadXMLDataFromWS(trim(stm.DataString));
    end;
    dbm.gf.DoDebug.Msg('Step5');
    stm.Free;

    if sname = 'printprops' then
    begin
       s := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       if GetStructName = '' then
         GetPrintTemplate('printprops',name,s)
       else
         GetPrintTemplate('printprops',GetStructName,s);
    end;
end;


function TAxProvider.CheckProduct(name : string ; pxml :  IXMLDocument) : IXMLDocument;
  var i,pid : integer;
begin
  result := pxml;
  exit;
  if dbm.gf.evalcopy then exit;
  if dbm.gf.dbmflag = 'axpman' then exit;
  if assigned(lm) then
  begin
    if pxml.DocumentElement.HasAttribute('pid') then
    begin
       pid := strtoint(vartostr(pxml.DocumentElement.Attributes['pid']));
       i := 0;
       i := GetProdCode(name);
       i := pid - i;
       if (i <> 0) and (i <> 100) and (i <> lm.licProdCode) then
       begin
         raise exception.Create('Product not compatible with licensed version...');
       end;
       pxml.DocumentElement.Attributes['pid'] := '';
    end;
  end else pxml.DocumentElement.Attributes['pid'] := '';
  result := pxml;
end;

function TAxProvider.GetProdCode(s:string) : integer;
  var i,k,j: integer;
begin
  k := 0;
  s := lowercase(s);
  for i := 1 to length(s) do
  begin
     j := ord(s[i]);
     k := k + (j + i*100);
  end;
  result := k;
end;

function TAxProvider.LoadXMLDataFromWS(xml : WideString) : IXMLDocument;
begin
   result := LoadXMLData(xml);
end;

function TAxProvider.GetStructure(sname, name, caption, purpose, uname: String): IXMLDocument;
  var s,w,p:String;
  stm : TStringStream;
begin
  result:=LoadXMLData('<root></root>');
  if name='' then
  begin
     w := 'caption= :name and username= :uname';
     p := caption
  end else
  begin
     w := dbm.gf.sqllower+'(name)= :name and username= :uname' ;
     p := lowercase(name) +','+uname;
  end;
  {
  if name='' then w:=sqllower+'(caption)='+lowercase(quotedstr(caption)) + 'and username='+quotedstr(uname)
  else w:=sqllower+'(name)='+lowercase(quotedstr(name)) + 'and username='+quotedstr(uname) ;
  }
  x.sqltext:='select * from '+sname+' where '+w;
  x.parambyname('name').AsString := lowercase(name);
  x.parambyname('uname').AsString := uname;
  x.open;
  if x.isempty then
  begin
     x.close;
     {
     if name='' then w:=sqllower+'(caption)='+lowercase(quotedstr(caption)) + 'and username='+quotedstr('all')
     else w:=sqllower+'(name)='+lowercase(quotedstr(name)) + 'and username='+quotedstr('all') ;
     }
     p := lowercase(name) +','+'all';
     x.sqltext:='select * from '+sname+' where '+w;
     x.parambyname('name').AsString := lowercase(name);
     x.parambyname('uname').AsString := 'all';
     x.open;
  end;
  if not x.isempty then begin
    s :='';
    stm := TStringStream.Create(s);
    dbm.ReadMemo('props', sname, w,p,'cc', stm);
    if stm.Size=0 then result:=LoadXMLData('<root/>')
    else result:=Loadxmldata(trim(stm.DataString));
    stm.Free;
    if sname = 'axpages' then
    begin
      GetPageName:='';
      GetPageCaption:='';
      GetPageImg:='';
      GetPageVisible:='';
      GetPageOrdNo := 0;
      GetPageName:=x.fieldbyname('name').asstring;
      GetPageCaption:=x.fieldbyname('caption').asstring;
      result.DocumentElement.Attributes['name']:=GetPageName;
      result.DocumentElement.Attributes['caption']:=GetPageCaption;
      result.DocumentElement.Attributes['orderno']:=GetPageOrdNo;
    end
    else begin
      GetStructName:=x.fieldbyname('name').asstring;
      GetStructCaption:='';
      if assigned(x.findfield('caption')) then GetStructCaption:=x.fieldbyname('caption').asstring;
      result.DocumentElement.Attributes['name'] := GetStructName;
      result.DocumentElement.Attributes['caption'] := GetStructCaption;
    end;
  end else result:=LoadXMLData('<root/>');
  x.close;
end;
{
function TAxProvider.GetOneRecord(SQLText, ParamValues, ParamTypes:String):IXMLDocument;
var i:integer;
    s:String;
    n:ixmlnode;
    dt : TFieldType;
begin
  result:=loadxmldata('<root></root>');
  q.sqltext:=sqltext;
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    q.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;
  if lowercase(copy(sqltext,1,7)) <> 'select ' then
    q.execsql
  else begin
    q.open;
    xnode:=result.DocumentElement;
    while not q.eof do begin
      n:=xnode.AddChild('row');
      for i:=0 to q.Fields.Count-1 do
        n.AddChild(q.fields[i].FieldName).NodeValue:=q.Fields[i].AsString;
      q.next;
    end;
  end;
end;
}
function TAxProvider.EditField(TableName, FName, DType: String; FWidth, FDec: Integer): String;
var JoinStr : String;
    flag : Boolean;
begin
  if dbm.gf.RemoteLogin then
  begin
    Result := RemoteEditField(TableName,FName,DType,FWidth,FDec);
    if (Trim(lowercase(result)) = 'field edited successfully') then
      result := '';
    exit;
  end;
  result := '';
  JoinStr := GetJoinStr(FName,DType,FWidth,FDec,True);
  Try
    ErrorStr :='';
    flag := dbm.InTransaction;
    if (not flag)  then  dbm.StartTransaction(dbm.gf.connectionname);
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQLtext := 'Alter table ['+ UpperCase(TableName) + '] modify ' + JoinStr
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] alter column ' + JoinStr
    else if dbm.Connection.DbType = 'postgre' then
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' alter column ' + JoinStr
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' modify ' + JoinStr;
    q.ExecSQL;
    if (not flag) then dbm.Commit(dbm.gf.connectionname);
  Except on e:Exception do
    ErrorStr := e.Message;
  End;
  if ErrorStr<>'' then begin
    if (not flag) then dbm.RollBack(dbm.gf.connectionname);
    result := 'Column['+fname+'] to be modified must be empty to change datatype or to decrease width or decimal.';
  end
  else
     result := 'Not able to modify field '''+JoinStr+''''
 { Except on e:Exception do begin
      if dbm.InTransaction then dbm.RollBack(dbm.gf.connectionname);
      if e.Message = '' then
        result := 'Not able to modify field '''+JoinStr+''''
      else
        result := 'Column['+fname+'] to be modified must be empty to change datatype or to decrease width or decimal.';
    end;
  End; }
end;

function TAxProvider.ExecSQL(SQLText, ParamValues, ParamTypes:String; WithData:Boolean):IXMLDocument;
var i,done:integer;
    s:String;
    n:ixmlnode;
    dt : TFieldType;
begin
  result:=loadxmldata('<root></root>');
  q.sqltext:=sqltext;
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    q.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;
  done := 0;
  while (done < 100) do begin
    try
      if lowercase(copy(sqltext,1,7)) <> 'select ' then
        q.execsql
      else begin
        if (q.Connection.DbType = 'ms sql') and (pos('into', lowercase(q.SqlText)) > 0) then
          q.execsql
        else begin
          q.open;
          xnode:=result.DocumentElement;
          xnode:=xnode.AddChild('schema');
          for i:=0 to q.Fields.Count-1 do begin
            n:=xnode.AddChild(q.fields[i].FieldName);
            dt := q.Fields[i].DataType;
            case dt of
              ftBCD,ftSmallint,ftInteger,ftFloat,ftCurrency,ftLargeint : n.Attributes['type'] := 'n';
              ftDate,ftTime, ftDateTime,ftTimeStamp : n.Attributes['type'] := 'd';
              else n.Attributes['type'] := 'c';
            end;
          end;
          if withdata then begin
            xnode:=result.DocumentElement;
            xnode:=xnode.AddChild('data');
            while not q.eof do begin
              n:=xnode.AddChild('row');
              for i:=0 to q.Fields.Count-1 do
                n.AddChild(q.fields[i].FieldName).NodeValue:=q.Fields[i].AsString;
              q.next;
            end;
          end;
        end;
      end;
      break;
    except on e:Exception do
      begin
        dbm.gf.DoDebug.Msg('SQL Error - '+e.Message);
        inc(done);
        if done = 99 then raise Exception.Create(e.Message);
      end;
    end;
  end;
end;

function TAxProvider.GetBOMXML : IXMLDocument;
var  fn,w : String;
     ts : TStringList;
Begin
  {
  result := LoadXMLData('<root></root>');
//  x.SQL.Clear;
  x.SQLText := 'select * from axprops where ' + sqllower +'(name)='+lowercase(quotedstr('bom'));
  x.open;
  if not x.isempty then begin
    w := sqllower + '(name)='+lowercase(quotedstr('bom'));
    fn := startpath+'temp\bom.xml';
    dbm.ReadMemo('props','axprops',w,fn);
    ts := TStringlist.Create;
    ts.LoadFromFile(fn);
    result := LoadXmlData(ts.Text);
  end;
  }
End;

function TAxProvider.GetAllStructures(sname:String): IXMLDocument;
  var stype : String;
begin
  if sname = 'axpages' then
  begin
     result := GetPageOrderXML;
     exit;
  end ;
  {
  x.sqlText:='select name,caption from '+sname+' where blobno=1 order by caption';
  x.open;
  result:=LoadXMLData('<root></root>');
  while not x.eof do begin
     result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
     x.next;
  end;
  x.close;
  }
  if sname = 'tstructs' then
      stype := 't'
   else if sname = 'iviews' then
      stype := 'i'
   else if sname = 'lviews' then
      stype := 'l'
   else stype := 'p';
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption from '+sname+' where blobno=1 order by ' + dbm.gf.sqllower + '(caption)'
  else  begin
    if lowercase(sname)<>'prints' then
      x.sqltext:='select name,caption from '+sname+' where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
    else  begin
      if lowercase(dbm.Connection.DbName) = 'ms sql' then
        x.sqltext:='select name,caption from '+sname+' where blobno=1 and substring(sname,2,6) in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
      else
        x.sqltext:='select name,caption from '+sname+' where blobno=1 and substr(sname,2,6) in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)';
    end;
  end;
  x.open;
  result:=LoadXMLData('<root></root>');
  while not x.eof do begin
     result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
     x.next;
  end;
  x.close;
//select name,caption from tstructs where name in (select sname from axpagedetail where name in (select name from axpages where visible = 'T'))

end;

function TAxProvider.GetPageOrderXML() : IXMLDocument;
  var n : IXMLNode;
  s : String;
begin
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno=1 order by levelno , ordno'
  else
  begin
    s := '';
    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by levelno , ordno';
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
    end;
    x.close;
    delete(s,length(s),2);
    if s = '' then raise exception.Create('User Roles not defined for this user');
    s := 'select name,caption,type,visible,img,parent from axpages where blobno=1 and name in ( ' + s + ' ) order by levelno , ordno';
    x.sqltext:= s;
  end;
  s := '';
  x.open;
  {
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    n := result.DocumentElement.AddChild(s);
    if x.fieldbyname('type').AsString  = 'h' then
       n.Attributes['group'] := 'true'
    else
       n.Attributes['group'] := 'false';
    n.Attributes['img'] :=  x.fieldbyname('img').asstring;
    n.Attributes['visible'] := x.fieldbyname('visible').asstring;
    n.Attributes['parent']  := x.fieldbyname('parent').asstring;
    n.NodeValue := x.fieldbyname('caption').asstring;
    x.next;
  end;
  }
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    n := result.DocumentElement.AddChild(s);
    if x.fieldbyname('type').AsString  = 'h' then
       n.Attributes['group'] := 'true'
    else if x.fieldbyname('type').AsString  = 's' then
       n.Attributes['group'] := 'pop'
    else if x.fieldbyname('type').AsString  = 'c' then
       n.Attributes['group'] := 'child'
    else
       n.Attributes['group'] := 'false';
    n.Attributes['img'] :=  x.fieldbyname('img').asstring;
    n.Attributes['visible'] := x.fieldbyname('visible').asstring;
    n.Attributes['parent']  := x.fieldbyname('parent').asstring;
    n.NodeValue := x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
end;

function TAxProvider.LoadImage(sname , fname , dtype , fldval : String;recid:Extended) : String;
var w : String;
    forcds : TXDS;
    GetImgExtn , s , filename: String;
    k : integer;
begin
  result := '';
  if pos('\',sname) > 0 then
     sname := dbm.gf.FindAndReplace(sname,'\','');
  forcds:=dbm.GetXDS(nil);
  forcds.buffered := True ;
  if dtype = 'i' then
  begin
    w:='recordid='+floattostr(recid);
    forcds.CDS.CommandText:='select ftype from '+sname+' where '+w;
    forcds.open;
    if not forcds.CDS.isempty then
    begin
        if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
//        if not DirectoryExists(dbm.gf.StartPath+ '\' + fname) then CreateDir(dbm.gf.StartPath+ '\' + fname);
        GetImgExtn := forcds.CDS.fieldbyname('ftype').AsString;
        s := dbm.gf.StartPath + '\' + fname + '.' + GetImgExtn;
        w:='recordid='+floattostr(recid);
        dbm.ReadBlob('img',sname , w , s);
        result := fname + '.' + GetImgExtn;
    end;
  end else
  begin
      filename := fldval + ',';
      k := 1;
      fldval := dbm.gf.GetNthString(filename,k);
      while fldval <> '' do
      begin
        w :='recordid = ' +Floattostr(recid) + ' and filename='+quotedstr(fldval);
        if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
        s := dbm.gf.StartPath + '\' + fldval;
        dbm.ReadBlob('img',sname , w , s);
        inc(k);
        fldval := dbm.gf.GetNthString(filename,k);
      end;
      result := fldval;
  end;
  forcds.close;
  FreeAndNil(forcds);
end;

function TAxProvider.CheckStructureAccess(sname,name : String) : ixmldocument;
   var i,j : integer;
   optname,s,w,r,rt,stype,p : String;
   n,n1,n2 : ixmlnode;
   accxml : ixmldocument;
   stm : TStringStream;
   Qxds : TXDS;
begin
   if dbm.gf.inuserroles = '' then
   begin
      i := 1;
      s := dbm.gf.userroles + ',' ;
      r := dbm.gf.getnthstring(s,i);
      dbm.gf.inuserroles := '';
      while r<>'' do
      begin
         dbm.gf.inuserroles := dbm.gf.inuserroles + quotedstr(r) + ',';
         inc(i);
         r := dbm.gf.getnthstring(s,i);
      end;
      i := length(dbm.gf.inuserroles);
      r := copy(dbm.gf.inuserroles,i,1);
      if r = ',' then delete(dbm.gf.inuserroles,i,1);
   end;
   Qxds := nil;
   if sname = 'tstructs' then
      stype := 't'
   else if sname = 'iviews' then
      stype := 'i'
   else if sname = 'lviews' then
      stype := 'l'
   else stype := 'p';
   x.sqltext:='select name from ' + sname + ' where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and ' + dbm.gf.sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr(stype) +' )';
   x.open;
   if x.isempty then
   begin
      x.close;
      result := nil;
      exit;
   end;
   Qxds := dbm.GetXDS(nil);
   Qxds.buffered := true;
   result := loadxmldata('<root></root>');
   i := 1;
   r := dbm.gf.getnthstring(dbm.gf.userroles,i);
   while r<>'' do
   begin
     {
     if stype = 't' then
        w:=sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('t')
     else if stype = 'i' then
        w:=sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('i')
     else if stype = 'l' then
        w:=sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('l')
     else
        w:=sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('p')  ;
     }
     p := lowercase(r)+ ',';
     p := p + lowercase(name) + ',';
     if stype = 't' then
        p := p + 't'
     else if stype = 'i' then
        p := p + 'i'
     else if stype = 'l' then
        p := p +  'l'
     else
        p := p +  'p'  ;
     if stype = 't' then
     begin
       w:=dbm.gf.sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + dbm.gf.sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('t');
       Qxds.close;
       Qxds.CDS.CommandText := 'select Props from axuseraccess where '+w;
       Qxds.Open;
       if (Qxds.CDS.RecordCount <= 0) then begin
          inc(i);
          r := dbm.gf.getnthstring(dbm.gf.userroles,i);
          continue;
       end ;
     end else if stype = 'i' then
     begin
       w:=dbm.gf.sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + dbm.gf.sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('i');
       Qxds.close;
       Qxds.CDS.CommandText := 'select Props from axuseraccess where '+w;
       Qxds.Open;
       if (Qxds.CDS.RecordCount <= 0) then begin
          inc(i);
          r := dbm.gf.getnthstring(dbm.gf.userroles,i);
          continue;
       end ;
     end else if stype = 'l' then
     begin
       w:=dbm.gf.sqllower+'(rname)='+lowercase(quotedstr(r)) + ' and ' + dbm.gf.sqllower + '(sname)=' + lowercase(quotedstr(name)) + ' and stype = ' + quotedstr('l');
       Qxds.close;
       Qxds.CDS.CommandText := 'select Props from axuseraccess where '+w;
       Qxds.Open;
       if (Qxds.CDS.RecordCount <= 0) then begin
          inc(i);
          r := dbm.gf.getnthstring(dbm.gf.userroles,i);
          continue;
       end ;
     end;
     w:=dbm.gf.sqllower+'(rname)= :rname and ' + dbm.gf.sqllower + '(sname)= :sname and stype = :stype' ;
     rt := 't'+inttostr(i);
     s := '';
     stm := TStringStream.Create(s);
     dbm.ReadMemo('props', 'axuseraccess' , w , p,'ccc' , stm);
     dbm.gf.DoDebug.msg('Reading data from stream');
     dbm.gf.DoDebug.msg(trim(stm.DataString));
     if (trim(stm.DataString) = '') or (trim(stm.DataString) = '<root></root>') then
     begin
       accxml:=nil;
       stm.Free;
       stm := nil;
       inc(i);
       r := dbm.gf.getnthstring(dbm.gf.userroles,i);
       continue;
     end
     else accxml:=Loadxmldata(trim(stm.DataString));
     stm.Free;
     stm := nil;
     if (accxml <> nil) then
     begin
       dbm.gf.DoDebug.msg('Result XML :' + Result.DocumentElement.XML);
       if result.DocumentElement.ChildNodes.Count = 0 then
       begin
         dbm.gf.DoDebug.msg('accxml :' + accxml.DocumentElement.XML);
         n := result.DocumentElement.AddChild(rt);
         n.ChildNodes.Add(accxml.DocumentElement.CloneNode(True));
       end else
       begin
        if (stype = 'i') or (stype = 'l') then begin
          n := result.DocumentElement.AddChild(rt);
          n.ChildNodes.Add(accxml.DocumentElement.CloneNode(True));
        end else begin
          n:= result.DocumentElement.ChildNodes[0];
          n:= n.ChildNodes[0];
          n1 := accxml.DocumentElement;
          if vartostr(n1.Attributes['r']) = 'n' then n.Attributes['r'] := 'n';
          if n.ChildNodes.Count > 0 then
          begin
            n := n.ChildNodes[0];
            if n <> nil then
            begin
              n := n.ChildNodes[0];
              if n <> nil then
              begin
                if (n1.ChildNodes.Count > 0) then
                begin
                n1 := n1.ChildNodes[0];
                  if n1 <> nil then
                  begin
                    for j := n.ChildNodes.Count - 1 downto 0 do
                    begin
          //            dbm.gf.DoDebug.msg('Node name :' + n.ChildNodes[j].NodeName);
                       n2 := n1.ChildNodes.FindNode(n.ChildNodes[j].NodeName);
                       if n2 = nil then n.ChildNodes.Delete(j)
                       else begin
                          if vartostr(n2.Attributes['a']) = 'd' then n.ChildNodes[j].Attributes['a'] := 'd';
                       end;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
       end;
     end;
     inc(i);
     r := dbm.gf.getnthstring(dbm.gf.userroles,i);
   end;
   if (stype = 'i') or (stype = 'l') then
   begin
      result :=  CreateAccessControlXML(result) ;
   end;
   FreeAndNil(Qxds);
   dbm.gf.DoDebug.msg('CheckStructureAccess completed2');
end;

function TAxProvider.CreateAccessControlXML(cxml : ixmldocument) : ixmldocument ;
var i,j:integer;
    s : String ;
    n,n1,n2 : ixmlnode;
begin
  result := loadxmldata('<root></root>');
  if assigned(cxml) and (cxml.DocumentElement.ChildNodes.Count > 0) then
  begin
     for i := 0 to cxml.DocumentElement.ChildNodes.Count - 1 do
     begin
        n :=  cxml.DocumentElement.ChildNodes[i].ChildNodes[0];
        if i = 0 then
        begin
           for j := 0 to n.ChildNodes.Count - 1 do
              result.DocumentElement.ChildNodes.Add(n.ChildNodes[j]);
        end else
        begin
           for j := 0 to n.ChildNodes.Count - 1 do
           begin
             n1 := n.ChildNodes[j].ChildNodes[0];
             s := vartostr(n1.NodeName);
             n2 := result.DocumentElement.ChildNodes[0];
             if n2 <> nil then n2 := n2.ChildNodes.FindNode(s);
             if n2 = nil then result.DocumentElement.ChildNodes[0].ChildNodes.Add(n1)
             else begin
                if vartostr(n1.Attributes['a']) = 'h' then
                   n2.Attributes['a'] := 'h';
             end;
           end;
        end;
     end;
  end;
end;

function TAxProvider.SetAttachments(sname,recordid,filename :String ):String;
var
  w ,recid,fn,fn1,fpath :String;
  i : integer;
begin
  try
    ErrorStr :='';
    i := 1;
    sname := sname+'attach';
    while true do
    begin
      fn:=dbm.gf.getnthstring(filename,i);
      if fn='' then break;
      x.close;
      fn1 := fn;
      fn := dbm.gf.StartPath + '\' + fn;
      if not FileExists(fn)  then
      begin
        result := '<error> File :'+fn+' does not exists.</error>';
        exit;
      end;
      recid := trim(Recordid+'$'+fn1);
      w:='recid ='+ Quotedstr(recid);
      x.Submit('recordid', recordid, 'c');
      x.Submit('recid', recid, 'c');
      x.Submit('filename',fn1,'c');
      x.AddOrEdit(sname, w);
      dbm.WriteBlob('template', sname, w, trim(fn));
      inc(i);
    end;
    result := 'done';
  except on E : Exception do
    ErrorStr := E.Message;
  end;
  if Errorstr <> '' then begin
     x.close;
     result :=  Errorstr;
  end;
end;

function TAxProvider.ViewAttachments(sessionid,sname,recordid,filename :String ):String;
var
  w ,recid,fn :String;
begin
  try
    Errorstr :='';
    dbm.gf.DoDebug.Msg('View attachments start');
    dbm.gf.DoDebug.Msg('file = ' + filename + ' sname = ' + sname + ' recordid = ' + recordid);
    if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
    fn := dbm.gf.StartPath +'\' + filename;
    w:='Recordid='+QuotedStr(recordid)+' and '+dbm.gf.sqllower+'(filename)='+QuotedStr(lowercase(filename));
    if pos('_image',sname) = 0 then
    begin
      sname := sname+'attach';
      dbm.ReadBlob('template', sname, w, trim(fn));
    end else dbm.ReadBlob('img' ,sname, w, trim(fn));
    result := filename;
    dbm.gf.DoDebug.Msg('File stored at ' + fn);
    except on E : Exception do
     Errorstr := E.Message;
    end;
    if Errorstr <>'' then begin
      dbm.gf.DoDebug.Msg('Error in view attachments : '+Errorstr);
      result := Errorstr;
    end;
end;

function TAxProvider.RemoveAttachments(sname,recordid,filename :String ):String;
var
  w ,recid,fn :String;
  i : integer;
begin
  try
    i := 1;
    sname := sname+'attach';
    while true do
    begin
      fn:=dbm.gf.getnthstring(filename,i);
      if fn='' then break;
      x.close;
    //  recid := trim(Recordid+'$'+fn);
    //  w:='recid ='+ Quotedstr(recid);
      w:='Recordid='+QuotedStr(recordid)+' and '+dbm.gf.sqllower+'(filename)='+QuotedStr(lowercase(filename));
      x.sqltext:='delete from '+sname+' where '+w;
      x.execsql;
      inc(i);
    end;
    result := 'done';
  except on E : Exception do
     begin
       x.close;
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.GetPDFs(stransid:String): IXMLDocument;
var
  xnode,vnode: IXMLNode;
  Formats:string;
begin
  result:=LoadXMLData('<root></root>');
  stransid := lowercase(stransid);
  result.DocumentElement.AddChild('transid').NodeValue:=stransid;
  x.sqltext:='select distinct caption,name from pdfprops where '+dbm.gf.sqllower+'(transid) = ' + quotedstr(stransid) + 'order by caption';
  x.open;
  while not x.eof do begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(x.fieldbyname('name').AsString) ;
    if xnode = nil then
    begin
       vnode:=  result.DocumentElement;
       vnode.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
       vnode:=vnode.ChildNodes.FindNode(x.fieldbyname('name').AsString);
       vnode.Attributes['source']:='pdf';
     //  result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    end;
    x.next;
  end;
  x.close;
  if dbm.gf.IsService then begin
    Formats:='''pdf''';
    GetAxFastList(stransid,Formats,result);
  end;
end;
procedure TAxProvider.GetAxFastList(stransid,Formats:String;result:IXMLDocument);
var
  x1:TXDS;
  vnode: IXMLNode;
  caption,Extn,Sqlstr:string;
begin
  x1:=dbm.GetXDS(nil);
  x1.buffered:=true;
  if Lowercase(dbm.Connection.Driver)='dbx' then begin
    if formats='''pdf''' then begin
      Sqlstr :='Select distinct caption,output from axfastlink where '
                + dbm.gf.sqllower+ '(transid) = ' + Lowercase(Quotedstr(stransid)) + ' and '
                +'('+dbm.gf.sqllower+ '(output) in (' + Lowercase(Formats) + ')' + ' Or '
                + ' output is null) Order by caption ';
    end
    else begin
      Sqlstr :='Select distinct caption,output from axfastlink where '
                + dbm.gf.sqllower+ '(transid) = ' + Lowercase(Quotedstr(stransid)) + ' and '
                + dbm.gf.sqllower+ '(output) in (' + Lowercase(Formats) + ')' + ' Order by caption ';
    end;
  end
  else if Lowercase(dbm.Connection.Driver)='ado' then begin
    if formats='''pdf''' then begin
      Sqlstr :='Select distinct caption,output from axfastlink where '
                + dbm.gf.sqllower+ '(transid) = ' + Lowercase(Quotedstr(stransid)) + ' and '
                +'('+dbm.gf.sqllower+ '(output) in (' + Lowercase(Formats) + ')' + ' Or '
                + ' output = '''') Order by caption ';
    end
    else begin
       Sqlstr :='Select distinct caption,output from axfastlink where '
                + dbm.gf.sqllower+ '(transid) = ' + Lowercase(Quotedstr(stransid)) + ' and '
                + dbm.gf.sqllower+ '(output) in (' + Lowercase(Formats) + ')' + ' Order by caption ';
    end;
  end;
  x1.CDS.CommandText:=Sqlstr;
  x1.open;
  while not x1.CDS.Eof do begin
    caption:=x1.CDS.FieldByName('caption').AsString;
    Extn:=Trim(Lowercase(x1.CDS.FieldByName('output').AsString));
    if Extn='msword' then Extn:='doc'
    else if Extn='' then Extn:='pdf';
    Caption:= Caption + '.' + Extn;
    vnode:= result.DocumentElement;
    vnode.AddChild(Caption).NodeValue:=Caption;
    vnode:=vnode.ChildNodes.FindNode(Caption);
    vnode.Attributes['source']:='fastreport';
//    result.DocumentElement.AddChild(x1.CDS.FieldByName('caption').AsString).NodeValue:=x1.CDS.FieldByName('caption').AsString;
    x1.CDS.Next;
  end;
  x1.close;
  freeandnil(x1);
end;

function TAxProvider.CheckForPDF(stransid:String): boolean;
var
  xnode : IXMLNode;
begin
  result:=false;
  stransid := lowercase(stransid);
  x.sqltext:='select distinct caption,name from pdfprops where '+dbm.gf.sqllower+'(transid) = ' + quotedstr(stransid) + 'order by caption';
  x.open;
  if not x.isempty then result := true;
  x.close;
end;

function TAxProvider.ViewAttachment(sname,recordid,filename:String) : String;
var  w,tdate,fdate,fn : String;
  recid : String;
begin
  if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
  recid := Recordid + '-'+lowercase(filename);
  fn := dbm.gf.StartPath +'\'+filename;
  w:='recid='+QuotedStr(recid);
  dbm.ReadBlob('template',sname,w,fn);
  result := fn;
end;

Function TAxProvider.TableFound(Tablename :String) :Boolean;
begin
    Result :=False;
    q.Close;
    if dbm.Connection.DbType = 'access' then
      q.sqltext := 'Select * from [' + UpperCase(Tablename) +'] where 1=2 '
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Select * from [' + UpperCase(Tablename) +'] where 1=2 '
    else
       q.sqltext := 'Select * from ' + UpperCase(Tablename)+' where 1=2 ';
    Try
      q.Active := True;
      Result := True;
    Except

    end;
end;

function TAxProvider.GetPrintForms(sname:String): IXMLDocument;
  var i : integer;
begin
  result:=LoadXMLData('<root></root>');
  sname := lowercase(sname);
  x.close;
  x.sqltext:='select distinct caption,name,printdoctype from prints where '+dbm.gf.sqllower+'(sname) = ' + quotedstr(sname) +' and blobno=1 '+ 'order by caption';
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
end;

function TAxProvider.GetAttachments(sname,wrecid:String): IXMLDocument;
  var i : integer;
begin
  result:=nil;
  if tableFound(sname+'Attach') then
  begin
    result:=LoadXMLData('<root></root>');
    sname := lowercase(sname);
    x.close;
    x.sqltext:= 'select filename from '+sname+'Attach where blobno=1 and recordid='+wrecid;
    x.open;
    i := 0;
    while not x.eof do begin
      result.DocumentElement.AddChild('a'+inttostr(i)).NodeValue:=x.fieldbyname('filename').asstring;
      inc(i);
      x.next;
    end;
    x.close;
  end;
end;

procedure TAxProvider.GetAttachments(transid:String;enode:ixmlnode;recid:Extended);
var tblname : String;
    n : ixmlnode;
begin
  dbm.gf.DoDebug.msg('# 1#Executing GetAttachments');
  tblname := transid+'attach';
  x.SqlText := 'select distinct filename as fn from '+tblname+' where recordid = '+floattostr(recid);
  x.open;
  if not (x.isempty) then begin
    n := enode.AddChild('Attachments');
    while (not x.eof) do
    begin
      n.AddChild('a').NodeValue := (x.fieldbyname('fn').AsString);
      x.next;
    end;
  end;
  x.close;
end;

function TAxProvider.GetAttachmentAsStr(transid:String; recid:Extended) : String;
var tblname : String;
begin
  result := '';
  if recid = 0 then exit;
  dbm.gf.DoDebug.msg('# 1#Executing GetAttachments');
  tblname := transid+'attach';
  x.SqlText := 'select distinct filename as fn from '+tblname+' where recordid = '+floattostr(recid);
  x.open;
  if not (x.isempty) then begin
    while (not x.eof) do
    begin
//      n.AddChild('a').NodeValue := (x.fieldbyname('fn').AsString);
      result := result + x.fieldbyname('fn').AsString + ',';
      x.next;
    end;
  end;
  if result <> '' then delete(result,length(result),1);
  x.close;
end;

procedure TAxProvider.SetMailVars(n : ixmlnode) ;
  var xml : ixmldocument;
  tnode : ixmlnode;
begin
  xml:= GetStructure('axprops', 'app', '','');
  dbm.gf.DoDebug.Msg('xml : ' + xml.DocumentElement.XML);
  dbm.gf.GlobalProps:=xml.DocumentElement.Childnodes[0];
  tnode := dbm.gf.globalprops.ChildNodes.FindNode('mail');
  if assigned(tnode) then begin
    dbm.gf.MailHost := vartostr(tnode.ChildValues['host']);
    dbm.gf.MailPort := vartostr(tnode.ChildValues['port']);
    if (dbm.gf.MailUserId = '') and (dbm.gf.MailPassword = '') then
    begin
      dbm.gf.MailUserId := vartostr(tnode.ChildValues['userid']);
      dbm.gf.MailPassword := vartostr(tnode.ChildValues['password']);
    end;
  end;
  dbm.gf.DoDebug.msg('Reading mail parameters');
  tnode := n.ChildNodes.FindNode('mailfrom');
  if assigned(tnode) then
     dbm.gf.mailfrom := vartostr(tnode.NodeValue)
  else begin
     x.sqltext := 'select email from axusers where username = :u';
     if dbm.gf.ServiceName = 'Login' then
        x.parambyname('u').AsString := 'admin'
     else x.parambyname('u').AsString := dbm.gf.username;
     x.open;
     dbm.gf.MailFrom := x.fieldbyname('email').AsString;
     x.close;
  end;
  if dbm.gf.MailFrom = '' then dbm.gf.MailFrom := dbm.gf.MailUserId;
  dbm.gf.DoDebug.msg('Mail from ' + dbm.gf.mailfrom);
  xml := nil ; tnode := nil;
end;

procedure TAxProvider.SetPrintTemplate(name, sname, printdoctype: String;
  PropsXML: IXMLDocument);
var
  w, s:String;
  x1  : Txds;
  docfilename : String;
  nm,fn : String;
  p : Integer;
begin
//  nm := lowercase(findandreplace(name,' ','_'))+lowercase(findandreplace(sname,' ','_'))+lowercase(printdoctype);
  nm := name;
  if bImportPrintDoc then
  begin
    fn := PropsXML.DocumentElement.Attributes['filename'];
    docfilename := fn;
    fn := ExtractFileName(fn);
    p := pos('$',fn);
    if p=0 then exit;
    fn := copy(fn,p+1,length(fn)-(p+4));
    PropsXML.DocumentElement.Attributes['filename']:=fn;
    setStructure('printprops',nm,name,PropsXML);
    if dbm.gf.RemoteLogin then begin
      RemoteSetPrintTemplate(nm, sname,printdoctype,docfilename,nm);
      exit;
    end;
  end
  else
  begin
    setStructure('printprops',nm,name,PropsXML);
    docfilename := dbm.gf.startpath+'docs\'+ ExtractFileName(PropsXML.DocumentElement.Attributes['filename']);
    if dbm.gf.RemoteLogin then begin
      RemoteSetPrintTemplate(nm, sname,printdoctype,docfilename,nm);
      exit;
    end;
  end;
  w:=dbm.gf.sqllower+'(name)='+ Quotedstr(lowercase(nm));
  x1 := dbm.GetXDS(nil);
  x1.sqltext := 'delete from prints where ' + w;
  x1.execsql;
  x1.Submit('name', nm, 'c');
  x1.Submit('caption',name,'c');
  x1.Submit('sname',sname,'c');
  x1.Submit('printdoctype',uppercase(printdoctype),'c');
  x1.Submit('blobno','1','n');
  x1.AddOrEdit('Prints', w);
  dbm.WriteBlob('template', 'Prints', w, docfilename);
  x1.free;
end;

procedure TAxProvider.RemoteSetPrintTemplate(name, sname,printdoctype,filename,nm :String );
begin

end;


function TAxProvider.RemoteSetStructure(sname, name, caption, uname: String;
  xml: IXMLDocument): String;
begin

end;

function TAxProvider.SaveImage(sname , imgName: String; recid: Extended) : boolean;
  var w,s,ftype:String;
      i : integer;
begin
  result := false;
  ftype := '';
  try
    s := dbm.gf.StartPath + '\' + imgName;
    dbm.gf.DoDebug.Msg('Image File Name :' + s);
    if pos('.',s) > 0 then
    begin
      ftype := s;
      i := 0;
      while True do
      begin
        i := pos('.',ftype);
        if i = 0 then break;
        delete(ftype,1,i);
      end;
    end;
    w:='recordid='+floattostr(recid);
    q.close;
    q.sqltext:='delete from '+sname+' where '+w;
    q.execsql;
    x.Submit('recordid', floattostr(recid), 'n');
    x.Submit('blobno', '1', 'n');
    x.Submit('ftype', ftype, 'c');
    x.AddOrEdit(sname, w);
    x.Post;
    dbm.WriteBlob('img', sname, w, s,true);
    if savedimages = '' then deletefile(s)
    else savedimages := savedimages + s + ',';
  except on e : exception do
    begin
       dbm.gf.DoDebug.Msg(e.Message);
       exit;
    end;
  end;
  result := true;
end;

function TAxProvider.MenuHeadInfo(appname,mname,level : String) : IXMLDocument;
  var n,pn,n1 : IXMLNode;
  s,s1,tname : String;
  i,call : integer;
begin
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
//    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno = 1 and type = ' + quotedstr('h')+ ' or type = ' + quotedstr('s') + ' or parent is null or parent = ' + quotedstr('') + ' order by levelno, ordno '
    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno=1 order by levelno , ordno'
  else
  begin
    s := '';
//    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno = 1 and type = ' + quotedstr('h')+ ' or type = ' + quotedstr('s') + ' or parent is null or parent = ' + quotedstr('') + ' and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ inuserroles +') and stype = ' + quotedstr('p') +' ) order by levelno , ordno';
    x.sqltext:='select name,caption,type,visible,img,parent from axpages where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by levelno , ordno';
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
    end;
    x.close;
    delete(s,length(s),2);
    if s = '' then raise exception.Create('User Roles not defined for this user');
//    s := 'select name,caption,type,visible,img,parent from axpages where blobno = 1 and type = ' + quotedstr('h')+ ' or type = ' + quotedstr('s') + ' or parent is null or parent = ' + quotedstr('') +  'and name in ( ' + s + ' ) order by levelno , ordno';
    s := 'select name,caption,type,visible,img,parent from axpages where blobno=1 and name in ( ' + s + ' ) order by levelno , ordno';
    x.sqltext:= s;
  end;
  s := '';
  x.open;
  s1 := GetCurrentDir + '\Axpert\'+appname ;
  s1 := s1 + '\home.html';
  if FileExists(s1) then
     s1 := 'home.html'
  else
     s1 := '';
  while not x.eof do begin
    if (x.fieldbyname('parent').asstring = '') and ((x.fieldbyname('type').AsString  = 'h') or (x.fieldbyname('type').AsString  = 'p')) then
    begin
      s := x.fieldbyname('name').AsString ;
      n := result.DocumentElement.AddChild(s);
      if x.fieldbyname('type').AsString  = 'h' then
         n.Attributes['group'] := 'true'
      else if x.fieldbyname('type').AsString  = 's' then
         n.Attributes['group'] := 'pop'
      else if x.fieldbyname('type').AsString  = 'c' then
         n.Attributes['group'] := 'child'
      else
         n.Attributes['group'] := 'false';
      n.Attributes['img'] :=  x.fieldbyname('img').asstring;
      n.Attributes['visible'] := x.fieldbyname('visible').asstring;
      n.Attributes['parent']  := x.fieldbyname('parent').asstring;
      n.Attributes['call']  := '1';
      n.Attributes['wname']  := s1;
      n.NodeValue := x.fieldbyname('caption').asstring;
    end;
    x.next;
  end;
  call := 1;
  for i := 0 to result.DocumentElement.ChildNodes.Count - 1 do
  begin
     n := result.DocumentElement.ChildNodes[i];
     s := n.NodeName;
     call := 3;
     x.first;
     while not x.eof do
     begin
        if s = x.fieldbyname('parent').asstring then
        begin
          call := 3;
          if x.fieldbyname('type').AsString = 's' then
          begin
            call := 2;
            break;
          end;
        end;
        x.next;
        if call = 2 then break;
     end;
     n.Attributes['call']  := inttostr(call);
  end;
  if mname <> '' then
  begin
     pn := result.DocumentElement;
     if level = '2' then
     begin
        n := pn.AddChild('slevel');
        x.first;
        tname := '';
        while not x.eof do begin
          if (x.fieldbyname('caption').AsString  = mname) or (pos(x.fieldbyname('parent').asstring,tname)>0) then
          begin
            s := x.fieldbyname('name').AsString ;
            tname := tname + s + ',';
            n1 := n.AddChild(s);
            if x.fieldbyname('type').AsString  = 'h' then
               n1.Attributes['group'] := 'true'
            else if x.fieldbyname('type').AsString  = 's' then
               n1.Attributes['group'] := 'pop'
            else if x.fieldbyname('type').AsString  = 'c' then
               n1.Attributes['group'] := 'child'
            else
               n1.Attributes['group'] := 'false';
            n1.Attributes['img'] :=  x.fieldbyname('img').asstring;
            n1.Attributes['visible'] := x.fieldbyname('visible').asstring;
            n1.Attributes['parent']  := x.fieldbyname('parent').asstring;
            n1.Attributes['wname']  := s1;
            n1.NodeValue := x.fieldbyname('caption').asstring;
          end;
          x.next;
        end;
     end else if level = '3' then
     begin
        n := pn.AddChild('tlevel');
        tname := '';
        dbm.gf.DoDebug.msg('Level ' + level);
        x.first;
        while not x.eof do begin
          if (x.fieldbyname('caption').AsString  = mname) then tname := tname +  x.fieldbyname('name').AsString + ',';
          if pos(x.fieldbyname('parent').asstring,tname) > 0 then
          begin
            s := x.fieldbyname('name').AsString ;
            n1 := n.AddChild(s);
            if x.fieldbyname('type').AsString  = 'h' then
               n1.Attributes['group'] := 'true'
            else if x.fieldbyname('type').AsString  = 's' then
               n1.Attributes['group'] := 'pop'
            else if x.fieldbyname('type').AsString  = 'c' then
               n1.Attributes['group'] := 'child'
            else
               n1.Attributes['group'] := 'false';
            n1.Attributes['img'] :=  x.fieldbyname('img').asstring;
            n1.Attributes['visible'] := x.fieldbyname('visible').asstring;
            n1.Attributes['parent']  := x.fieldbyname('parent').asstring;
            n1.Attributes['call']  := '';
            n1.Attributes['wname']  := '';
            n1.NodeValue := x.fieldbyname('caption').asstring;
          end;
          x.next;
        end;
     end;
  end;
  x.close;
end;

function TAxProvider.MultiLevelMenuXML(headname,headlevel : String) : IXMLDocument;
  var pnode,cnode,iconNode,icNode : IXMLNode;
  s , p , c , t,pp,ptype,pagenames : String;
  i , j, k,l,level,hidelevel,icdelm: integer;
  hlist : TList;
  hdlist : HeadList;
  added : boolean;
  Errorstr :String;
  intview, img, icon : String;
  iHiddenMainLevel, ExprListCount : Integer;
  SqlTxt,OrgSqlTxt,OrdTxt,AddSql : string;
begin
  if headlevel <> '' then
  begin
    result := GetMultiLevelMenuInfo(headname,headlevel) ;
    exit;
  end;
  SqlTxt := '';
  ExprListCount := 1;
  result:=LoadXMLData('<root></root>');
  if dbm.gf.Applanguage = '' then
  begin
    if pos('default',dbm.gf.userroles) > 0 then
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem''  order by ordno ,levelno '
    else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      try
        Errorstr :='';
        x.open;
      except on e:Exception do
        Errorstr :=e.Message;
      end;
      if Errorstr<>'' then begin
        if not FieldFound('webenable','axpages') then begin
          CreateField('axpages','webenable','c',1,0);
          x.open;
        end;
      end;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      AddSql := 'select b.name,b.caption,b.type,b.visible,b.img,b.parent,b.ordno,b.levelno,b.props,b.pagetype,b.intview,b.icon from ( ';
      OrgSqlTxt := 'select name,caption,type,visible,img,parent,ordno,levelno,pagetype,intview,icon from axpages where blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in';
      OrdTxt := ' , axpages b where a.name = b.name order by b.ordno, b.levelno ) c';
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        begin
          s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          Inc(ExprListCount);
        end;
        if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
        begin
           s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
           Inc(ExprListCount);
        end;
        x.next;
        //Inc(ExprListCount);
        if ExprListCount >= 999 then begin
          delete(s,length(s),2);
          if SqlTxt = '' then
             SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
          else
             SqlTxt := SqlTxt + ' Union '+OrgSqlTxt+' ( ' + s + ' ) ';
          s := '';
          ExprListCount := 1;
        end;
      end;
      if s <> '' then delete(s,length(s),2);
      if (ExprListCount > 1) then begin
         if (SqlTxt = '') then
            SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
         else
            SqlTxt := SqlTxt + ' Union '+ OrgSqlTxt+' ( ' + s + ' ) ' ;
      end;
      if SqlTxt = '' then raise exception.Create('User Roles not defined for this user');
      SqlTxt := 'select * from (' + AddSql + SqlTxt + ') a '+OrdTxt;
      x.close;
      x.sqltext:= SqlTxt;
      {pagenames := s + ',';
      while True do
      begin
        added := false;
        s := 'select name,caption,type,visible,img,parent,levelno,props,pagetype,intview from axpages where blobno=1 and lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in ( ' + s + ' ) order by ordno ,levelno ';
        x.sqltext:= s;
        x.open;
        while not x.eof do begin
          if pos(quotedstr(x.fieldbyname('name').AsString),pagenames) = 0 then
          begin
            pagenames := pagenames + quotedstr(x.fieldbyname('name').AsString) + ',' ;
            added := true;
          end;
          if pos(quotedstr(x.fieldbyname('parent').asstring),pagenames) = 0 then
          begin
             pagenames := pagenames + quotedstr(x.fieldbyname('parent').asstring) + ',';
             added := true;
          end;
          x.next;
        end;
        if added = false then break;
        x.close;
        delete(pagenames,length(pagenames),2);
        s := pagenames;
        pagenames := s + ',';
      end;}
    end;
  end else
  begin
    if pos('default',dbm.gf.userroles) > 0 then
    begin
      //x.sqltext:='select a.name,a.caption,a.type,a.visible,a.img,a.parent,a.levelno,a.props,a.pagetype,b.compcaption,a.intview from axpages a, axlanguage b where a.blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+' lower(' + dbm.gf.sqlnull + '(a.pagetype,''s'')) <> ''stem'' and lower(a.name) = lower(b.compname) order by a.ordno ,a.levelno '
      s:='select a.name,a.caption,a.type,a.visible,a.img,a.parent,a.levelno,a.props,a.pagetype, a.icon, ';
      s:=s+'(case when b.compcaption is null then a.caption else b.compcaption end) as compcaption,a.intview from axpages a ';
      s:=s+'left outer join axlanguage b on '+dbm.gf.sqllower +'(b.dispname) = ' + quotedstr(lowercase(dbm.gf.Applanguage)) + ' and lower(a.name) = lower(b.compname) ';
      s:=s+'where a.blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and ';
      s:=s+' lower(' + dbm.gf.sqlnull + '(a.pagetype,''s'')) <> ''stem'' order by a.ordno ,a.levelno ';
      x.sqltext:= s;
    end
    else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      try
        Errorstr :='';
        x.open;
      except on e:Exception do
        Errorstr :=e.Message;
      end;
      if Errorstr<>'' then begin
        if not FieldFound('webenable','axpages') then begin
          CreateField('axpages','webenable','c',1,0);
          x.open;
        end;
      end;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      OrgSqlTxt := ' select a.name,a.caption,a.type,a.visible,a.img,a.parent,a.ordno,a.levelno,a.props,a.pagetype,a.icon , (case when b.compcaption is null then a.caption else b.compcaption end)'+' as compcaption,a.intview from axpages a left outer join axlanguage b on '+dbm.gf.sqllower +'(dispname) = ' + quotedstr(lowercase(dbm.gf.Applanguage)) + ' and lower(a.name) = lower(b.compname) where a.blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(a.pagetype,''s'')) <> ''stem'' and name in ';
      OrdTxt := ' order by a.ordno ,a.levelno ';
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        begin
          s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          Inc(ExprListCount);
        end;
        if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
        begin
           s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
          Inc(ExprListCount);
        end;
        x.next;
        if ExprListCount >= 999 then begin
          delete(s,length(s),2);
          if SqlTxt = '' then
             SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
          else
             SqlTxt := SqlTxt + ' Union all '+OrgSqlTxt+' ( ' + s + ' ) ';
          s := '';
          ExprListCount := 1;
        end;
      end;
      if s <> '' then delete(s,length(s),2);
      if (ExprListCount > 1) then begin
         if (SqlTxt = '') then
            SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
         else
            SqlTxt := SqlTxt + ' Union all '+ OrgSqlTxt+' ( ' + s + ' ) ' ;
      end;
      if SqlTxt = '' then raise exception.Create('User Roles not defined for this user');
      SqlTxt := 'select * from ('+SqlTxt+') a '+OrdTxt;
      x.close;
      x.sqltext:= SqlTxt;
    end;
  end;
  s := '';
  try
    Errorstr :='';
    if not x.Active then x.open;
  except on e:Exception do
    begin
      Errorstr :=e.Message;
      dbm.gf.DoDebug.Msg('Error : ' + Errorstr);
    end;
  end;
  if Errorstr<>'' then begin
    if not FieldFound('webenable','axpages') then begin
      CreateField('axpages','webenable','c',1,0);
      x.open;
    end;
  end;
  pnode := result.DocumentElement;
  j := -1;
  k := 0;
  x.first;
  hlist := TList.Create;
  level:=-1;
  hidelevel := -1;
  iHiddenMainLevel := -1;  //Modified by Shankar.J on 18/05/2015
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    if s = 'inbox' then
    begin
       x.next;
       continue
    end;
    p := x.fieldbyname('parent').asstring;
    t := x.fieldbyname('type').AsString ;
    i := x.fieldbyname('levelno').AsInteger;
    intview := x.FieldByName('intview').AsString;
    icon := x.FieldByName('icon').AsString;
    dbm.gf.DoDebug.Msg('Name : ' + s);
    if dbm.gf.Applanguage <> '' then
    begin
      c := x.fieldbyname('compcaption').asstring;
      if c = '' then c := x.fieldbyname('caption').asstring;
    end else c := x.fieldbyname('caption').asstring;
//    wp := x.fieldbyname('pagetype').AsString;
    ptype := x.fieldbyname('pagetype').AsString;
    img := x.fieldbyname('img').AsString;

    if ptype = 'web' then
       pp := x.fieldbyname('props').AsString
    else
       pp := '';
    // new tree logic
    //Modified by Shankar.J on 18/05/2015 Start
    if i <= iHiddenMainLevel then
      iHiddenMainLevel := -1;
    //Modified by Shankar.J on 18/05/2015 End
    if x.fieldbyname('visible').asstring = 'F' then
    begin
      //Modified by Shankar.J on 18/05/2015 Start
      if iHiddenMainLevel = -1 then
        iHiddenMainLevel := i;
      //Modified by Shankar.J on 18/05/2015 End
        if t = 'h' then hidelevel := i;
        x.next;
        continue;
    end;
    if hidelevel > -1 then
    begin
       if i > hidelevel then
       begin
         x.next;
         continue;
       end else hidelevel := -1;
    end;
    //Modified by Shankar.J on 18/05/2015 Start
    if (iHiddenMainLevel <> -1) and (i > iHiddenMainLevel) then
    begin
      x.Next;
      Continue;
    end;
    //Modified by Shankar.J on 18/05/2015 End

    if i > level then begin
//      dbm.gf.DoDebug.Msg('Step1');
      if level=-1 then
        pnode:=result.documentelement
      else begin
          try
          pnode:=headList(hlist.Items[level]).hnode
          except on e:exception do
          begin
           dbm.gf.DoDebug.Msg('Parent not found 1');
           x.Next;
           Continue;
          end;
        end;
      end;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      new(hdList);
      hdlist.hnode := cnode;
      hlist.Add(hdList);
      level:=i;
    end else if i < level then begin
//      dbm.gf.DoDebug.Msg('Step2');
      k:=i+1 ;
      for l:=level downto k do begin
        if hlist.Count > l then hlist.delete(l);
      end;
//      dbm.gf.DoDebug.Msg('Step22');
      level := i;
      if level>0 then
      begin
          try
           pnode:=headList(hlist.Items[level-1]).hnode
          except on e:exception do
          begin
           dbm.gf.DoDebug.Msg('Parent not found 2');
           x.Next;
           Continue;
          end;
          end;
      end else
        pnode:=result.documentelement;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end else begin
//      dbm.gf.DoDebug.Msg('Step3');
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end;
    //
    if i > j then j := i;
    if copy(ptype,1,1) = 'i' then
    begin
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'iview.aspx?ivname=' + ptype;
    end else if copy(ptype,1,1) = 't' then
    begin
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'tstruct.aspx?transid=' + ptype ;
    end else if copy(ptype,1,1) = 'n' then
    begin
// for Interactive report multilevelmenu changes  -iviewInteractive.aspx
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'iviewInteractive.aspx?ivname=' + ptype;
    end else if pp <> '' then
       cnode.Attributes['target'] := pp
    else
       cnode.Attributes['target'] :=  '';
    cnode.Attributes['name'] := c;
    cnode.Attributes['url'] := pp;
    cnode.Attributes['level'] := inttostr(i);
    cnode.Attributes['oname'] := s;
    cnode.Attributes['intview'] := intview;
    cnode.Attributes['img'] := img;
    if (icon <> '') then
    begin
	    icdelm := Pos('|', icon);
      if icdelm > 0 then
      begin
        iconNode := cnode.AddChild('icon');
        icNode := iconNode.AddChild('text');
        icNode.Text := Copy(icon, 0, icdelm-1);;
        icNode := iconNode.AddChild('addClass');
        icNode.Text := Copy(icon, icdelm+ 1, length(icon));
      end
      else
        begin
          iconNode := cnode.AddChild('icon');
          iconNode.Text := icon;
        end;
    end;
    x.next;
  end;
  result.DocumentElement.Attributes['max'] := inttostr(j);
  x.close;
//  dbm.gf.DoDebug.Msg('Step 4');
  for i:=0 to hlist.count-1 do begin
    dispose(headlist(hlist[i]));
  end;
  hlist.clear;
end;

function TAxProvider.GetMultiLevelMenuInfo(head,level : String) : IXMLDocument;
  var n,pnode,n1,n2 : IXMLNode;
  s , p , c , t,ptype,pp: String;
  i , j, k , l : integer;
  found : boolean;
  pgs : TStringList;
  cat, img : String;
begin
  if dbm.gf.pageaccess <> '' then
  begin
    pgs := TStringList.Create;
    if pos(',',dbm.gf.pageaccess) > 0 then
    begin
      i := 1;
      while true do
      begin
        s := dbm.gf.getnthstring(dbm.gf.pageaccess,i);
        if s = '' then break;
        pgs.Add(s);
        i := i + 1;
      end;
    end
    else pgs.Add(dbm.gf.pageaccess);
  end;
  dbm.gf.DoDebug.Msg('Page Access Category : ' + dbm.gf.pageaccess);
  result:=LoadXMLData('<root></root>');
  l := strtoint(level);
  if head = '' then
  begin
    if pos('default',dbm.gf.userroles) > 0 then
    begin
         x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where levelno = 0 and type = ''h'' and blobno=1 order by ordno ,levelno '
    end else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where levelno = 0 and type = ''h'' and blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      x.open;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
          s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
        if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
           s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
        x.next;
      end;
      x.close;
      delete(s,length(s),2);
      if s = '' then raise exception.Create('User Roles not defined for this user');
      s := 'select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and name in ( ' + s + ' ) order by ordno ,levelno ';
      x.sqltext:= s;
    end;
  end else begin
    if pos('default',dbm.gf.userroles) > 0 then
    begin
         x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where ordno > (select ordno from axpages where name = '+quotedstr(head) +') and blobno=1 order by ordno ,levelno '
    end else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where ordno > (select ordno from axpages where name = '+quotedstr(head) +') and blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      x.open;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      while not x.eof do begin
        if (x.fieldbyname('parent').asstring = head) then
          s := s + quotedstr(x.fieldbyname('name').AsString) + ','
        else begin
          if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
            s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
             s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
        end;
        x.next;
      end;
      x.close;
      delete(s,length(s),2);
      if s = '' then raise exception.Create('User Roles not defined for this user');
      s := 'select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and name in ( ' + s + ' ) order by ordno ,levelno ';
      x.sqltext:= s;
    end;
  end;
  s := '';
  x.open;
  pnode := result.DocumentElement;
  j := 1;
  k := 0;
  x.first;
  while not x.eof do begin
    cat := lowercase(x.fieldbyname('category').AsString) ;
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1  then
      begin
        x.next;
        continue;
      end;
    end;
    s := x.fieldbyname('name').AsString ;
    if x.fieldbyname('visible').asstring = 'F' then
    begin
       x.next;
       continue
    end;
    if s = 'inbox' then
    begin
       x.next;
       continue
    end;
    p := x.fieldbyname('parent').asstring;
    c := x.fieldbyname('caption').asstring;
    t := x.fieldbyname('type').AsString ;
    i := x.fieldbyname('levelno').AsInteger;
    ptype := x.fieldbyname('pagetype').AsString;
    if ptype = 'web' then
       pp := x.fieldbyname('props').AsString
    else
       pp := '';
    img := x.fieldbyname('img').AsString;
    if head = '' then
    begin
      if i = 0 then
      begin
         n := pnode.AddChild('parent');
         n1 := n;
      end else if i = 1 then
      begin
         n := n1.AddChild('child');
         n2 := n;
      end else
      begin
         if i < j then n2 := n.ParentNode.ParentNode;
         if t = 'h' then
         begin
           n := n2.AddChild('child');
           n2 := n;
         end else
           n := n2.AddChild('child');
      end;
    end else
    begin
      if l = 0 then
      begin
        if i = 0 then break;
        if head = p then
        begin
          n := pnode.AddChild('parent');
          n1 := n;
        end;
        if i > 1 then
        begin
           if i < j then n1 := n.ParentNode.ParentNode;
           if t = 'h' then
           begin
             n := n1.AddChild('parent');
             n1 := n;
           end else
             n := n1.AddChild('child');
        end;
      end;
      if l = 1 then
      begin
        if i = 1 then   break;
        if head = p then
        begin
          n := pnode.AddChild('parent');
          n1 := n;
        end;
        if i > 2 then
        begin
           if i < j then n1 := n.ParentNode.ParentNode;
           if t = 'h' then
           begin
             n := n1.AddChild('parent');
             n1 := n;
           end else
             n := n1.AddChild('child');
        end;
      end;
    end;
    j := i;
    if i > k then k := i;
    if head <> '' then
    begin
      if copy(ptype,1,1) = 'i' then
      begin
         delete(ptype,1,1);
         n.Attributes['target'] := 'iview.aspx?ivname=' + ptype;
      end else if copy(ptype,1,1) = 't' then
      begin
         delete(ptype,1,1);
         n.Attributes['target'] := 'tstruct.aspx?transid=' + ptype ;
      end else if copy(ptype,1,1) = 'n' then
      begin
// for Interactive report multilevelmenu changes  -iviewInteractive.aspx
         delete(ptype,1,1);
         n.Attributes['target'] := 'iviewInteractive.aspx?ivname=' + ptype;
      end else if pp <> '' then
         n.Attributes['target'] := pp
      else
         n.Attributes['target'] :=  '';
    end else n.Attributes['target'] :=  s;
    n.Attributes['name'] := c;
    n.Attributes['img'] := img;
    x.next;
  end;
  result.DocumentElement.Attributes['max'] := inttostr(k);
  x.close;
  if assigned(pgs) then pgs.Free;
end;

function TAxProvider.MultiLevelFilterMenuXML() : IXMLDocument;
  var pnode,cnode : IXMLNode;
  s , p , c , t,wp,pp: String;
  i , j, k,l,level,hidelevel: integer;
  hlist : TList;
  hdlist : HeadList;
  pgs : TStringList;
  cat,filter,pagenames : String;
  added : boolean;
begin
  pgs := TStringList.Create;
  if dbm.gf.pageaccess <> '' then
  begin
    if pos(',',dbm.gf.pageaccess) > 0 then
    begin
      i := 1;
      while true do
      begin
        s := dbm.gf.getnthstring(dbm.gf.pageaccess,i);
        if s = '' then break;
        pgs.Add(s);
        i := i + 1;
      end;
    end
    else pgs.Add(dbm.gf.pageaccess);
  end;
  dbm.gf.DoDebug.Msg('Page Access Category : ' + dbm.gf.pageaccess);
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption,type,visible,img,parent,levelno,pagetype,props,category from axpages where blobno=1 order by ordno ,levelno '
  else
  begin
    s := '';
    x.sqltext:='select name,caption,type,visible,img,parent,levelno,pagetype,props,category from axpages where blobno=1 and lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
    end;
    x.close;
    delete(s,length(s),2);
    if s = '' then raise exception.Create('User Roles not defined for this user');
    pagenames := s + ',';
    while True do
    begin
      added := false;
      s := 'select name,caption,type,visible,img,parent,levelno,pagetype,props,category from axpages where blobno=1 and lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in ( ' + s + ' ) order by ordno ,levelno ';
      x.sqltext:= s;
      x.open;
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),pagenames) = 0 then
        begin
          pagenames := pagenames + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          added := true;
        end;
        if pos(quotedstr(x.fieldbyname('parent').asstring),pagenames) = 0 then
        begin
           pagenames := pagenames + quotedstr(x.fieldbyname('parent').asstring) + ',';
           added := true;
        end;
        x.next;
      end;
      if added = false then break;
      x.close;
      delete(pagenames,length(pagenames),2);
      s := pagenames;
      pagenames := s + ',';
    end;
  end;
  s := '';
  if not x.Active then x.open;
  pnode := result.DocumentElement;
  j := -1;
  k := 0;
  x.first;
  hlist := TList.Create;
  hlist:=tlist.create;
  level:=-1;
  hidelevel := -1;
  while not x.eof do begin
    cat := lowercase(x.fieldbyname('category').AsString) ;
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1  then
      begin
        x.next;
        continue;
      end;
    end;
    s := x.fieldbyname('name').AsString ;
    if s = 'inbox' then
    begin
       x.next;
       continue
    end;
    dbm.gf.DoDebug.Msg('Name : ' + s);
    p := x.fieldbyname('parent').asstring;
    c := x.fieldbyname('caption').asstring;
    t := x.fieldbyname('type').AsString ;
    i := x.fieldbyname('levelno').AsInteger;
    wp := x.fieldbyname('pagetype').AsString;
    if wp = 'web' then
       pp := x.fieldbyname('props').AsString
    else
       pp := '';
    // new tree logic
    if x.fieldbyname('visible').asstring = 'F' then
    begin
        if t = 'h' then hidelevel := i;
        x.next;
        continue;
    end;
    if hidelevel > -1 then
    begin
       if i > hidelevel then
       begin
         x.next;
         continue;
       end else hidelevel := -1;
    end;
    if i > level then begin
      dbm.gf.DoDebug.Msg('Step1');
      if level=-1 then
        pnode:=result.documentelement
      else begin
        pnode:=headList(hlist.Items[level]).hnode;
      end;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      new(hdList);
      hdlist.hnode := cnode;
      hlist.Add(hdList);
      level:=i;
    end else if i < level then begin
      dbm.gf.DoDebug.Msg('Step2');
      k:=i+1 ;
      for l:=level downto k do begin
        if hlist.Count > 0 then hlist.delete(l);
      end;
      dbm.gf.DoDebug.Msg('Step22');
      level := i;
      if level>0 then
        pnode:=headList(hlist.Items[level-1]).hnode
      else
        pnode:=result.documentelement;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end else begin
      dbm.gf.DoDebug.Msg('Step3');
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end;
    //
    if i > j then j := i;
    if copy(wp,1,1) = 'i' then
    begin
       delete(wp,1,1);
       cnode.Attributes['target'] := 'iview.aspx?ivname=' + wp;
    end else if copy(wp,1,1) = 't' then
    begin
       delete(wp,1,1);
       cnode.Attributes['target'] := 'tstruct.aspx?transid=' + wp ;
    end else if pp <> '' then
       cnode.Attributes['target'] := pp
    else
       cnode.Attributes['target'] :=  '';
    cnode.Attributes['name'] := c;
    cnode.Attributes['url'] := pp;
    cnode.Attributes['level'] := inttostr(i);
    cnode.Attributes['oname'] := s;
    x.next;
  end;
  result.DocumentElement.Attributes['max'] := inttostr(j);
  x.close;
  dbm.gf.DoDebug.Msg('Step 4');
  for i:=0 to hlist.count-1 do begin
    dispose(headlist(hlist[i]));
  end;
  hlist.clear;
  if assigned(pgs) then pgs.Free;
end;

function TAxProvider.GetParents(pgs : TStringList) : String;
  var  s , p , c , t,r: String;
  i , j, k , l : integer;
  found : boolean;
  cat : String;
begin
  result := '';
  l := 0;
  if pos('default',dbm.gf.userroles) > 0 then
  begin
       x.sqltext:='select name,visible,category,parent from axpages where levelno = 0 and type = ''h'' and blobno=1 order by ordno ,levelno '
  end else
  begin
    s := '';
    x.sqltext:='select name,visible,category,parent from axpages where levelno = 0 and type = ''h'' and blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
    end;
    x.close;
    delete(s,length(s),2);
    if s = '' then raise exception.Create('User Roles not defined for this user');
    s := 'select name,visible,category,parent from axpages where blobno=1 and name in ( ' + s + ' ) order by ordno ,levelno ';
    x.sqltext:= s;
  end;
  x.open;
  j := 1;
  k := 0;
  x.first;
  while not x.eof do begin
    cat := lowercase(x.fieldbyname('category').AsString) ;
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1  then
      begin
        x.next;
        continue;
      end;
    end;
    if x.fieldbyname('visible').asstring = 'F' then
    begin
       x.next;
       continue
    end;
    s := x.fieldbyname('name').asstring;
    if s = 'inbox' then
    begin
       x.next;
       continue
    end;
    result := result + quotedstr(s) + ',';
    x.next;
  end;
  if result <> '' then
  begin
    i := length(result);
    r := copy(result,i,1);
    if r = ',' then delete(result,i,1);
  end;
end;

function TAxProvider.GetDetails() : IXMLDocument;
  var enode,cnode : IXMLNode;
      nName,uroles,s,ur,r :String;
      i,j : integer;
begin
  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  x.close;
  cnode := enode.AddChild('roles');
  x.sqltext:='select distinct rname from axuseraccess order by '+dbm.gf.sqllower+'(rname)';
  x.open;
  if not x.isempty then begin
    x.first;
    i := 1;
    while not x.eof do begin
      nName := 'l'+Trim(inttostr(i));
      cnode.AddChild(nName).NodeValue := x.fieldbyname('rname').AsString;
      x.next;
      Inc(i);
    end;
  end;
  x.close;
  cnode := enode.AddChild('usergroup');
  x.sqltext:='select groupname from axusergroups order by '+dbm.gf.sqllower+'(groupname)';
  x.open;
  if not x.isempty then begin
    i := 1;
    while not x.eof do begin
      nName := 'l'+Trim(inttostr(i));
      cnode.AddChild(nName).NodeValue := x.fieldbyname('groupname').AsString;
      x.next;
      Inc(i);
    end;
  end;
  x.close;
end;

function TAxProvider.GetUserGroupDetails(UserGrp:String) : IXMLDocument;
  var enode,cnode : IXMLNode;
      nName,sRoles :String;
      i : integer;
      defRole : Boolean;
begin

  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  x.sqltext:='select userroles from axusergroups where groupname = '+quotedstr(UserGrp);
  x.open;
  sRoles := '';
//  enode.Attributes['roletype'] := x.fieldbyname('roletype').AsString;
  if not x.isempty then begin
    sRoles := x.fieldbyname('userroles').AsString;
    defRole := False;
  end else
    defRole := True;
  sRoles := lowercase(','+sRoles+',');
  x.close;
  x.sqltext:='select distinct rname from axuseraccess';
  x.open;
  if not x.isempty then begin
    x.first;
    i := 1;
    while not x.eof do begin
      nName := 'l'+Trim(inttostr(i));
      cnode := enode.AddChild(nName);
      cnode.NodeValue := x.fieldbyname('rname').AsString;
      if pos(','+lowercase(x.fieldbyname('rname').AsString)+',',sRoles) > 0 then
        cnode.Attributes['checked']:='true'
      else begin
        if (defRole) and (x.fieldbyname('rname').AsString = 'default') then
          cnode.Attributes['checked']:='true'
        else
          cnode.Attributes['checked']:='false';
      end;
      x.next;
      Inc(i);
    end;
  end;
  x.close; enode := nil; cnode:=nil;
end;

function TAxProvider.GetUserDetails(sUser:String) : IXMLDocument;
  var enode,cnode,gnode,row : IXMLNode;
      nName , r:String;
      i : integer;
      qry : TXDS;
begin
  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  x.close;
  x.sqltext:='select username,usergroup,build,tools,email,actflag,workflow,exportstruct,importstruct,manage,pwdexpdays from axusers where username = '+quotedstr(sUser);
  x.open;
  if not x.isempty then begin
    enode.AddChild('uname').NodeValue := sUser;
    cnode := enode.AddChild('usergroup');
    cnode.Attributes['value'] := x.fieldbyname('usergroup').AsString;
    enode.AddChild('mailid').NodeValue := x.fieldbyname('email').AsString;
    enode.AddChild('build').NodeValue := x.fieldbyname('build').AsString;
    enode.AddChild('tools').NodeValue := x.fieldbyname('tools').AsString;
    enode.AddChild('act').NodeValue := x.fieldbyname('actflag').AsString;
    enode.AddChild('workflow').NodeValue := x.fieldbyname('workflow').AsString;
    enode.AddChild('exp').NodeValue := x.fieldbyname('exportstruct').AsString;
    enode.AddChild('imp').NodeValue := x.fieldbyname('importstruct').AsString;
    enode.AddChild('manage').NodeValue := x.fieldbyname('manage').AsString;
    enode.AddChild('pwdexpdays').NodeValue := x.fieldbyname('pwdexpdays').AsString;
  end else begin
    enode.AddChild('uname').NodeValue := sUser;
    cnode := enode.AddChild('usergroup');
    cnode.Attributes['value'] := '';
    enode.AddChild('mailid');
    enode.AddChild('build').NodeValue := 'F';
    enode.AddChild('tools').NodeValue := 'F';
    enode.AddChild('act').NodeValue := 'F';
    enode.AddChild('workflow').NodeValue := 'F';
    enode.AddChild('exp').NodeValue := 'F';
    enode.AddChild('imp').NodeValue := 'F';
    enode.AddChild('manage').NodeValue :='F';
    enode.AddChild('pwdexpdays').NodeValue := '0';
  end;
  qry := dbm.GetXDS(nil);
  qry.buffered := true;
  qry.CDS.CommandText:='select usergroup,startdate,enddate from AXUSERLEVELGROUPS where username = '+ quotedstr(sUser);
  qry.open;
  if not qry.CDS.isempty then begin
  qry.CDS.First;
  while not qry.CDS.Eof do begin
    row := cnode.addchild('row');
    for i:=0 to qry.CDS.FieldCount-1 do begin
      xnode := row.addchild(qry.CDS.Fields[i].FieldName);
      if qry.CDS.fields[i].text = '' then
        xnode.Text := ''
      else
        xnode.text := qry.CDS.Fields[i].text;
    end;
    dbm.gf.DoDebug.msg('CDS Value : ' + xnode.text);
    qry.CDS.next;
  end;
  end;
  x.close; enode := nil; cnode:=nil; gnode:=nil;
  qry.close;qry.Free;
end;

function TAxProvider.RemoveRole(rName :String ):String;
  var i : integer;
      s,r : String;
begin
  if pos(',',rName) > 0 then
  begin
    i := 1;
    while true do
    begin
      s := dbm.gf.getnthstring(rName,i);
      if s = '' then break;
      r := r + DeleteRole(s);
      if r <> '' then r := r + ',';
      i := i + 1;
    end;
  end else r := DeleteRole(rName);
  if r = '' then
     result := 'success'
  else
     result := 'Since ' + r + ' assigned to User Roles, can''t be deleted'
end;

function TAxProvider.DeleteRole(rName :String ):String;
begin
  result := '';
  try
    dbm.gf.DoDebug.msg('Delete Role '+rName);
    x.close;
    if dbm.Connection.DbType = 'ms sql' then
      x.sqltext:= 'select userroles from axusergroups where '',''+userroles+'','' like ''%,'+rName+',%'''
    else
      x.sqltext:= 'select userroles from axusergroups where '',''||userroles||'','' like ''%,'+rName+',%''';
    x.open;
    if not x.isempty then
      raise exception.Create(rName);
    x.close;
    x.sqltext:='delete from axuseraccess where rname = '+quotedstr(rName);
    x.execsql;
  except on E : Exception do
     begin
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.RemoveUserGroup(gName :String ):String;
var grpno,tblName : String;
begin
  try
    x.close;
    x.sqltext:= 'select * from axuserlevelgroups WHERE usergroup = '+quotedstr(gName);
    x.open;
    if not x.isempty then
      raise exception.Create('Since this role has been assigned to users, it can''t be deleted');
    x.close;
    x.sqltext:='select groupno from axusergroups where groupname = '+quotedstr(gName);
    x.open;
    grpno := '';
    if not x.isempty then
      grpno := x.fieldbyname('groupno').AsString;
    x.close;
    x.sqltext:='delete from axusergroups where groupname = '+quotedstr(gName);
    x.execsql;
    tblName := 'msgs'+Trim(grpno);
    if TableFound(tblname) then
      DropTable(tblname);
    result := 'success'; 
  except on E : Exception do
     begin
       x.close;
       raise exception.Create(E.Message);
     end;
  end;
  x.close;
end;

function TAxProvider.AddUserGroup(gName,sRoles,roletype,actflag:String ):String;
var gno : Integer;
    s : String;
begin
  try
    x.close;
    x.sqltext:='select groupname from axusergroups where '+dbm.gf.sqllower+'(groupname) = '+quotedstr(lowercase(gName));
    x.open;
    if not x.isempty then
      Raise Exception.Create('Usergroup already exists');
    x.close;
//    x.sqltext:='select groupno from axusergroups where groupname = '+quotedstr(gName);
//    x.open;
//    gno := x.fieldbyname('groupno').AsInteger;
    gno := 0;
    x.close;
    s := 'insert into axusergroups(groupno,groupname,userroles,actflag) values(';
    s := s+inttostr(gno)+',';
    s := s+QuotedStr(gName)+',';
    s := s+QuotedStr(sRoles)+',';
    s := s+QuotedStr(actflag);
    s := s +')';
    x.sqltext:= s;
    x.execsql;
//    CreateMsgsTable(gno);
    result := 'success';
  except on E : Exception do
     begin
       x.close;
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.UpdateUserGroup(gName,sRoles,roletype,actflag:String ):String;
var gno : Integer;
    s : String;
begin
  try
//    x.close;
//    x.sqltext:='select max(groupno)+1 as grpno from axusergroups';
//    x.open;
//    gno := x.fieldbyname('grpno').AsInteger;
    x.close;
    s := 'update axusergroups set userroles = '+quotedstr(sRoles) + ',actflag = ' + quotedstr(actflag) +  ' where groupname = '+quotedstr(gName);
    x.sqltext:= s;
    x.execsql;
//    CreateMsgsTable(gno);
    result := 'success';
  except on E : Exception do
     begin
       x.close;
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.RemoveUser(uName :String ):String;
begin
  try
     x.close;
     x.sqltext:='delete from axuserlevelgroups where username = '+quotedstr(uName); //new delete axuserlevelgroups
     x.execsql;                                                                     //new
     x.close;                                                                       //new
     x.sqltext:='delete from axusers where username = '+quotedstr(uName);
    x.execsql;
    result := 'success';
  except on E : Exception do
     begin
       x.close;
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.AddUser(uName:String;enode:ixmlnode):String;
var gno : Integer;
    s,pwd,gName,pno,adminchange : String;
    md5 : MessageDigest_5.IMD5;
    n : ixmlnode;
    rQry : TXds;
begin
  result := '';
  rQry := nil;
  try
    x.close;
    x.sqltext:='select username from axusers where '+dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(uName));
    x.open;
    if not x.isempty then Raise Exception.Create('Username already exists');
    gName := vartostr(enode.ChildNodes['usergroup'].NodeValue);
    n := enode.ChildNodes.FindNode('ug');
    if assigned(n) then
       if n.ChildNodes.Count = 0 then  Raise Exception.Create('Usergroups is not assigned to this user');
    x.close;
    pno := '0';
    if vartype(enode.ChildNodes['pwdexpdays'].NodeValue) <> varnull then
    begin
       if vartostr(enode.ChildNodes['pwdexpdays'].NodeValue) <> '' then
          pno := vartostr(enode.ChildNodes['pwdexpdays'].NodeValue)
       //else pno := '0'
    end;
    adminchange := 'no';
    if vartype(enode.attributes['changebyadmin']) <> varnull then
    begin
      adminchange := lowercase(vartostr(enode.attributes['changebyadmin']));
    end;
    gno := 0;
    s := 'insert into axusers(username,password,usergroup,groupno,build,tools,workflow,actflag,email,exportstruct,importstruct,manage,isfirsttime,pwdexpdays) values(';
    s := s+quotedstr(uName)+',';
    pwd := vartostr(enode.ChildNodes['pwd'].NodeValue);
    {
    if pwd <> '' then begin
      md5 := MessageDigest_5.GetMD5();
      md5.Update(pwd);
      pwd := lowercase(md5.AsString());
    end;
    }
    s := s+QuotedStr(pwd)+',';
    s := s+quotedstr(gName)+',';
    s := s+inttostr(gno)+',';
    s := s+quotedstr(uppercase(vartostr(enode.ChildNodes['build'].NodeValue)))+',';
    s := s+quotedstr(uppercase(vartostr(enode.ChildNodes['tools'].NodeValue)))+',';
    s := s+quotedstr(uppercase(vartostr(enode.ChildNodes['workflow'].NodeValue)))+',';
    s := s+quotedstr(uppercase(vartostr(enode.ChildNodes['act'].NodeValue)))+',';
    s := s+quotedstr(vartostr(enode.ChildNodes['mailid'].NodeValue))+',';
    s := s+quotedstr(vartostr(enode.ChildNodes['exp'].NodeValue))+',';
    s := s+quotedstr(vartostr(enode.ChildNodes['imp'].NodeValue))+',';
    s := s+quotedstr(vartostr(enode.ChildNodes['manage'].NodeValue))+',';
    s := s+quotedstr('T')+',';
    s := s+quotedstr(pno)+')';
    x.sqltext:= s;
    x.execsql;
    dbm.gf.DoDebug.msg('Adding Userlevel groups ');
    dbm.gf.DoDebug.msg('ug node : ' + n.XML);
    updateaxuserlevelgroups(n,uname);
    if (lowercase(uname) <> 'admin') then
    begin
       rQry := dbm.GetXDS(nil);
       rQry.Submit('username',trim(uname),'c');
       rQry.Submit('pwdchange','N','c');
       rQry.Submit('pwdchangedate',datetimetostr(dbm.serverdatetime),'d');
       rQry.Submit('prevpwds',quotedstr(''),'c');
       rQry.AddOrEdit('axuserspwdpolicy', dbm.gf.SQLLower+'(username) = '+quotedstr(lowercase(uname)));
       rQry.close;
    end;
    result := 'success';
  except on E : Exception do
     begin
       x.close;
       raise Exception.Create(E.Message);
     end;
  end;
  x.close;
  if assigned(rQry) then begin
    rQry.close; rQry.Free; rQry := nil;
  end;
end;

function TAxProvider.UpdateUser(uName:String;enode:ixmlnode):String;
var gno : Integer;
    s,pwd,gName,pno,adminchange : String;
   // md5 : MessageDigest_5.IMD5;
    n : ixmlnode;
    rQry : TXds;
begin
  result := '';
  rQry := nil;
  try
    gName := vartostr(enode.ChildNodes['usergroup'].NodeValue);
    if assigned(n) then
       if n.ChildNodes.Count = 0 then  Raise Exception.Create('Usergroups is not assigned to this user');
    adminchange := 'no';
    pwd := vartostr(enode.ChildNodes['pwd'].NodeValue);
    adminchange := lowercase(vartostr(enode.attributes['changebyadmin']));
    if adminchange <> 'yes' then
    begin
      if dbm.gf.pwdprevnos > 0 then
      begin
        if not checkfor_prev_pwds(pwd,uname) then
        begin
          raise exception.Create('New password should not be same as last ' + inttostr(dbm.gf.pwdprevnos) + ' passwords');
        end;
      end;
    end;
    gno := 0;
    pno := '0';
    if vartype(enode.ChildNodes['pwdexpdays'].NodeValue) <> varnull then
    begin
       if vartostr(enode.ChildNodes['pwdexpdays'].NodeValue) <> '' then
          pno := vartostr(enode.ChildNodes['pwdexpdays'].NodeValue)
//       else pno := '0'
    end;
    x.close;
    s := 'update axusers set usergroup='+quotedstr(gName);
    s := s+',groupno='+inttostr(gno);
    s := s+',build='+quotedstr(uppercase(vartostr(enode.ChildNodes['build'].NodeValue)));
    s := s+',tools='+quotedstr(uppercase(vartostr(enode.ChildNodes['tools'].NodeValue)));
    s := s+',email='+quotedstr(vartostr(enode.ChildNodes['mailid'].NodeValue));
    pwd := vartostr(enode.ChildNodes['pwd'].NodeValue);
    {
    if pwd <> '' then begin
      md5 := MessageDigest_5.GetMD5();
      md5.Update(pwd);
      pwd := lowercase(md5.AsString());
      s := s+',password='+quotedstr(pwd)
    end;
    }
    if pwd <> '' then s := s+',password='+quotedstr(pwd);
    if adminchange = 'yes' then
    begin
      s := s+',logintry='+quotedstr('0');
    end;
    s := s+',actflag='+ quotedstr(vartostr(enode.ChildNodes['act'].NodeValue));
    s := s+',workflow='+ quotedstr(vartostr(enode.ChildNodes['workflow'].NodeValue));
    s := s+',exportstruct='+ quotedstr(vartostr(enode.ChildNodes['exp'].NodeValue));
    s := s+',importstruct='+ quotedstr(vartostr(enode.ChildNodes['imp'].NodeValue));
    s := s+',manage='+ quotedstr(vartostr(enode.ChildNodes['manage'].NodeValue));
    s := s+',isfirsttime='+ quotedstr('F');
    s := s+',pwdexpdays='+ quotedstr(pno);
    s := s+' where username = '+quotedstr(uName);
    x.sqltext:= s;
    x.execsql;
    x.close;
    n := enode.ChildNodes.FindNode('ug');
    x.SqlText := 'delete  from axuserlevelgroups where '+dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(uName));
    x.execsql;
    updateaxuserlevelgroups(n,uname);
    if (lowercase(uname) <> 'admin') then
    begin
      rQry := dbm.GetXDS(nil);
      rQry.Submit('username',trim(uname),'c');
      if adminchange = 'yes' then
         rQry.Submit('pwdchange','Y','c')
      else
      begin
         rQry.Submit('pwdchange','N','c');
         rQry.Submit('pwdchangedate',datetimetostr(dbm.serverdatetime),'d');
         rQry.Submit('prevpwds',prev_pwds,'c');
      end;

      rQry.AddOrEdit('axuserspwdpolicy',dbm.gf.SQLLower+'(username) = '+quotedstr(lowercase(uname)));
      rQry.close;
    end else begin
      rQry := dbm.GetXDS(nil);
      if adminchange = 'yes' then
         rQry.Submit('pwdchange','Y','c')
      else
      begin
         rQry.Submit('pwdchange','N','c');
      end;
      rQry.AddOrEdit('axuserspwdpolicy', dbm.gf.SQLLower+'(username) = '+quotedstr(lowercase(uname)));
      rQry.close;
    end;
    result := 'success';
  except on E : Exception do
     begin
       x.close;
       raise Exception.Create(E.Message);
     end;
  end;
  x.close;
  if assigned(rQry) then begin
    rQry.close; rQry.Free; rQry := nil;
  end;
end;

procedure TAxProvider.updateaxuserlevelgroups(ug : ixmlnode ; uname : String);
  var i : integer;
  ugrps,stdt,endt : String;
  axuserlevelgroupsid : Extended;
  sdt,edt : TDateTime;
begin
  dbm.gf.DoDebug.msg('Updating axuserlevelgroups');
  dbm.gf.DoDebug.msg('ug node : ' + ug.XML);
  for i := 0 to ug.ChildNodes.Count - 1 do
  begin
     ugrps := vartostr(ug.ChildNodes[i].ChildValues['USERGROUP']);
     if ugrps = '' then continue;
     stdt := vartostr(ug.ChildNodes[i].ChildValues['STARTDATE']);
     endt := vartostr(ug.ChildNodes[i].ChildValues['ENDDATE']);
     if stdt <> '' then
     begin
       sdt := strtodate(stdt);
       stdt:=dbm.gf.findandreplace(dbm.gf.dbdatestring, ':value', dbm.gf.ConvertToDBDateTime(dbm.Connection.dbtype,sdt));
     end;
     if endt <> '' then
     begin
       edt := strtodate(endt);
       endt:=dbm.gf.findandreplace(dbm.gf.dbdatestring, ':value', dbm.gf.ConvertToDBDateTime(dbm.Connection.dbtype,edt));
     end else endt := quotedstr('');
     x.close;
//old     x.sqltext:= 'insert into axuserlevelgroups values (' + quotedstr(uname) + ',' + quotedstr(ugrps) + ',' + quotedstr(stdt) + ','+ quotedstr(endt) + ')';
//     axuserlevelgroupsid := dbm.Gen_id(dbm.Connect.Connection); //removed axuserlevelgroupid after the discussion with Sab, its not used anywhere else.
     x.sqltext:= 'insert into axuserlevelgroups(USERNAME,USERGROUP,STARTDATE,ENDDATE) values ('+ quotedstr(uname) + ',' + quotedstr(ugrps) + ',' + stdt + ','+ endt + ')';//new
     dbm.gf.DoDebug.msg('SQL Text : ' + x.sqltext);
     x.execsql;
  end;
end;

procedure TAxProvider.CreateMsgsTable(grpno:Integer);
var tblname,s : String;
begin
  tblname := 'msgs'+Trim(InttoStr(grpno));
  s := '';
  if (dbm.Connection.DbType = 'mysql') or (dbm.Connection.DbType = 'postgre') then begin
    s := s+'msgtime varchar(25)'+',';
    s := s+'msg text default '''''+',';
    s := s+'msgfrom varchar(30) default '''''+',';
    s := s+'msgto varchar(30) default '''''+',';
    s := s+'sname varchar(10) default '''''+',';
    s := s+'recordid numeric(15) default 0'+',';
    s := s+'readflag varchar(3) default '''''+',';
    s := s+'msgno numeric(5) default 0';
  end else if dbm.Connection.DbType = 'access' then begin
    s := s+'msgtime text(25)'+',';
    s := s+'msg memo'+',';
    s := s+'msgfrom text(30)'+',';
    s := s+'msgto text(30)'+',';
    s := s+'sname text(10)'+',';
    s := s+'recordid double'+',';
    s := s+'readflag text(3)'+',';
    s := s+'msgno numeric(5) integer';
  end else if dbm.Connection.DbType = 'oracle' then begin
    s := s+'msgtime varchar2(25)'+',';
    s := s+'msg clob'+',';
    s := s+'msgfrom varchar2(30)'+',';
    s := s+'msgto varchar2(30)'+',';
    s := s+'sname varchar2(10)'+',';
    s := s+'recordid numeric(15)'+',';
    s := s+'readflag varchar2(3)'+',';
    s := s+'msgno numeric(5)';
  end else if dbm.Connection.DbType = 'ms sql' then begin
    s := s+'msgtime varchar(25)'+',';
    s := s+'msg varchar(max)'+',';
    s := s+'msgfrom varchar(30)'+',';
    s := s+'msgto varchar(30)'+',';
    s := s+'sname varchar(10)'+',';
    s := s+'recordid numeric(15)'+',';
    s := s+'readflag varchar(3)'+',';
    s := s+'msgno numeric(5)';
  end;
  if not TableFound(tblname) then
    CreateTable(tblname,s);
end;

Procedure TAxProvider.CreateTable(TableName:String;FName :String);
 var St ,ErrMsg   :String;
begin
  Try
   ErrMsg :='';
   q.close;
   if FName <> '' then begin
     if dbm.Connection.DbType = 'mysql' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ') ENGINE=InnoDB'// TYPE=InnoDB
     else if dbm.Connection.DbType = 'access' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + FName + ')'
     else if dbm.Connection.DbType = 'ms sql' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + FName + ')'
     else if dbm.Connection.DbType = 'postgres' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ')'
     else
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ')';
   end else begin
     if dbm.Connection.DbType = 'mysql' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id decimal(16)) ENGINE=InnoDB'// TYPE=InnoDB
     else if dbm.Connection.DbType = 'access' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + TableName +'id double)'
     else if dbm.Connection.DbType = 'ms sql' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + TableName +'id integer)'
     else if dbm.Connection.DbType = 'postgres' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id numeric(16))'
     else
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id integer)';
   end;
   q.sqltext := St;
   q.execsql;
   q.close;
  Except on e:exception do
   ErrMsg := e.message ;
  End;
  if ErrMsg<>'' then begin
   q.close;
   //Showmessage('TablesCreated ~ '+ TableName +'  ' + Errmsg +'');
   dbm.gf.DoDebug.Msg('TablesCreated ~ '+ TableName +'  ' + Errmsg +'');
   dbm.gf.DoDebug.log('TablesCreated ~ '+ TableName +'  ' + Errmsg +'');
  end;
end;

procedure TAxProvider.DropConstraint(TableName, Constraints: String);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDropConstraint(TableName,Constraints);
    exit;
  end;
  Try
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQlText := 'Alter table ['+ UpperCase(TableName) + '] drop constraint ' + Constraints
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] drop Constraint ' + Constraints
    else if dbm.Connection.DbType = 'mysql' then begin
      if copy(constraints,1,1)='P' then
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop primary key '
      else
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop foreign key ' + Constraints;
    end
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop Constraint ' + Constraints;
    q.ExecSQL;
  Except
  End;
end;

Procedure TAxProvider.DropTable(TableName:String);
  var  St,ErrMsg : String;
begin
  Try
   ErrMsg :='';
   q.Close;
   St := 'Drop Table '+ UpperCase(TableName) ;
   q.sqltext := St;
   q.ExecSQL;
   q.Close;
  Except on e:exception do
   ErrMsg := e.message ;
  End;
  if ErrMsg<>'' then begin
     //Showmessage('Cannot Drop Table  ~ '+ TableName +'  ' + Errmsg +'');
    q.Close;
    dbm.gf.DoDebug.Msg('Cannot Drop Table  ~ '+ TableName +'  ' + Errmsg +'');
    dbm.gf.DoDebug.Log('Cannot Drop Table  ~ '+ TableName +'  ' + Errmsg +'');
  end;
end;

procedure TAxProvider.LoadItems(mNode:ixmlnode;sName,sRole:String);
var axml : ixmldocument;
    i : integer;
    enode,cnode : ixmlnode;
    tx1 : TXDS;
begin
  if sname = 'pages' then begin
    if srole = 'default' then
      mNode.attributes['checked'] := 'true';
    GetPageOrderXMLForAccCtrl(mNode,sRole);
  end else begin
    axml := GetAllStructures(sname);
    enode := axml.DocumentElement;
    if sRole = 'default' then
      mnode.Attributes['checked'] := 'true';
    for i := 0 to enode.ChildNodes.Count - 1 do begin
      cnode := mNode.AddChild(enode.ChildNodes[i].NodeName);
      if sRole = 'default' then
        cnode.Attributes['checked'] := 'true'
      else
        cnode.Attributes['checked'] := 'false';
      cnode.Attributes['cap'] := vartostr(enode.ChildNodes[i].NodeValue);
    end;
    enode := nil; cnode:=nil ;axml := nil;
  end;
end;

procedure TAxProvider.GetPageOrderXMLForAccCtrl(mNode:ixmlnode;sRole:String);
var pnode,n : IXMLNode;
    s,pStr,sname : String;
    oldlevel,curlevel : integer;
    i : integer;
begin
  x.sqltext:='select name,caption,type,visible,img,parent,levelno,pagetype from axpages where blobno=1 and name <> ''inbox'' order by ordno ,levelno ';
  x.open;
  if x.isempty then begin
    x.close;
    exit;
  end;
  pStr := '';
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    sname := x.fieldbyname('pagetype').AsString ;
    if (x.fieldbyname('levelno').asInteger = 0) then begin
       n := mNode.AddChild(s);
    end else begin
       pnode := GetParentNode(mNode,x.fieldbyname('parent').asString);
       if pnode = nil  then
          n := mNode.AddChild(s)
       else n := pnode.AddChild(s);
    end;
    if (x.fieldbyname('type').asstring = 'h') then
      n.Attributes['type'] := 'parent';
    n.Attributes['parent']  := x.fieldbyname('parent').asstring;
    if sRole = 'default' then
      n.Attributes['checked']  := 'true'
    else
      n.Attributes['checked']  := 'false';
    n.Attributes['cap'] := x.fieldbyname('caption').asstring;
//    if sname <> '' then delete(sname,1,1);
    n.Attributes['sname'] := sname;
    x.next;
  end;
  x.close;
  n:=nil;
end;

function TAxProvider.GetParentNode(mNode:ixmlnode;pName:String):ixmlnode;
var jnode,rnode : ixmlnode;
  procedure ProcessNode(Node : IXMLNode; sName: String);
  var
    cNode : IXMLNode;
  begin
    if (Node = nil)  then Exit;
    if Node.NodeName = sName then begin
      rnode := node;
      exit;
    end;
    cNode := Node.ChildNodes.First;
    while cNode <> nil do
    begin
      ProcessNode(cNode, sName);
      if rnode <> nil then exit;
      cNode := cNode.NextSibling;
    end;
  end; (*ProcessNode*)
begin
  jNode := mNode;
  rnode := nil;
  while jNode <> nil do
  begin
    ProcessNode(jNode,pName);
    if rnode <> nil then begin
      result := rnode;
      exit;
    end;
    jNode := jNode.NextSibling;
  end;
end;

procedure TAxProvider.LoadAccess(mNode:ixmlnode;sRole:String);
var otype : String;
    snode,pnode,n :ixmlnode;
    sname : String;
begin
  dbm.gf.DoDebug.msg('Executing LoadAccess');
  x.sqltext := 'select sname,stype from axuseraccess where rname = '+quotedstr(sRole)+' order by stype';
  x.open;
  if not x.isempty then begin
    x.first;
    otype := '';
    while not x.eof do begin
      if x.fieldbyname('stype').asstring = 'l' then
      begin
       x.next;
       continue;
      end;
      if otype <> x.fieldbyname('stype').asstring then begin
        if x.fieldbyname('stype').asstring = 't' then
          snode := mnode.ChildNodes.FindNode('Tstructs')
        else if x.fieldbyname('stype').asstring = 'p' then
          snode := mnode.ChildNodes.FindNode('Pages')
        else if x.fieldbyname('stype').asstring = 'i' then
          snode := mnode.ChildNodes.FindNode('Iviews');
        snode.Attributes['checked'] := 'true';
        otype := x.fieldbyname('stype').asstring;
      end;
      sname := x.fieldbyname('sname').asstring;
      if x.fieldbyname('stype').asstring = 'p' then begin
        pnode := snode;
        n := GetParentNode(pnode,sname);
        if n <> nil then begin
          n.Attributes['checked'] := 'true';
        end;
      end else begin
        n := snode.ChildNodes.FindNode(sname);
        if n<>nil then begin
          n.Attributes['checked'] := 'true';
        end;
      end;
      x.next;
    end;
  end else begin
   snode := mnode.ChildNodes.FindNode('Tstructs');
   snode.attributes['checked']:= 'false';
   snode := mnode.ChildNodes.FindNode('Iviews');
   snode.attributes['checked']:= 'false';
   snode := mnode.ChildNodes.FindNode('Pages');
   snode.attributes['checked']:= 'false';
  end;
  x.close;
  snode := nil; pnode :=nil; n:=nil;
end;

function TAxProvider.AddRoles(enode:ixmlnode):String;
var i , j : Integer;
    s,rName,sType,sCap,t,w,sName,act : String;
    cnode : ixmlnode;
begin
  s := vartostr(enode.Attributes['role']) + ',';
  act := vartostr(enode.Attributes['act']);
  j := 1;
  while true do
  begin
    rName := dbm.gf.getnthstring(s,j);
    if rName = '' then break;
    j := j + 1;
    try
  //    rName := vartostr(enode.Attributes['role']);
      dbm.gf.DoDebug.msg('Deleting Roles');
      x.SqlText := 'select rname,sname,stype from axuseraccess where ' + dbm.gf.sqllower + '(rname) = '+quotedstr(lowercase(rname));
      x.open;
      if not x.isempty then begin
        x.first;
        while not x.eof do begin
          if x.fieldbyname('stype').AsString <> 'l' then begin
            if not NodeExists(enode,lowercase(x.fieldbyname('sname').asstring),lowercase(x.fieldbyname('stype').AsString)) then begin
              dbm.gf.DoDebug.msg('deleting record sname = '+x.fieldbyname('sname').asstring+' stype='+x.fieldbyname('stype').asstring);
              w:='rname '+'='+quotedstr(rName)+' and '+'sname '+'='+quotedstr(x.fieldbyname('sname').asstring)+' and stype = '+quotedstr(x.fieldbyname('stype').asstring);
              dbm.gf.DoDebug.msg('Where contition : ' + w)  ;
              q.DeleteRecord('axuseraccess',w);
              if x.fieldbyname('stype').asstring = 't' then begin
                w:='rname '+'='+quotedstr(rName)+' and sname '+'='+quotedstr(x.fieldbyname('sname').asstring)+' and stype = '+quotedstr('l');
                dbm.gf.DoDebug.msg('Where contition : ' + w)  ;
                q.DeleteRecord('axuseraccess',w);
              end;
            end;
            q.close;
          end;
          x.next;
        end;
      end;
      dbm.gf.DoDebug.msg('Adding Roles');
      x.close;
      for i := 0 to enode.ChildNodes.Count - 1 do begin
        cnode := enode.ChildNodes[i];
        sCap := lowercase(vartostr(cnode.NodeValue));
        if (sCap = 'tstructs') or (sCap = 'iviews') or (sCap = 'pages') then continue;
        sType := lowercase(vartostr(cnode.Attributes['parent']));
        if sType = 'tstructs' then
          sType := 't'
        else if sType = 'iviews' then
          sType := 'i'
        else sType := 'p';
        sName := vartostr(cnode.NodeName);
        t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
        w:= dbm.gf.sqllower + '(rname) =' + quotedstr(lowercase(rName))+' and sname ='+quotedstr(sName)+' and stype = '+quotedstr(sType);
        x.Submit('rname', rName, 'c');
        x.Submit('sname',sName , 'c');
        x.Submit('stype',sType,'c');
        x.Submit('actflag',act,'c');
        x.Submit('updatedon',t,'c');
        x.AddOrEdit('axuseraccess', w);
        x.Post;
        dbm.gf.DoDebug.msg('Where contition : ' + w)  ;
        {
        if (stype = 'p') and (lowercase(copy(sname,1,4)) = 'head') then
        begin
          sname := vartostr(cnode.Attributes['parent']);
          while sname <> '' do
          begin
            q.close;
            q.SqlText := 'select name,parent from axpages where name = '+quotedstr(sname);
            q.open;
            if not q.isempty then
            begin
              sname := q.fieldbyname('name').AsString;
              w:= dbm.gf.sqllower + '(rname) =' + quotedstr(lowercase(rName))+' and sname ='+quotedstr(sName)+' and stype = '+quotedstr(sType);
              x.Submit('rname', rName, 'c');
              x.Submit('sname',sName , 'c');
              x.Submit('stype',sType,'c');
              x.Submit('updatedon',t,'c');
              x.AddOrEdit('axuseraccess', w);
              x.Post;
              dbm.gf.DoDebug.msg('Where contition : ' + w)  ;
              sname := trim(q.fieldbyname('parent').AsString);
              if sname = '' then break;
            end else break;
          end;
        end;
        }
      end;
      x.close;
      result := 'success';
    except on E : Exception do
       begin
         x.close;
         result :=  E.Message;
         dbm.gf.DoDebug.msg('Error Message : ' + E.Message)  ;
       end;
    end;
  end;
end;

procedure TAxprovider.LoadTstructDetails(enode:ixmlnode;transid:String);
var xml : ixmldocument;
    tenode,dnode,fnode,pnode,xnode,tnode,tcnode : ixmlnode;
    i : integer;
    lview,asgrid : Boolean;
begin
  dbm.gf.DoDebug.msg('Loading Tstruct Details');
  xml := GetStructure('tstructs',transid,'','');
  tenode := xml.DocumentElement;
  if tenode = nil then exit;
  dnode := enode.ChildNodes.FindNode('dcs');
  fnode := enode.ChildNodes.FindNode('fields');
  tcnode := enode.ChildNodes.FindNode('tcfld');
  for i := 0 to tenode.ChildNodes.Count - 1 do begin
    pnode := tenode.ChildNodes[i];
    if (pnode.Attributes['cat']<>'tstruct') and (pnode.Attributes['cat']<>'dc') and (pnode.Attributes['cat']<>'field') then continue;
    if pnode.Attributes['cat'] = 'tstruct' then begin
      lview := lowercase(vartostr(pnode.ChildNodes[xml_listview].NodeValue)) = 'true';
      continue;
    end else if pnode.Attributes['cat'] = 'dc' then begin
      xnode := dnode.AddChild(pnode.NodeName);
      xnode.Attributes['cap'] := vartostr(pnode.ChildValues[xml_caption]);
      asgrid := (pnode.ChildValues[xml_AsGrid] = 'True');
    end else if pnode.Attributes['cat'] = 'field' then begin
      xnode := fnode.AddChild(pnode.NodeName);
      xnode.Attributes['cap'] := vartostr(pnode.ChildValues[xml_caption]);
      if not asgrid then
        tcnode.AddChild(pnode.NodeName)
    end;
    xnode.Attributes['view'] := 'true';
    xnode.Attributes['enable'] := 'true';
  end;
  tnode := tenode.ChildNodes.FindNode('comps');
  if tnode <> nil then begin
    dnode := enode.ChildNodes.FindNode('buttons');
    AddBtns(tnode,dnode);
  end;
  if lview then
    LoadListViewButtons(enode,transid);
  xml:=nil;tenode:=nil;dnode:=nil;fnode:=nil;pnode:=nil;xnode:=nil;tnode:=nil;tcnode:=nil;
end;

procedure TAxprovider.LoadListViewButtons(enode:ixmlnode;lvname:String);
var xml : ixmldocument;
    i : integer;
    tenode,cnode,pnode: ixmlnode;
begin
  dbm.gf.DoDebug.msg('Loading ListView buttons');
  xml := GetStructure('lviews',lvname,'','',dbm.gf.username);
  tenode := xml.DocumentElement;
  if tenode = nil then exit;
  cnode := tenode.ChildNodes.FindNode('comps');
  if cnode = nil then exit;
  pnode := enode.ChildNodes.FindNode('listviewbuttons');
  AddBtns(cnode,pnode);
  xml:=nil;tenode:=nil;cnode:=nil;pnode:=nil;
end;

procedure TAxprovider.AddBtns(tnode,dnode:ixmlnode);
var i : integer;
    pnode,xnode : ixmlnode;
begin
  dbm.gf.DoDebug.msg('Loading buttons');
  for i := 0 to tnode.ChildNodes.Count - 1 do begin
    pnode := tnode.ChildNodes[i];
    if (pnode.HasAttribute('cat')) then begin
      if (vartostr(pnode.Attributes['cat']) <> 'btn') then continue;
      xnode := dnode.AddChild(pnode.NodeName);
      if VarToStr(pnode.Attributes['caption']) <> '' then
        xnode.Attributes['cap'] := VarToStr(pnode.Attributes['caption'])
      else if VarToStr(pnode.Attributes['hint']) <> '' then
        xnode.Attributes['cap'] := VarToStr(pnode.Attributes['hint']);
      xnode.Attributes['view'] := 'true';
      xnode.Attributes['enable'] := 'true';
    end;
  end;
  pnode:=nil; xnode:=nil;
end;

function TAxprovider.NodeExists(enode:ixmlnode;sname,stype:String):Boolean;
var i : integer;
    cnode : ixmlnode;
    cName,cType,sCap : String;
begin
  result := False;
  for i := 0 to enode.ChildNodes.Count - 1 do begin
    cnode := enode.ChildNodes[i];
    sCap := lowercase(vartostr(cnode.NodeValue));
    if (sCap = 'tstructs') or (sCap = 'iviews') or (sCap = 'pages') then continue;
    cType := lowercase(vartostr(cnode.Attributes['parent']));
    if cType = 'tstructs' then
      cType := 't'
    else if cType = 'iviews' then
      cType := 'i'
    else   cType := 'p';
    cName := lowercase(vartostr(cnode.NodeName));
    if (sname = cName) and (stype = cType) then begin
      result := True;
      break;
    end;
  end;
  cnode := nil;
end;

function TAxProvider.RoleExists(rName:String):Boolean;
begin
  x.close;
  x.sqltext:='select distinct rname from axuseraccess where '+dbm.gf.sqllower+'(rname) = '+quotedstr(lowercase(rName));
  x.open;
  result := (not x.isempty);
end;

procedure TAxprovider.LoadAccControl(enode:ixmlnode;sName,sRole,sType:String;lview:Boolean);
var s,rName,w,p : String;
    stm : TStringStream;
    xml : ixmldocument;
    dnode,cnode,tnode : ixmlnode;
begin
  if lowercase(sRole) = 'default' then exit;
  dbm.gf.DoDebug.msg('Loading Access Control');
  rName := enode.Attributes['role'];
//  w:='rname '+'='+quotedstr(sRole)+' and '+'sname '+'='+quotedstr(sname)+' and stype = '+quotedstr(sType);
  w:=dbm.gf.sqllower+'(rname)= :rname and ' + dbm.gf.sqllower + '(sname)= :sname and stype = :stype' ;
  p := lowercase(sRole) + ','+ lowercase(sname) +',' + sType;
  x.sqltext:='select props from axuseraccess where '+w;
  x.parambyname('rname').AsString := lowercase(sRole);
  x.parambyname('sname').AsString := lowercase(sName);
  x.parambyname('stype').AsString := lowercase(sType);
  x.open;
  if x.isempty then begin
    x.close;
    exit;
  end;
  s := '';
  stm := TStringStream.Create(s);
  dbm.ReadMemo('props', 'axuseraccess' , w ,p,'ccc' , stm);
  dbm.gf.DoDebug.msg(trim(stm.DataString));
  if stm.DataString = '' then begin
    stm.Free;
    exit;
  end else xml:=Loadxmldata(trim(stm.DataString));
  stm.Free;
  dnode := xml.DocumentElement;
  if dnode <> nil then begin
    cnode := dnode.ChildNodes.FindNode('vc');
    if cnode <> nil then
      LoadViewControl(cnode,enode,'t');
    if sType = 't' then begin
      cnode := dnode.ChildNodes.FindNode('tc');
      if cnode <> nil then
        LoadTransControl(cnode,enode);
    end;
  end;
  if (sType = 't') and (lview) then begin
//    w:='rname '+'='+quotedstr(sRole)+' and '+'sname '+'='+quotedstr(sName)+' and stype = '+quotedstr('l');
    p := '';
    w:=dbm.gf.sqllower+'(rname)= :rname and ' + dbm.gf.sqllower + '(sname)= :sname and stype = :stype' ;
    p := lowercase(sRole) + ','+ lowercase(sname) +',' + 'l';
    x.close;
    x.sqltext:='select props from axuseraccess where '+w;
    x.open;
    if not x.isempty then begin
      s :='';
      stm := TStringStream.Create(s);
      dbm.ReadMemo('props', 'axuseraccess', w,p,'ccc', stm);
      if stm.DataString = '' then
        stm.Free
      else begin
        xml:=Loadxmldata(trim(stm.DataString));
        stm.Free;
      end;
      dnode := xml.DocumentElement;
      if dnode <> nil then begin
        cnode := dnode.ChildNodes.FindNode('vc');
        if cnode <> nil then
          LoadViewControl(cnode,enode,'l');
      end;
    end;
  end;
  xml:=nil;dnode:=nil;cnode:=nil;tnode:=nil;
  x.close;
end;

procedure TAxProvider.LoadViewControl(cnode,enode:ixmlnode;vcFor:String);
var dcnode,fnode,bnode,tnode :ixmlnode;
    i : integer;
begin
  dbm.gf.DoDebug.msg('Loading ViewControl');
  if vcFor = 't' then begin
    dcnode := enode.ChildNodes.FindNode('dcs');
    fnode := enode.ChildNodes.FindNode('fields');
    bnode := enode.ChildNodes.FindNode('buttons');
    for i := 0 to cnode.ChildNodes.Count - 1 do begin
      dbm.gf.DoDebug.msg('name '+cnode.ChildNodes[i].Nodename+' c='+cnode.ChildNodes[i].Attributes['c']+' a='+cnode.ChildNodes[i].Attributes['a']);
      if cnode.ChildNodes[i].Attributes['c'] = 'd' then
        tnode := dcnode.ChildNodes.FindNode(cnode.ChildNodes[i].NodeName)
      else if cnode.ChildNodes[i].Attributes['c'] = 'f' then
        tnode := fnode.ChildNodes.FindNode(cnode.ChildNodes[i].NodeName)
      else if cnode.ChildNodes[i].Attributes['c'] = 'b' then
        tnode := bnode.ChildNodes.FindNode(cnode.ChildNodes[i].NodeName);
      if tnode <> nil then begin
        if cnode.ChildNodes[i].Attributes['a'] = 'd' then
          tnode.Attributes['enable'] := 'false'
        else if cnode.ChildNodes[i].Attributes['a'] = 'h' then
          tnode.Attributes['view'] := 'false';
      end;
    end;
    dcnode:=nil;fnode:=nil;bnode:=nil;tnode:=nil;
  end else if vcFor = 'l' then begin
    bnode := enode.ChildNodes.FindNode('listviewbuttons');
    for i := 0 to cnode.ChildNodes.Count - 1 do begin
      tnode := bnode.ChildNodes.FindNode(cnode.ChildNodes[i].NodeName);
      if tnode <> nil then begin
        if cnode.ChildNodes[i].Attributes['a'] = 'd' then
          tnode.Attributes['enable'] := 'false'
        else if cnode.ChildNodes[i].Attributes['a'] = 'h' then
          tnode.Attributes['view'] := 'false';
      end;
    end;
    bnode:=nil; tnode:=nil;
  end;
end;

procedure TAxProvider.LoadTransControl(cnode,enode:ixmlnode);
var pnode,tcnode,tnode :ixmlnode;
    i : integer;
    s,nName,val,op,acs,f : String;
begin
  dbm.gf.DoDebug.msg('Loading TransControl');
  tcnode := enode.ChildNodes.FindNode('tcexpr');
  for i := 0 to cnode.ChildNodes.Count - 1 do begin
    pnode := cnode.ChildNodes[i];
    tnode := tcnode.AddChild('row');
    val := vartostr(pnode.NodeValue);
    op := vartostr(pnode.Attributes['op']);
    acs := vartostr(pnode.Attributes['a']);
    f := vartostr(pnode.Attributes['f']);
    if op = 'btw' then
      s := 'if '+f+' '+GetOperator(op)+' '+dbm.gf.getnthstring(val,1)+' and '+dbm.gf.getnthstring(val,2)
    else
      s := 'if '+f+' '+GetOperator(op)+' '+val;
    tnode.AddChild('expr').NodeValue := s;
    if acs = 'n' then begin
      tnode.AddChild('view').NodeValue := 'false';
      tnode.AddChild('edit').NodeValue := 'false';
      tnode.AddChild('delete').NodeValue := 'false';
    end else if acs = 'd' then begin
      tnode.AddChild('view').NodeValue := 'true';
      tnode.AddChild('edit').NodeValue := 'true';
      tnode.AddChild('delete').NodeValue := 'true';
    end else if acs = 'e' then begin
      tnode.AddChild('view').NodeValue := 'true';
      tnode.AddChild('edit').NodeValue := 'true';
      tnode.AddChild('delete').NodeValue := 'false';
    end else if acs = 'v' then begin
      tnode.AddChild('view').NodeValue := 'true';
      tnode.AddChild('edit').NodeValue := 'false';
      tnode.AddChild('delete').NodeValue := 'false';
    end;
    tnode.AddChild('selfld').NodeValue := f;
    tnode.AddChild('opr').NodeValue := GetOperator(op);
    tnode.AddChild('val').NodeValue := dbm.gf.getnthstring(val,1);
    tnode.AddChild('bval').NodeValue := dbm.gf.getnthstring(val,2);
  end;
  tcnode:=nil;tnode:=nil;pnode:=nil;
end;

Function TAxProvider.GetOperator(s:String):String;
var
  exprstr,opr,v1,v2,fld,fldvalue :String;
begin
  exprstr := s;
  if exprstr = 'Less Than or Equal to' then Result := 'le';
  if exprstr = 'Greater Than or Equal to' then Result := 'ge';
  if exprstr = 'Not Equal to' then Result := 'ne';
  if exprstr = 'Equal to' then Result := 'eq';
  if exprstr = 'Less Than' then Result := 'lt';
  if exprstr = 'Greater Than' then Result := 'gt';
  if exprstr = 'Between' then Result := 'btw';
  if exprstr = 'Not Contains' then Result := 'notin';
  if exprstr = 'Contains' then Result := 'in';
  if exprstr = 'Is Empty' then Result := 'isempty';

  if exprstr = 'le' then Result := 'Less Than or Equal to';
  if exprstr = 'ge' then Result := 'Greater Than or Equal to';
  if exprstr = 'ne' then Result := 'Not Equal to';
  if exprstr = 'eq' then Result := 'Equal to';
  if exprstr = 'lt' then Result := 'Less Than';
  if exprstr = 'gt' then Result := 'Greater Than';
  if exprstr = 'btw' then Result := 'Between';
  if exprstr = 'notin' then Result := 'Not Contains';
  if exprstr = 'in' then Result := 'Contains';
  if exprstr = 'isempty' then Result := 'Is Empty';
end;

procedure TAxprovider.LoadIviewDetails(enode:ixmlnode;ivname:String);
var xml : ixmldocument;
    tenode,bnode,tnode : ixmlnode;
    i : integer;
    lview : Boolean;
begin
  dbm.gf.DoDebug.msg('Loading Iview Details');
  xml := GetStructure('iviews',ivname,'','');
  tenode := xml.DocumentElement;
  if tenode = nil then exit;
  tnode := tenode.ChildNodes.FindNode('comps');
  if tnode <> nil then begin
    bnode := enode.ChildNodes.FindNode('buttons');
    AddBtns(tnode,bnode);
  end;
  xml:=nil;tenode:=nil;bnode:=nil;tnode:=nil;
end;

function TAxProvider.AddViewControlDetails(enode,vnode:ixmlnode):String;
var i,j : Integer;
    pnode,cnode,tnode : ixmlnode;
    t,w,cType,view,enable : String;
begin
  try
    dbm.gf.DoDebug.msg('Adding ViewControlDetails');
    result := '';
    for i := 0 to enode.ChildNodes.Count - 1 do begin
      pnode := enode.ChildNodes[i];
      if (pnode.NodeName <> 'dcs') and (pnode.NodeName <> 'fields') and
         (pnode.NodeName <> 'buttons') then continue;
      if pnode.NodeName = 'dcs' then
        cType := 'd'
      else if pnode.NodeName = 'fields' then
        cType := 'f'
      else if pnode.NodeName = 'buttons' then
        cType := 'b';
      for j := 0 to pnode.ChildNodes.Count - 1 do begin
        cnode := pnode.ChildNodes[j];
        view := VarToStr(cnode.Attributes['view']);
        enable := VarToStr(cnode.Attributes['enable']);
        if (view = 'false') or (enable = 'false') then begin
          tnode := vnode.AddChild(cnode.NodeName);
          tnode.Attributes['c'] := cType;
          if view = 'false' then
            tnode.Attributes['a'] := 'h'
          else if enable = 'false' then
            tnode.Attributes['a'] := 'd';
        end;
      end;
    end;
  except on E : Exception do
     begin
       pnode:=nil;cnode:=nil;tnode:=nil;
       result :=  E.Message;
     end;
  end;
  pnode:=nil;cnode:=nil;tnode:=nil;
end;

function TAxProvider.AddTransControlDetails(enode,vnode:ixmlnode;transid:String):String;
var i,cnt : Integer;
    pnode,tnode,tcnode,fnode : ixmlnode;
    view,edit,delete,nName,fname : String;
    pxml : ixmldocument;
begin
  try
    dbm.gf.DoDebug.msg('Adding TransControlDetails');
    result := '';
    tcnode := enode.ChildNodes.FindNode('tcexpr');
    if tcnode = nil then exit;
    cnt := 1;
    pxml := GetStructure('tstructs',transid,'','');
    for i := 0 to tcnode.ChildNodes.Count - 1 do begin
      pnode := tcnode.ChildNodes[i];
      if VarToStr(pnode.ChildNodes['expr'].NodeValue) = '' then continue;
      view := lowercase(VarToStr(pnode.ChildNodes['view'].NodeValue));
      edit := lowercase(VarToStr(pnode.ChildNodes['edit'].NodeValue));
      delete := lowercase(VarToStr(pnode.ChildNodes['delete'].NodeValue));
      nName := 'l'+Trim(IntToStr(cnt));
      tnode := vnode.AddChild(nName);
      if view = 'false' then
        tnode.Attributes['a'] := 'n'
      else if edit = 'false' then
        tnode.Attributes['a'] := 'v'
      else if delete = 'false' then
        tnode.Attributes['a'] := 'e'
      else
        tnode.Attributes['a'] := 'd';

      fname := VarToStr(pnode.ChildNodes['selfld'].NodeValue);
      dbm.gf.DoDebug.msg('transntrol nodename '+fname);
      tnode.Attributes['f'] := fname;
      tnode.Attributes['op'] := GetOperator(VarToStr(pnode.ChildNodes['opr'].NodeValue));

      fnode := pxml.DocumentElement.ChildNodes.FindNode(fname);
      dbm.gf.DoDebug.msg('transntrol nodename '+fnode.NodeName);
      tnode.Attributes['d'] := lowercase(copy(vartostr(fnode.ChildNodes['xml_datatype'].NodeValue),1,1));

      if tnode.Attributes['op']='btw' then
        tnode.NodeValue := VarToStr(pnode.ChildNodes['val'].NodeValue)+','+VarToStr(pnode.ChildNodes['bval'].NodeValue)
      else
        tnode.NodeValue := VarToStr(pnode.ChildNodes['val'].NodeValue);
      cnt := cnt+1;
    end;
  except on E : Exception do
     begin
       pnode:=nil;tcnode:=nil;tnode:=nil;fnode:=nil;
       result :=  E.Message;
     end;
  end;
  pnode:=nil;tcnode:=nil;tnode:=nil;fnode:=nil;
end;

function TAxProvider.SaveAccessDetails(pxml:ixmldocument;rName,sName,sType:String):String;
var t,w : String;
    stm : TStringStream;
    s : WideString;
begin
  result := '';
  try
    dbm.gf.DoDebug.msg('Saving AccessTstruct Details');
    t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
    w:='rname '+'='+quotedstr(rname)+' and sname '+'='+quotedstr(sName)+' and stype = '+quotedstr(sType);
    x.Submit('rname',rName,'c');
    x.Submit('sname',sName,'c');
    x.Submit('stype',sType,'c');
    x.Submit('updatedon',t,'c');
    x.AddOrEdit('axuseraccess',w);
    x.Post;
    x.close;
    x.sqltext:='select props from axuseraccess where '+w;
    x.open;
    if not x.isempty then
    begin
      dbm.gf.DoDebug.msg('before creating tstringstream');
      s := pxml.XML.Text;
      stm := TStringStream.Create(s);
      dbm.gf.DoDebug.msg('after creating tstringstream');
      dbm.WriteMemo('props','axuseraccess',w, stm);
      dbm.gf.DoDebug.msg('after writememo');
      stm.Free;
    end;
    x.close;
//    result := 'success';
  except on E : Exception do
     begin
       x.close;
       result :=  E.Message;
       exit;
     end;
  end;
  result := 'done';
end;


procedure TAxProvider.AddConstraint(TableName, Constraints: String);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteAddConstraint(TableName,Constraints);
    exit;
  end;
  Try
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQlText := 'Alter table ['+ UpperCase(TableName) + '] add constraint ' + Constraints
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add Constraint ' + Constraints
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' add Constraint ' + Constraints;

    q.ExecSQL;
  Except
  on e:Exception do begin
    dbm.gf.DoDebug.msg('Error in AddConstraint '+E.Message);
    (*
      if e.Message = '' then
        ShowMessage('Not able to create constraint '''+Constraints+'''')
      else
        showmessage(e.Message);
    *)
   end;
  End;
end;

function TAxProvider.AddListViewControlDetails(enode,vnode:ixmlnode):String;
var i,j : Integer;
    cnode,tnode : ixmlnode;
    t,w,cType,view,enable : String;
begin
  result := '';
  try
    dbm.gf.DoDebug.msg('Adding ListViewControlDetails');
    result := '';
    for i := 0 to enode.ChildNodes.Count - 1 do begin
      cnode := enode.ChildNodes[i];
      view := VarToStr(cnode.Attributes['view']);
      enable := VarToStr(cnode.Attributes['enable']);
      if (view = 'false') or (enable = 'false') then begin
        tnode := vnode.AddChild(cnode.NodeName);
        tnode.Attributes['c'] := 'b';
        if view = 'false' then
          tnode.Attributes['a'] := 'h'
        else if enable = 'false' then
          tnode.Attributes['a'] := 'd';
      end;
    end;
  except on E : Exception do
     begin
       cnode:=nil;tnode:=nil;
       result :=  E.Message;
     end;
  end;
  cnode:=nil;tnode:=nil;
end;

procedure TAxProvider.CreateField(TableName,FName,DType:String;FWidth,FDec:Integer);
var JoinStr : String;
begin
  JoinStr := GetJoinStr(FName,DType,FWidth,FDec,False);
  Try
    ErrorStr :='';
    q.close;
    if dbm.Connection.DbType = 'access' then
        q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add ' + JoinStr
    else if dbm.Connection.DbType = 'ms sql' then
        q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add ' + JoinStr
    else
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' add ' + JoinStr;
    q.ExecSQL;
  Except on e:Exception do
    ErrorStr := e.Message;
  End;
  if ErrorStr<>'' then begin
     if ErrorStr = '' then begin
        dbm.gf.DoDebug.Msg('Not able to create field '''+JoinStr+'''');
        dbm.gf.DoDebug.Log('Not able to create field '''+JoinStr+'''');
     end
     else begin
        dbm.gf.DoDebug.Msg(ErrorStr);
        dbm.gf.DoDebug.Log(ErrorStr);
     end;
  end;
end;

Function TAxProvider.GetJoinStr(Fname,DType:String;Width,Dec :integer;ToModify:Boolean=False):string;
  var  Temp, s : string;
begin
  if dbm.Connection.DbType = 'access' then
    Temp := '[' + Fname + ']'
  else if dbm.Connection.DbType = 'ms sql' then
    Temp := '[' + Fname + ']'
  else if dbm.Connection.DbType = 'mysql' then
  begin
    (*
    schema is a reserved word in MYSQL , to handle that we enclosed the column name with backtick(`).
    Here we have handled only for schema , when it's required we may need to implement a separate
    function to check the keywords/reserved words.
    *)
    if lowercase(Fname) = 'schema' then
      Fname := '`'+Fname+'`';
    Temp := Fname
  end
  else
    Temp := Fname;
  if (dbm.Connection.DbType = 'postgre') and (ToModify) then
    Temp := Temp+' type ';
  if (uppercase(DType) = 'N') then
  begin
    if dbm.Connection.DbType = 'access' then begin
      If (Width<=5) And (Dec=0) Then Temp := Temp + '  INTEGER'
      Else  Temp := Temp + '  DOUBLE';
    end else begin
      s := '  NUMERIC('+inttostr(width)+ ',' + inttostr(dec)+')';
      Temp := Temp + s;
{     if dbm.Connection.DbType = 'mysql' then
        Temp := Temp + ' Default 0';}        //new
    end;
  end else if (uppercase(DType) = 'C') then begin
    if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  VARCHAR2('+inttostr(width)+')'
    else if dbm.Connection.DbType = 'mysql' then begin
    {*[MYSQL - supports 255 char length for varchar earlier [before ver 5.0.3] , later they changed to 65535]
      So we removed conditional statement which checks whether the char length is grater than 255 *}
      Temp := Temp + '  VARCHAR('+inttostr(width)+')';
    //  Temp := Temp + ' Default '''''; //new
    end else if dbm.Connection.DbType = 'access' then begin
      If width < 255 Then Temp := Temp + '  Text('+inttostr(width)+')'
      Else Temp := Temp + ' Memo';
    end else begin
      if dbm.gf.MsSql_Unicode_Char = 'N' then Temp := Temp + ' NVARCHAR('+inttostr(width)+')'
      else begin
        s := '  VARCHAR('+inttostr(width)+')';
        Temp := Temp + s ;
      end;
    end;
  end else if (uppercase(DType) = 'D') then begin
    //For mysql also DATETIME used instead of DATE , else we may get into pbm when setting default value now() or timestamp..
    if (dbm.Connection.DbType = 'ms sql') or ((dbm.Connection.DbType = 'mysql')) then
      Temp := Temp + '  DATETIME'
    else
    begin
      s := '  DATE';
      Temp := Temp +s;
    end;
    {if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' Default ''1900/01/01''';}//new
  end else if (uppercase(DType) = 'T') then begin
    if dbm.Connection.DbType = 'access' then
      Temp := Temp + ' Memo'
    else if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  NCLOB'//Temp + '  CLOB'
    else if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' Text ' //Default ''''' new
    else if dbm.Connection.DbType = 'ms sql' then begin
      if dbm.gf.MsSql_Unicode_Char = 'N' then Temp := Temp + ' NVARCHAR(MAX)'
      else Temp := Temp + '  VARCHAR(MAX)'
    end
    else
    begin
      s := '  Text';
      Temp := Temp +s;
    end;
  end else if (uppercase(DType) = 'I') then begin
    if dbm.Connection.DbType = 'access' then
      Temp := Temp + ' Memo'
    else if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  BLOB'
    else if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' BLOB ' //Default ''''' new
    else if dbm.Connection.DbType = 'postgre' then
    begin
      s := ' BYTEA ';
      Temp := Temp + s //Default ''''' new
    end
    else Temp := Temp + '  IMAGE';
  end;
  if (dbm.Connection.DbType = 'postgre') and (ToModify) then
    Temp := Temp+ ' USING '+Fname+'::'+s;
  Result := Temp;
end;

procedure TAxProvider.AlterMenu(xml:ixmlnode);
var i,j,toordno:integer;
    s, parent,name, cap, url, posn :String;
    x1:txds;
    flag:boolean;
begin
  parent:=vartostr(xml.Attributes['name']);
  dbm.gf.DoDebug.msg('parent='+parent);
  x1:=dbm.GetXDS(nil);
  x1.buffered:=true;
  if parent='axpertroot' then s:=' is null ' else s:='='+quotedstr(parent);
  x1.cds.CommandText:='select * from axpages where parent'+s+' order by ordno';
  x1.open;

  // Delete menu options found in database that are not found in param xml
  while not x1.cds.eof do begin
    name:=x1.CDS.fieldbyname('name').asstring;
    if name <> 'inbox' then begin
      dbm.gf.DoDebug.msg('Checking '+name);
      flag:=false;
      for i:=0 to xml.childnodes.count-1 do begin
        if lowercase(xml.ChildNodes[i].Attributes['name'])=lowercase(name) then begin
          flag:=true;
          break;
        end;
      end;
      if not flag then begin
        DeleteMenuOption(name);
      end;
    end;
    x1.cds.next;
  end;

  //Insert new menu options from xlml
  for i := 0 to xml.ChildNodes.count - 1 do begin
    cap:=vartostr(xml.childnodes[i].Attributes['target']);
    url:=vartostr(xml.childnodes[i].Attributes['url']);
    name:=vartostr(xml.childnodes[i].Attributes['name']);
    if name='' then begin
      j:=i+1;
      posn:='';
      while (j<xml.childnodes.count-1) do begin
        if vartostr(xml.childnodes[j].Attributes['name'])<>'' then begin
          posn:=vartostr(xml.childnodes[j].Attributes['name']);
          break;
        end;
        inc(j);
      end;
      addmenuoption(parent, posn, cap, url);
    end;
  end;

  //Rearrange menu options as given in the param xml

  //Fire SQL to get immediate children for given parent into dataset named children.
  if vartostr(xml.Attributes['move']) = 'True' then
  begin
    x1.close;
    x1.cds.CommandText:='select * from axpages where parent'+s+' and name <> ''inbox'' order by ordno';
    x1.open ;
    for i:=0 to xml.childnodes.count-1 do begin
      name:=xml.ChildNodes[i].Attributes['name'] ;
      dbm.gf.DoDebug.msg('Checking '+name);
      if lowercase(x1.CDS.fieldbyname('name').asstring) <> lowercase(name) then begin
        toordno := x1.CDS.FieldByName('ordno').AsInteger;
        dbm.gf.DoDebug.msg('Calling movemenu for  '+name);
        movemenu(name,toordno);
        dbm.gf.DoDebug.msg('movemenu for  ' + name + 'Completed');
        x1.close;
        x1.open;
        x1.CDS.Locate(x1.CDS.Fields[0].FieldName, name, [locaseinsensitive]);
      end;
      x1.cds.next;
    end;
  end;
  x1.close;
  x1.free;
end;


procedure TAxProvider.movemenu(ename : String ; toorderno : integer);
  var x1,q1:txds;
  pordno,nextno,plevelno,moveorder : integer;
begin
//get all the children under element
  x1:=dbm.getxds(nil);
  x1.buffered:=true;
  x1.CDS.CommandText := 'select ordno,levelno from axpages where name = ' + quotedstr(ename);
  x1.open;
  if not x1.cds.isempty then
  begin
     pordno := x1.CDS.FieldByName('ordno').AsInteger;
     plevelno := x1.CDS.FieldByName('levelno').AsInteger;
  end;
  dbm.gf.DoDebug.msg('Parent LevelNo  '+ inttostr(plevelno));
  dbm.gf.DoDebug.msg('Parent Ordno  '+ inttostr(pordno));
  //find the order no of next sibble of the given element
  x1.close;
  x1.CDS.CommandText := 'select min(ordno) mno from axpages where (levelno <= ' + quotedstr(inttostr(plevelno)) + ') and (ordno > ' + quotedstr(inttostr(pordno)) + ')';
  x1.open;
  nextno := x1.CDS.FieldByName('mno').AsInteger;
  if nextno = 0 then nextno :=100000 ;
  dbm.gf.DoDebug.msg('Next Sible  '+ inttostr(nextno));

  x1.close;
  x1.CDS.CommandText := 'select * from axpages where (ordno >= ' + quotedstr(inttostr(pordno)) + ') and (ordno < ' + quotedstr(inttostr(nextno)) + ')  order by ordno';
  x1.open;

  q1:=dbm.getxds(nil);
  while not x1.cds.eof do begin
    moveorder := x1.CDS.FieldByName('ordno').AsInteger;
    q1.SqlText:='update axpages set ordno=0 where ordno=' + quotedstr(inttostr(moveorder));
    q1.execsql;
    q1.SqlText:='update axpages set ordno=ordno-1 where ordno >=' +  quotedstr(inttostr(moveorder));
    q1.execsql;
    q1.SqlText:='update axpages set ordno=ordno+1 where ordno >=' +  quotedstr(inttostr(toorderno));
    q1.execsql;
    q1.SqlText:='update axpages set ordno= ' + quotedstr(inttostr(toorderno)) + ' where ordno = 0';
    q1.execsql;
    toorderno:=toorderno+1 ;
    x1.cds.Next;
  end ;
  q1.close;
  q1.Free;
  x1.close;
  x1.Free;
end;

procedure TAxprovider.Deletemenuoption(name:String);
var x1,q1:txds;
    level,sord,eord,cnt:integer;
begin
  dbm.gf.DoDebug.msg('deleting '+name);
  x1:=dbm.getxds(nil);
  x1.buffered:=true;
  x1.CDS.CommandText:='select * from axpages order by ordno';
  x1.open;
  if x1.cds.isempty then begin
    x1.close;
    x1.free;
    exit;
  end;
  sord:=-1;eord:=-1;
  while not x1.cds.eof do begin
    if lowercase(x1.cds.fieldbyname('name').asstring)=lowercase(name) then begin
      level:=x1.cds.fieldbyname('levelno').asinteger;
      sord:=x1.cds.fieldbyname('ordno').asinteger;
      eord:=sord;
      break;
    end;
    x1.cds.next;
  end;
  x1.cds.next;
  dbm.gf.DoDebug.msg('sord='+inttostr(eord)+' eord='+inttostr(eord));
  cnt:=1;
  while not x1.cds.eof do begin
    if x1.cds.fieldbyname('levelno').asinteger<=level then
      break;
    eord:=x1.cds.fieldbyname('ordno').asinteger;
    inc(cnt);
    x1.cds.next;
  end;
  dbm.gf.DoDebug.msg('sord='+inttostr(eord)+' eord='+inttostr(eord)+' cnt='+inttostr(cnt));
  x1.close;
  x1.free;

  if sord=-1 then exit;

  q1:=dbm.getxds(nil);
  q1.sqltext:='delete from axpages where ordno>='+inttostr(sord)+' and ordno<='+inttostr(eord);
  q1.execsql;

  q1.sqltext:='update axpages set ordno=ordno-'+inttostr(cnt)+' where ordno>'+inttostr(sord);
  q1.execsql;

  q1.free;
end;

procedure TAxprovider.Addmenuoption(parent, posn, cap, url:String);
var q,x:txds;
    level,ono,c:integer;
    s,name,typ:String;
    flag:boolean;
begin
  if parent='axpertroot' then parent:='';
  dbm.gf.DoDebug.msg('adding '+cap+' under '+ parent+' at '+posn);

  x:=dbm.getxds(nil);
  x.buffered:=true;
  x.cds.commandtext:='select * from axpages where name <> ''inbox'' order by ordno';
  x.open;
  if x.cds.IsEmpty then begin
    level:=0;
    ono:=1;
  end else begin
    level:=-1;
    flag:=false;
    while not x.cds.eof do begin
      dbm.gf.DoDebug.msg('posn='+posn+' level '+inttostr(level)+' ono '+inttostr(ono)+x.cds.fieldbyname('name').asstring+' parent='+parent);
      if (posn='') and (x.cds.fieldbyname('levelno').asinteger<=level) then begin
        ono:=x.cds.fieldbyname('ordno').asinteger;
        level:=level+1;
        flag:=true;
        break;
      end;
      if lowercase(x.cds.fieldbyname('name').asstring)=lowercase(posn) then begin
        level:=x.cds.fieldbyname('levelno').asinteger;
        ono:=x.cds.fieldbyname('ordno').asinteger;
        flag:=true;
        break;
      end;
      if uppercase(x.cds.fieldbyname('name').asstring)=uppercase(parent) then begin
        level:=x.cds.fieldbyname('levelno').asinteger;
      end;
      x.cds.next;
    end;
    dbm.gf.DoDebug.msg('posn='+posn+' level '+inttostr(level)+' ono '+inttostr(ono)+x.cds.fieldbyname('name').asstring+' parent='+parent);
    if level=-1 then begin
     level:=0;
     ono:=x.cds.RecordCount+1;
    end else if not flag then begin
     dbm.gf.DoDebug.msg(x.cds.fieldbyname('caption').asstring+'level = '+inttostr(level));
     inc(level);
     ono:=x.cds.fieldbyname('ordno').asinteger+1;
    end;
  end;
  dbm.gf.DoDebug.msg('level='+inttostr(level)+' ordno='+inttostr(ono));

  c := findcountno;
  if url='' then begin
    name := 'Head' + inttostr(c);
    typ:='h';
  end else begin
    name := 'Page' + inttostr(c);
    typ:='p';
  end;

  q:=dbm.GetXDS(nil);
  q.sqltext:='update axpages set ordno=ordno+1 where ordno>='+inttostr(ono);
  q.execsql;

  s := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
//  s:=findandreplace(dbdatestring, ':value', s);
  q.SqlText:='insert into axpages (name, caption, levelno, blobno, visible,pagetype, type, parent, ordno, updatedon, props) values ';
  q.sqltext:=q.sqltext+'('+quotedstr(name)+','+quotedstr(cap)+','+inttostr(level)+',1,'+quotedstr('T') +',' +quotedstr('web')+','+quotedstr(typ)+','+quotedstr(parent)+','+inttostr(ono)+','+quotedstr(s)+','+quotedstr(url)+')';
  q.execsql;
  SavetoUserAccess(name); //add page access in user access control..
  q.free;
end;

{procedure TAxProvider.AlterMenu(xml : ixmlnode);
  var n,onode,newn,ordn,deln,n1 : ixmlnode;
  c , i , j , k : integer;
  name,cap,url,parent,wtype : String;
  pxml : ixmlnode;
  found : boolean;
  tmpxml : ixmldocument;
begin
  dbm.gf.DoDebug.Msg('Node for order change : ' + xml.XML);
  tmpxml := loadxmldata('<root></root>');
  onode := tmpxml.DocumentElement;
  newn := onode.AddChild('new');
  deln := onode.AddChild('delete');
  ordn := onode.AddChild('order');
  pxml := MultiLevelMenuXML.DocumentElement ;
  dbm.gf.DoDebug.Msg('Exiting order XML : ' + pxml.XML);
  parent := vartostr(xml.Attributes['target']);
  dbm.gf.DoDebug.Msg('Parent Name : ' + parent);
  for i := 0 to pxml.ChildNodes.Count - 1 do
  begin
    if parent = vartostr(pxml.ChildNodes[i].Attributes['target']) then
    begin
      j := i;
      n := pxml.ChildNodes[i];
      break;
    end;
  end;
//  pxml.ChildNodes.Delete(j);
//  pxml.ChildNodes.Insert(j,xml);
//  dbm.gf.DoDebug.Msg('Changed order XML : ' + pxml.XML);
//  fiding deleted nodes
  if assigned(n) then
  begin
    dbm.gf.DoDebug.Msg('Selected Node : ' + n.XML);
    for i := 0 to n.ChildNodes.Count - 1 do
    begin
      name := vartostr(n.ChildNodes[i].Attributes['target']);
      found := false;
      for j := 0 to xml.ChildNodes.Count - 1 do
      begin
         if name = vartostr(xml.ChildNodes[j].Attributes['target'])then
         begin
           found := true;
           break;
         end;
      end;
      if found = false then deln.ChildNodes.Add(n.ChildNodes[i])
    end;
  end;
  dbm.gf.DoDebug.Msg('Node for deletion: ' + deln.XML);
  //fiding added nodes
  if assigned(n) then
  begin
    for i := 0 to xml.ChildNodes.Count - 1 do
    begin
      name := vartostr(xml.ChildNodes[i].Attributes['target']);
      found := false;
      for j := 0 to n.ChildNodes.Count - 1 do
      begin
         if name = vartostr(n.ChildNodes[j].Attributes['target'])then
         begin
           found := true;
           break;
         end;
      end;
      if found = false then newn.ChildNodes.Add(xml.ChildNodes[i]);
    end;
  end else newn := xml ;
  dbm.gf.DoDebug.Msg('Node for addition: ' + newn.XML);
  //creating order node
  for i := 0 to pxml.ChildNodes.Count - 1 do
  begin
    n := pxml.ChildNodes[i];
    ordn.ChildNodes.Add(n.CloneNode(false));
    if parent = vartostr(pxml.ChildNodes[i].Attributes['target']) then n := xml;
    if n.HasChildNodes then
    begin
      for j := 0 to n.ChildNodes.Count - 1 do
      begin
         n1 := n.ChildNodes[j];
         ordn.ChildNodes.Add(n1.CloneNode(false));
         if n1.HasChildNodes then
         begin
            for k := 0 to  n1.ChildNodes.Count - 1 do
            begin
              ordn.ChildNodes.Add(n1.ChildNodes[k].CloneNode(false));
            end;
         end;
      end;
    end;
  end;
  if parent = '' then
  begin
    for i := 0 to xml.ChildNodes.Count - 1 do
    begin
      ordn.ChildNodes.Add(xml.ChildNodes[i]);
    end;
  end;
  dbm.gf.DoDebug.Msg('Node for Ordering: ' + ordn.XML);
  dbm.gf.DoDebug.Msg('Changed XML : ' + tmpxml.DocumentElement.XML);
  n := newn;
  onode := ordn;
  if assigned(n) then
  begin
    if n.ChildNodes.Count > 0 then
    begin
       c := findcountno;
       for i := 0 to n.ChildNodes.Count - 1 do
       begin
         url := vartostr(n.ChildNodes[i].Attributes['url']);
         if url = '' then
         begin
            name := 'Head' + inttostr(c) ;
            wtype := 'h'
         end else
         begin
            name := 'Page' + inttostr(c);
            wtype := 'p'
         end;
         parent := vartostr(n.ChildNodes[i].Attributes['target']);
         cap := vartostr(n.ChildNodes[i].Attributes['name']);
         ExecSQL('insert into axpages(name,caption,parent,type,props,webpage,blobno) values (' +  quotedstr(name) + ',' + quotedstr(cap) + ',' + quotedstr(parent) + ',' + quotedstr(wtype) + ',' + quotedstr(url) + ',' + quotedstr('Y') + ','  + quotedstr('1') + ')' + '','','',false );
         SavetoUserAccess(name); //add page access in user access control..
         c := c + 1;
         if assigned(onode) then
         begin
           for j := 0 to onode.ChildNodes.Count - 1 do
           begin
             if (vartostr(onode.ChildNodes[j].Attributes['name']) = cap) and
                (vartostr(onode.ChildNodes[j].Attributes['url']) = url) then
             begin
                onode.ChildNodes[j].Attributes['target'] := name;
                break;
             end;
           end;
         end;
       end;
    end;
  end;
  n := deln;
  if assigned(n) then
  begin
    if n.ChildNodes.Count > 0 then
    begin
       for i := 0 to n.ChildNodes.Count - 1 do
       begin
         parent := vartostr(n.ChildNodes[i].Attributes['parent']);
         name := vartostr(n.ChildNodes[i].Attributes['name']);
         cap := vartostr(n.ChildNodes[i].Attributes['name']);
         ExecSQL('delete from axpages where name = ' + quotedstr(name),'','',false);
         RemoveUserAccess(name);
       end;
    end;
  end;
  if assigned(onode) then
  begin
    updatePageOrder(onode);
  end;
end;

procedure TAxProvider.updatePageOrder(n : ixmlnode) ;
  var wlevelno,i,wordno : integer;
  tn,pnode : ixmlnode;
  pn,wparent,wtype,cap : String;
begin
  dbm.gf.DoDebug.Msg('Updating Pageorder');
  wlevelno := 0;
  wordno := 0;
  dbm.gf.DoDebug.Msg('Order XML : ' + n.XML);
  for i := 0 to n.ChildNodes.Count-1 do
  begin
    wordno := wordno + 1;
    tn := n.ChildNodes[i];
    pn := vartostr(tn.Attributes['target']);
    cap := vartostr(tn.Attributes['name']);
    if lowercase(copy(vartostr(tn.Attributes['target']),1,4)) = 'head' then
    begin
       wparent := vartostr(tn.Attributes['target']);
       wtype := 'h'
    end else wtype := 'p';
    wlevelno := 0;
    if vartostr(tn.Attributes['level']) <> '' then
       wlevelno := strtoint(vartostr(tn.Attributes['level']));
    ExecSQL('update axpages set type = ' + quotedstr(wtype) + ',parent = ' + quotedstr(wparent) + ',ordno = ' + quotedstr(inttostr(wordno)) + ',levelno = ' + quotedstr(inttostr(wlevelno)) + ' where name = ' + quotedstr(pn),'','',true);
  end;
end;}

function TAxProvider.findcountno : integer;
var
  xQry : TXDS;
  i ,p,c: integer;
  hd,tmpstr,s : String;
begin
 result := 0;
 c:=0;
 xQry:=dbm.GetXDS(nil);
 xQry.buffered := True;
 xQry.CDS.CommandText := 'select name,caption from axpages';
 xQry.open;
 xQry.CDS.First;
 while not xQry.CDS.eof do begin
   s:= xQry.CDS.FieldByName('name').AsString;
   p := length(xQry.CDS.FieldByName('name').AsString);
   tmpstr :=  trim(lowercase(copy(s,1,4)));
   if (tmpstr = 'head') or (tmpstr = 'page') then
   begin
       s := copy(s,1,p);
       delete(s,1,4);
       s := trim(s);
     try
       if strtoint(s) > 0 then
       begin
         p := strtoint(s);
       end;
     except on e:exception do begin
       xQry.CDS.Next;
       continue ;
     end;
     end;
     if p > c then c := p;
   end;
   xQry.CDS.Next;
 end;
 result := c + 1;
end;

procedure TAxProvider.SavetoUserAccess(pagename : String);
var  i : integer;
    xQry : TXDS;
    r,sqltext,s : String;
begin
  xQry := dbm.GetXDS(nil);
  xQry.buffered := True;
  i := 1;
  r := dbm.gf.getnthstring(dbm.gf.userroles,i);
  while r<>'' do
  begin
    if r = 'default' then
    begin
      inc(i);
      r := dbm.gf.getnthstring(dbm.gf.userroles,i);
      continue;
    end;
    try
      sqltext := 'insert into axuseraccess(rname,sname,stype,blobno) values (' + quotedstr(r) + ',' + quotedstr(trim(pageName)) + ',' + quotedstr('p') + ',' + quotedstr('1') + ')';
      xQry.CDS.CommandText := sqlText;
      if dbm.gf.remotelogin then
        xQry.open
      else
        xQry.execsql;
      dbm.gf.DoDebug.Msg('Firing SQL '+ sqltext+' <OK>');
      inc(i);
      r := dbm.gf.getnthstring(dbm.gf.userroles,i);
    Except on e:exception do
      begin
        s := 'Firing SQL '+ sqltext +' <error> '+E.Message ;
        dbm.gf.DoDebug.Msg('Firing SQL '+ sqltext +' <error> '+E.Message);
        inc(i);
        r := dbm.gf.getnthstring(dbm.gf.userroles,i);
      end;
    end;
  end;
  xQry.Free;
end;

procedure TAxProvider.RemoveUserAccess(fPageName : String);
var  xQry : TXDS;
     sqltext,s : String;
begin
  xQry := dbm.GetXDS(nil);
  xQry.buffered := True;
  try
   xQry.CDS.CommandText := 'delete from axuseraccess where stype = ''p'' and sname = ' + quotedstr(trim(fPageName));
   if dbm.gf.remotelogin then
     xQry.open
   else
     xQry.execsql;
   Except on e:exception do
      begin
        s := 'Firing SQL '+ sqltext +' <error> '+E.Message ;
        dbm.gf.DoDebug.Msg('Firing SQL '+ sqltext +' <error> '+E.Message);
      end;
   end;
   xQry.Free;
end;

function TAxProvider.GetPrintTemplate(sname,pname,fname:String) : String;
var  w,tdate,fdate,fn : String;
begin
  if not DirectoryExists(dbm.gf.StartPath+'\Docs') then CreateDir(dbm.gf.StartPath+'\Docs');
  fn:=dbm.gf.startpath+'\Docs\'+fname ;
  if not fileexists(fn) then
  begin
     w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(pname));
     dbm.ReadBlob('template','prints',w,fn);
  end ;
end;

function TAxProvider.GetAllWorkFlowTStructs: IXMLDocument;
  var i : integer;
  stype,s : String;
begin
  stype := 't';
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption,workflow from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow) = ''t'' order by ' + dbm.gf.sqllower + '(caption)'
  else  begin
    x.sqltext:='select name,caption from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow)=''t'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
  end;
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
end;

Procedure TAxProvider.Deletefields(TableName,FieldName: String);
  var  sqlstring : String;
begin

  if dbm.Connection.DbType = 'paradox' then
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop ' +FieldName
  else if dbm.Connection.DbType = 'ms sql' then
     sqlstring := 'Alter table ['+ UpperCase(TableName) + '] Drop Column [' +FieldName + ']'
  else if dbm.Connection.DbType = 'access' then
     sqlstring := 'Alter table ['+ UpperCase(TableName) + '] Drop Column [' +FieldName + ']'
  else if dbm.Connection.DbType = 'mysql' then
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop Column ' +FieldName
  else
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop Column ' +FieldName ;
  Try
    q.Close;
    q.SQLText := sqlstring;
    q.ExecSQL;
  Except on e:exception do
    begin
      sqlstring := e.Message ;
      if dbm.Connection.DbType = 'paradox' then
        if (pos(LowerCase('table does not exist'),LowerCase(sqlstring)) = 0) and (pos(LowerCase('field not found in table'),LowerCase(sqlstring)) = 0) then
           dbm.gf.DoDebug.Msg('Not able to drop field '''+FieldName+''''+#13+e.Message)// ShowMessage('Not able to drop field '''+FieldName+''''+#13+e.Message)
        else if pos(LowerCase('invalid column name'),LowerCase(sqlstring)) = 0 then
           dbm.gf.DoDebug.Msg('Not able to drop field '''+FieldName+''''+#13+e.Message);   //ShowMessage('Not able to drop field '''+FieldName+''''+#13+e.Message);

    sqlstring := '';
    end;
  End
end;

Function  TAxprovider.SetAppProps(enode:ixmlnode):String;
Var pxml : ixmldocument;
    PropsNode,MailNode,TempNode : ixmlnode;
    TimeStr,WhereCond : String;
    stm : TStringStream;
    TempStr : WideString;
Begin
  result := 'done';
  dbm.gf.DoDebug.msg('Saving Application Properties');
  try
    pxml := Getstructure('axprops','app','app','');
    PropsNode := pxml.documentelement.ChildNodes['props'];
    MailNode := PropsNode.ChildNodes['mail'];

    TempNode := enode.ChildNodes.FindNode('host');
    if TempNode = nil then
      MailNode.ChildNodes['host'].NodeValue := ''
    else
      MailNode.ChildNodes['host'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := enode.ChildNodes.FindNode('port');
    if TempNode = nil then
      MailNode.ChildNodes['port'].NodeValue := ''
    else
      MailNode.ChildNodes['port'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := enode.ChildNodes.FindNode('userid');
    if TempNode = nil then
      MailNode.ChildNodes['userid'].NodeValue := ''
    else
      MailNode.ChildNodes['userid'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := enode.ChildNodes.FindNode('password');
    if TempNode = nil then
      MailNode.ChildNodes['password'].NodeValue := ''
    else
      MailNode.ChildNodes['password'].NodeValue := VarToStr(TempNode.NodeValue);

    TimeStr := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
    WhereCond:='name '+'='+quotedstr('app');
    x.Submit('name','app','c');
    x.Submit('updatedon',TimeStr,'c');
    x.Submit('updusername',dbm.gf.UserName,'c');
    x.AddOrEdit('axprops',WhereCond);
    x.Post;
    x.close;
    x.sqltext:='select props from axprops where '+WhereCond;
    x.open;
    if not x.isempty then
    begin
      TempStr := pxml.XML.Text;
      stm := TStringStream.Create(TempStr);
      dbm.WriteMemo('props','axprops',WhereCond, stm);
      stm.Free;
    end;
    x.close;
    PropsNode:=nil;MailNode:=nil;TempNode:=nil;pxml:=nil;    
  Except
    On E:Exception do begin
       result := '<error> '+E.Message;
       PropsNode:=nil;MailNode:=nil;TempNode:=nil;pxml:=nil;
       Raise Exception.Create(E.Message);
    end;
  End;
End;


Function  TAxprovider.GetAppProps:IXMLDocument;
Var pxml : ixmldocument;
    PropsNode,MailNode,RMailNode,TempNode : ixmlnode;
Begin
  dbm.gf.DoDebug.msg('Getting Application Properties');
  Result := LoadXMLData('<root></root>');
  RMailNode := Result.DocumentElement.AddChild('row');
  RMailNode.Attributes['caption'] := 'Mail Settings';
  try
    pxml := Getstructure('axprops','app','app','');
    PropsNode := pxml.documentelement.ChildNodes.FindNode('props');
    if PropsNode = nil then exit;
    MailNode := PropsNode.ChildNodes.FindNode('mail');
    if MailNode = nil then exit;
    TempNode := MailNode.ChildNodes.FindNode('host');
    if TempNode = nil then
      RMailNode.ChildNodes['host'].NodeValue := ''
    else
      RMailNode.ChildNodes['host'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := MailNode.ChildNodes.FindNode('port');
    if TempNode = nil then
      RMailNode.ChildNodes['port'].NodeValue := ''
    else
      RMailNode.ChildNodes['port'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := MailNode.ChildNodes.FindNode('userid');
    if TempNode = nil then
      RMailNode.ChildNodes['userid'].NodeValue := ''
    else
      RMailNode.ChildNodes['userid'].NodeValue := VarToStr(TempNode.NodeValue);

    TempNode := MailNode.ChildNodes.FindNode('password');
    if TempNode = nil then
      RMailNode.ChildNodes['password'].NodeValue := ''
    else
      RMailNode.ChildNodes['password'].NodeValue := VarToStr(TempNode.NodeValue);
    PropsNode:=nil;MailNode:=nil;TempNode:=nil;RMailNode:=nil;pxml:=nil;
  Except
    On E:Exception do begin
       PropsNode:=nil;MailNode:=nil;TempNode:=nil;RMailNode:=nil;pxml:=nil;
       Raise Exception.Create(E.Message);
    end;
  End;
End;

function TAxProvider.GetObject(sname,fname,where :String ):String;
var w : String;
    GetImgExtn , s: String;
begin
  result := '';
  try
    x.close;
    x.SqlText:='select ftype from '+sname+' where '+ where;
    x.open;
    if not x.isempty then
    begin
        if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
        GetImgExtn := x.fieldbyname('ftype').AsString;
        s := dbm.gf.StartPath + '\' + fname + '.' + GetImgExtn;
        dbm.ReadBlob(fname , sname , where , s);
        result := s;
        result := 'openfile,'+s;
    end;
  except on E : Exception do
    result :=  E.Message;
  end;
end;

function TAxProvider.GetResponsibilityList(resp,active,page,struct : String) : IXMLDocument;
  var enode,cnode : IXMLNode;
      act,nName,uroles,s,ur,r,w,p,wor,ar,sqltext,par,tar :String;
      i,j,cnt : integer;
begin
  x.buffered := true; // Only in UM, x making buffered for pagination in mysql
  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  w := '';
  if (resp = '') and (page = '') and (struct = '') then
  begin
     sqltext := 'select rname,sname,actflag,stype from axuseraccess ';
  end else
  begin
     if resp <> '' then
     begin
       resp := '%' + lowercase(resp) + '%';
       w := dbm.gf.sqllower+'(rname) like ' + quotedstr(resp)
     end;
     if page <> '' then
     begin
        page := page + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(page,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+ '(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from axpages where ' + p  ;
        x.close;
        x.CDS.CommandText := sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          if w <> '' then w := w + ' or (sname in (' + p + ') and stype = ''p'') '
          else w := ' (sname in (' + p + ') and stype = ''p'')';
        end;
     end;
     p := '';
     if struct <> '' then
     begin
        struct := struct + ',';
        i := 1;
        while true do
        begin
          s := dbm.gf.GetnthString(struct,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+ '(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from tstructs where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          if w <> '' then w := w + ' or (sname in (' + p + ') and stype = ''t'')'
          else w := ' (sname in (' + p + ') and stype = ''t'')';
        end;
     end;
     if w <> '' then sqltext := 'select rname,sname,actflag,stype from axuseraccess '
     else exit;
  end;
  x.close;
  dbm.gf.dodebug.msg('Pagination page no ' + inttostr(dbm.gf.pagination_pageno));
  if active <> '' then
  begin
    if w <> '' then w := ' where ' + w + ' and ' + dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active))
    else w := ' where ' + dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active)); //new sqlnull is added in query
  end else
  begin
    if w <>'' then w := ' where '+w;  //new add where String in w if it is not empty
  end;
  if dbm.gf.pagination_pageno = 1 then
  begin
     if w <> '' then
        s := 'select distinct rname from axuseraccess ' + w + ' order by '+dbm.gf.sqllower+'(rname)'
     else
        s := 'select distinct rname from axuseraccess order by rname' ;
     s := dbm.ChangeSqlForPagination(s,true);
     x.CDS.CommandText := s;
     x.open;
     dbm.gf.pagination_totalrows := x.CDS.FieldByName('recno').AsInteger;
     x.close;
  end;
  // to find records from sno to eno in pagination
  if w <> '' then
    s := 'select distinct rname from axuseraccess ' + w
  else
    s := 'select distinct rname from axuseraccess order by rname' ;
  s := ChangeSqlForUMPagination(s);
  x.CDS.CommandText := s;
  x.open;
  s := Quotedstr('')+','; // new
  while not x.CDS.eof do
  begin
    s := s + quotedstr(x.CDS.fieldbyname('rname').AsString) + ',';
    x.CDS.next;
  end;
  i := length(s);
  r := copy(s,i,1);
  if r = ',' then delete(s,i,1);
  //-----
//  sqlText := dbm.ChangeSqlForPagination(sqlText,false);
  if w <> '' then
    w := w + ' and rname in ( ' + s + ')'
  else w := ' where rname in ( ' + s + ')';
  x.close;
  x.CDS.CommandText := sqlText + w + 'order by '+dbm.gf.sqllower+'(rname),'+dbm.gf.sqllower+'(stype),'+dbm.gf.sqllower+'(sname)';
  x.open;
  if dbm.gf.pagination_totalrows > 0 then enode.Attributes['totalrows'] := inttostr(dbm.gf.pagination_totalrows);
  if x.CDS.isempty then exit;
  while not x.CDS.eof do
  begin
    cnode := enode.addchild('row');
    uroles := x.CDS.fieldbyname('rname').AsString;
    cnode.AddChild('res').NodeValue := uroles;
    act := x.CDS.fieldbyname('actflag').AsString;
    if act = '' then act := 'Y';
    {if x.CDS.fieldbyname('stype').AsString = 'p'  then
       par := quotedstr(x.CDS.fieldbyname('sname').AsString)              In cds,rname has count as "1" the rname won't be added in result xml
    else if x.CDS.fieldbyname('stype').AsString = 't' then
       tar := quotedstr(x.CDS.fieldbyname('sname').AsString);
    x.CDS.next; }
    cnt := 1;
    par := '';
    tar := '';
    if (not x.CDS.eof) and (x.CDS.fieldbyname('rname').AsString =  uroles) then    //new not eof condition is added
    begin
      while not x.CDS.eof do
      begin
        if x.CDS.fieldbyname('stype').AsString = 'p'  then
        begin
           if par <> '' then par := par + ',' + quotedstr(x.CDS.fieldbyname('sname').AsString)
           else  par := quotedstr(x.CDS.fieldbyname('sname').AsString)
        end else if x.CDS.fieldbyname('stype').AsString = 't' then
        begin
           if tar <> '' then tar := tar + ',' + quotedstr(x.CDS.fieldbyname('sname').AsString)
           else  tar := quotedstr(x.CDS.fieldbyname('sname').AsString)
        end;
        x.CDS.next;
        if (x.CDS.eof) or (x.CDS.fieldbyname('rname').AsString <>  uroles) then break; // new not eof condition is added
        inc(cnt);
        if cnt > 999 then begin   //breaking this loop if vars 'par or 'tar' is >=1000 to avoid oracle error(not allowing morethan 1000 items in 'in' clouse. //going with this logic is because it just shwing 10 comma seperated page caption for each responcibility in .NET for displaying purpose.
         while ((not x.CDS.eof) and (x.CDS.fieldbyname('rname').AsString = uroles)) do begin
           x.CDS.next;  //  In CDS  rname count >=1000 the loop will break but still cds continue with same rname. ex: rname='rep1' with count 1200, so the loop will break in 1000 but again continue with 1001 count
         end;
         break;
        end;
      end;
    end;
    q.close;
    s := '';
    if par <> '' then
    begin
      i := length(par);
      r := copy(par,i,1);
      if r = ',' then delete(par,i,1);
      s := 'select caption from axpages where name in (' + par + ')';
    end else if tar <> '' then begin
      i := length(tar);
      r := copy(tar,i,1);
      if r = ',' then delete(tar,i,1);
      s := 'select caption from tstructs where name in (' + tar + ')' ;
    end;
    i := 1;
    ar := '';
    if s <> '' then
    begin
      q.SqlText := s;
      q.open;
      while not q.eof do
      begin
        if i <= 10 then ar := ar + q.fieldbyname('caption').AsString + ', '
        else break;
        q.next;
        inc(i);
      end;
    end;
    i := length(ar);
    r := copy(ar,i,1);
    if r = ',' then delete(ar,i,1);
    cnode.AddChild('ar').nodevalue := ar;
    cnode.AddChild('more').NodeValue := 'yes';
    cnode.AddChild('act').NodeValue := act;
  end;
  x.close;
end;

function TAxProvider.GetRolesList(roles,active,resp,page,struct : String) : IXMLDocument;
  var enode,cnode : IXMLNode;
      act,nName,uroles,s,ur,r,w,p,wor,sqltext :String;
      i,j : integer;
begin
  x.buffered := true; // Only in UM, x making buffered for pagination in mysql
  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  w := '';
  if (roles = '') and (resp = '') and (page = '') and (struct = '') then
  begin
     sqltext := 'select groupname,userroles,actflag from axusergroups ';
  end else
  begin
     if roles <> '' then
     begin
       roles := '%' + lowercase(roles) + '%';
       w := dbm.gf.sqllower+'(groupname) like ' + quotedstr(roles)
     end;
     if resp <> '' then
     begin
        resp := resp + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(resp,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        if w <> '' then w := w + ' or ' + p
        else w := p;
     end;
     if page <> '' then
     begin
        page := page + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(page,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+'(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from axpages where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' sname in (' + p + ') and stype = ''p''';
          sqltext := 'select rname from axuseraccess where ' + p + ' order by '+dbm.gf.sqllower+'(rname)';
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          while not x.CDS.eof do
          begin
            s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr('%'+lowercase(x.CDS.fieldbyname('rname').AsString)+'%') ;
            p := p + s + ' or ';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i-3,3);
          if r = ' or' then delete(p,i-3,3);
          if w <> '' then w := w + ' or ' + p
          else w := p;
        end;
     end;
     p := '';
     if struct <> '' then
     begin
        struct := struct + ',';
        i := 1;
        while true do
        begin
          s := dbm.gf.GetnthString(struct,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+'(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from tstructs where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' sname in (' + p + ') and stype = ''t''';
          sqltext := 'select rname from axuseraccess where ' + p + ' order by '+dbm.gf.sqllower+'(rname)';
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          while not x.CDS.eof do
          begin
            s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr('%'+lowercase(x.CDS.fieldbyname('rname').AsString)+'%') ;
            p := p + s + ' or ';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i-3,3);
          if r = ' or' then delete(p,i-3,3);
          if w <> '' then w := w + ' or ' + p
          else w := p;
        end;
     end;
     if w <> '' then sqltext := 'select  groupname,userroles,actflag from axusergroups '
     else exit;
  end;
  x.close;
  if w <> '' then w := ' where ' + w + ' and ' + dbm.gf.sqllower + '(groupname) <> ' + quotedstr('default')
  else w := ' where ' + dbm.gf.sqllower + '(groupname) <> ' +  quotedstr('default') ;
  dbm.gf.dodebug.msg('Pagination page no ' + inttostr(dbm.gf.pagination_pageno));
  if active <> '' then //new code active was not handled
  begin
    if w <> '' then begin
      if pos('where',lowercase(w)) = 0 then w :=  ' where ' + w;
      w :=  w + ' and ' + dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active));
    end
    else begin
      if pos('where',lowercase(w)) = 0 then w :=  ' where ' + w ;
      w := dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active)); //new sqlnull is added in query
    end;
  end;
  if dbm.gf.pagination_pageno = 1 then
  begin
     if w <> '' then
        s := 'select groupname from axusergroups ' + w + ' order by '+dbm.gf.sqllower+'(groupname)'
     else
        s := 'select groupname from axusergroups order by groupname' ;
     s := dbm.ChangeSqlForPagination(s,true);
     x.CDS.CommandText := s;
     x.open;
     dbm.gf.pagination_totalrows := x.CDS.FieldByName('recno').AsInteger;
     x.close;
  end;
  sqlText := sqlText + w + ' order by '+dbm.gf.sqllower+'(groupname)';
  sqlText := dbm.ChangeSqlForPagination(sqlText,false);
  x.CDS.CommandText := sqltext;
  x.open;
  if x.CDS.isempty then exit;
  while not x.CDS.eof do
  begin
//    if x.fieldbyname('groupname').AsString = 'default' then
//    begin
//      pagination_totalrows := pagination_totalrows - 1;
//      x.next;
//      continue;
//    end;
    cnode := enode.addchild('row');
    uroles := x.CDS.fieldbyname('groupname').AsString;
    cnode.AddChild('roles').NodeValue := uroles;
    act := x.CDS.fieldbyname('actflag').AsString;
    if act = '' then act := 'Y';
    cnode.AddChild('res').NodeValue := x.CDS.fieldbyname('userroles').AsString;;
    cnode.AddChild('act').NodeValue := act;
    x.CDS.next;
  end;
  if dbm.gf.pagination_totalrows > 0 then enode.Attributes['totalrows'] := inttostr(dbm.gf.pagination_totalrows);
  x.close;
end;

function TAxProvider.GetUsersList(user,roles,active,resp,page,struct : String) : IXMLDocument;
  var enode,cnode : IXMLNode;
      act,nName,uroles,s,ur,r,w,p,wor,sqltext,ar :String;
      i,j : integer;
begin
  x.buffered := true; // Only in UM, x making buffered for pagination in mysql
  result:=LoadXMLData('<root></root>');
  enode := result.DocumentElement;
  w := '';
  if (user = '') and (roles = '') and (resp = '') and (page = '') and (struct = '') then
  begin
     sqltext := 'select username,email , actflag from axusers ';
  end else
  begin
     if user <> '' then
     begin
       user := '%' + lowercase(user) + '%';
       w := dbm.gf.sqllower+'(username) like ' + quotedstr(user)
     end;
     if roles <> '' then
     begin
        roles := roles + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(roles,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+ '(usergroup) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select username from AXUSERLEVELGROUPS where  ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('username').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' username in (' + p + ')';
          if w <> '' then w := w + ' or ' + p
          else w := p;
        end;
     end;
     if resp <> '' then
     begin
        resp := resp + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(resp,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select groupname from axusergroups where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('groupname').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' usergroup in (' + p + ')';
          sqltext := 'select username from AXUSERLEVELGROUPS where ' + p  ;
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          if not x.CDS.isempty then
          begin
            while not x.CDS.eof do
            begin
              p := p + quotedstr(x.CDS.fieldbyname('username').AsString) + ',';
              x.CDS.next;
            end;
            i := length(p);
            r := copy(p,i,1);
            if r = ',' then delete(p,i,1);
            p := ' username in (' + p + ')';
            if w <> '' then w := w + ' or ' + p
            else w := p;
          end;
        end;
     end;
     if page <> '' then
     begin
        page := page + ',';
        i := 1;
        p := '';
        while true do
        begin
          s := dbm.gf.GetnthString(page,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+'(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from axpages where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' sname in (' + p + ') and stype = ''p''';
          sqltext := 'select rname from axuseraccess where ' + p + ' order by '+dbm.gf.sqllower+'(rname)';
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          while not x.CDS.eof do
          begin
            s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr('%'+lowercase(x.CDS.fieldbyname('rname').AsString)+'%') ;
            p := p + s + ' or ';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i-3,3);
          if r = ' or' then delete(p,i-3,3);
          sqltext := 'select groupname from axusergroups where ' + p  ;
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          if not x.CDS.isempty then
          begin
            while not x.CDS.eof do
            begin
              p := p + quotedstr(x.CDS.fieldbyname('groupname').AsString) + ',';
              x.CDS.next;
            end;
            i := length(p);
            r := copy(p,i,1);
            if r = ',' then delete(p,i,1);
            p := ' usergroup in (' + p + ')';
            sqltext := 'select username from AXUSERLEVELGROUPS where  ' + p  ;
            x.close;
            x.CDS.CommandText:= sqltext;
            x.open;
            p := '';
            if not x.CDS.isempty then
            begin
              while not x.CDS.eof do
              begin
                p := p + quotedstr(x.CDS.fieldbyname('username').AsString) + ',';
                x.CDS.next;
              end;
              i := length(p);
              r := copy(p,i,1);
              if r = ',' then delete(p,i,1);
              p := ' username in (' + p + ')';
              if w <> '' then w := w + ' or ' + p
              else w := p;
            end;
          end;
        end;
     end;
     p := '';
     if struct <> '' then
     begin
        struct := struct + ',';
        i := 1;
        while true do
        begin
          s := dbm.gf.GetnthString(struct,i);
          if s = '' then break;
          s := '%' + s + '%';
          s := dbm.gf.sqllower+'(caption) like ' + quotedstr(lowercase(s)) ;
          p := p + s + ' or ';
          i := i + 1;
        end;
        i := length(p);
        r := copy(p,i-3,3);
        if r = ' or' then delete(p,i-3,3);
        sqltext := 'select name from tstructs where ' + p  ;
        x.close;
        x.CDS.CommandText:= sqltext;
        x.open;
        p := '';
        if not x.CDS.isempty then
        begin
          while not x.CDS.eof do
          begin
            p := p + quotedstr(x.CDS.fieldbyname('name').AsString) + ',';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i,1);
          if r = ',' then delete(p,i,1);
          p := ' sname in (' + p + ') and stype = ''t''';
          sqltext := 'select rname from axuseraccess where ' + p + ' order by '+dbm.gf.sqllower+'(rname)';
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          while not x.CDS.eof do
          begin
            s := dbm.gf.sqllower+ '(userroles) like ' + quotedstr('%'+lowercase(x.CDS.fieldbyname('rname').AsString)+'%') ;
            p := p + s + ' or ';
            x.CDS.next;
          end;
          i := length(p);
          r := copy(p,i-3,3);
          if r = ' or' then delete(p,i-3,3);
          sqltext := 'select groupname from axusergroups where ' + p  ;
          x.close;
          x.CDS.CommandText:= sqltext;
          x.open;
          p := '';
          if not x.CDS.isempty then
          begin
            while not x.CDS.eof do
            begin
              p := p + quotedstr(x.CDS.fieldbyname('groupname').AsString) + ',';
              x.CDS.next;
            end;
            i := length(p);
            r := copy(p,i,1);
            if r = ',' then delete(p,i,1);
            p := ' usergroup in (' + p + ')';
            sqltext := 'select username from AXUSERLEVELGROUPS where  ' + p  ;
            x.close;
            x.CDS.CommandText:= sqltext;
            x.open;
            p := '';
            if not x.CDS.isempty then
            begin
              while not x.CDS.eof do
              begin
                p := p + quotedstr(x.CDS.fieldbyname('username').AsString) + ',';
                x.CDS.next;
              end;
              i := length(p);
              r := copy(p,i,1);
              if r = ',' then delete(p,i,1);
              p := ' username in (' + p + ')';
              if w <> '' then w := w + ' or ' + p
              else w := p;
            end;
          end;
        end;
     end;
     if w <> '' then sqltext := 'select username,email,actflag from axusers '
     else exit;
  end;
  x.close;
  if w <> '' then w := ' where ' + w + ' and ' + dbm.gf.sqllower + '(username) <> ' + quotedstr('admin')
  else w := ' where ' + dbm.gf.sqllower + '(username) <> ' +  quotedstr('admin') ;
  dbm.gf.dodebug.msg('Pagination page no ' + inttostr(dbm.gf.pagination_pageno));
  if active <> '' then //new code active was not handled
  begin
    if w <> '' then begin
      if pos('where',lowercase(w)) = 0 then w :=  ' where ' + w;
      w :=  w + ' and ' + dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active));
    end
    else begin
      if pos('where',lowercase(w)) = 0 then w :=  ' where ' + w ;
      w := dbm.gf.sqllower + '('+dbm.gf.sqlnull+'(actflag,''y'')) = ' + quotedstr(lowercase(active)); //new sqlnull is added in query
    end;
  end;
  if dbm.gf.pagination_pageno = 1 then
  begin
     if w <> '' then
        s := 'select username from axusers ' + w +  ' order by '+dbm.gf.sqllower+'(username)'
     else
        s := 'select username from axusers order by username' ;
     s := dbm.ChangeSqlForPagination(s,true);
     x.CDS.CommandText := s;
     x.open;
     dbm.gf.pagination_totalrows := x.CDS.FieldByName('recno').AsInteger;
     x.close;
  end;
  sqlText := sqlText + w +  ' order by '+dbm.gf.sqllower+'(username)';
  sqlText := dbm.ChangeSqlForPagination(sqlText,false);
  x.CDS.CommandText := sqltext;
  x.open;
  if x.CDS.isempty then exit;
  while not x.CDS.eof do
  begin
//    if x.fieldbyname('username').AsString = 'admin' then
//    begin
//      pagination_totalrows := pagination_totalrows - 1;
//      x.next;
//      continue;
//    end;
    cnode := enode.addchild('row');
    uroles := x.CDS.fieldbyname('username').AsString;
    cnode.AddChild('users').NodeValue := uroles;
    act := x.CDS.fieldbyname('actflag').AsString;
    if act = '' then act := 'Y';
    cnode.AddChild('res').NodeValue := '';
    cnode.AddChild('act').NodeValue := act;
    cnode.AddChild('email').NodeValue := x.CDS.fieldbyname('email').AsString;
    i := 0;
    ar := '';
    if uroles <> '' then
    begin
      q.close;
      q.SqlText := 'select usergroup from AXUSERLEVELGROUPS where username = ' + quotedstr(uroles);
      q.open;
      while not q.eof do
      begin
        ar := ar + q.fieldbyname('usergroup').AsString + ', ' ;
        q.next;
      end;
    end;
    i := length(ar);
    r := copy(ar,i-1,1);
    if r = ',' then delete(ar,i-1,1);
    cnode.AddChild('roles').NodeValue := ar;
    x.CDS.next;
  end;
  if dbm.gf.pagination_totalrows > 0 then enode.Attributes['totalrows'] := inttostr(dbm.gf.pagination_totalrows);
  x.close;
end;

function TAxProvider.ChangeSqlForUMPagination(orgSql : String ) : String ;
  var s,orderby,sql,from , ordfld, s1 , col , fld: String;
  sno, eno , i : integer;
begin
  result := orgSql;
  if dbm.gf.pagination_pageno = 0 then exit;
  s := '';
  if lowercase(dbm.Connection.DbType) = 'oracle' then
  begin
    eno := dbm.gf.pagination_pageno * dbm.gf.pagination_pagesize;
    sno := eno - dbm.gf.pagination_pagesize + 1;
    s := 'select  *  from (select  a.* , rownum axrnum  from ( ' + orgSql + ' )a  where rownum <= ' + inttostr(eno) + ' ) where axrnum  >= ' + inttostr(sno) ;
    result := s;
  end else if (lowercase(dbm.Connection.DbType)='mysql') or (lowercase(dbm.Connection.DbType)='postgre')  then begin
    {
    s:= 'select  * from (select  a.* , @rownum ::=  @rownum +1 as axrnum  from '+
      '( '+orgSql+') a, (SELECT @rownum ::= 0) r where @rownum < '+inttostr(eno)+' ) rr '+
      ' where rr.axrnum  >= '+inttostr(sno); }
    if dbm.gf.pagination_pageno = 1 then s:= orgSql + ' LIMIT ' + inttostr(dbm.gf.pagination_pagesize)
    else begin
      eno := dbm.gf.pagination_pageno * dbm.gf.pagination_pagesize;
      sno := eno - dbm.gf.pagination_pagesize;
      s:= orgSql + ' LIMIT ' + inttostr(dbm.gf.pagination_pagesize) + ' OFFSET ' + inttostr(sno) ;
    end;
    result := s;
  end else if lowercase(dbm.Connection.DbType) = 'ms sql' then
  begin
    sql := trim(lowercase(orgSql));
    if pos('order by',sql) > 0 then
    begin
      orderby := copy(sql,pos('order by',sql),length(sql));
      delete(sql,pos('order by',sql),length(sql));
      ordfld :=  orderby;
      ordfld := trim(copy(ordfld,pos('by',ordfld)+2,length(ordfld)))  ;
      col := '';
      fld := '';
      if pos(',',ordfld) > 0 then
      begin
        i := 1;
        while true do
        begin
          s := dbm.gf.GetnthString(ordfld,i);
          if s = '' then break;
          if pos(s,sql) = 0 then fld := fld + ',' + s;
          if pos('.',s) > 0 then
            s := copy(s,pos('.',s)+1,length(s));
          col := col +  s + ',';
          i := i + 1;
        end;
        while pos(',',ordfld) > 0 do
        begin
          delete(ordfld,1,pos(',',ordfld)+1)
        end;
        delete(col,length(col),1);
        if pos(' ',ordfld) > 0 then
        begin
          s1 := copy(ordfld,pos(' ',ordfld),length(ordfld))  ;
          col := col + ' ' + s1;
        end;
      end else
      begin
        if pos(' ',ordfld) > 0 then
        begin
          s1 := copy(ordfld,pos(' ',ordfld),length(ordfld))  ;
          delete(ordfld,pos(' ',ordfld),length(ordfld));
        end;
        s := ordfld;
        if pos(s,sql) = 0 then fld := fld + ',' + s ;
        if pos('.',s) > 0 then s := copy(s,pos('.',s)+1,length(s));
        col := s + ' ' + s1;
      end;
      if (pos('distinct',sql) = 0) and (fld <> '') then
      begin
        fld := fld + '  ';
        i := pos('from',sql);
        insert(fld,sql,i);
      end;
      orderby := ' order by ' + col;
    end
    else exit;
    eno := dbm.gf.pagination_pageno * dbm.gf.pagination_pagesize;
    sno := eno - dbm.gf.pagination_pagesize + 1;
    s := 'select * from (select row_number() over ( ' + orderby +' ) as axrnum, * from ( ' + sql + ') as abc  ) xy  where axrnum between ' + inttostr(sno) + ' and ' + inttostr(eno) + ' order by axrnum' ;
    result := s;
  end;
end;

function TAxProvider.checkLicence: String;
  var y,m,d  : Word ;
     dt,dt1, expDate : String;
begin
  // license expiry date. change here the values of y,m,d. this is only place to change. enter 0 for no-expiry date
  expDate := '';
  y := 2020;
  m := 03;
  d := 31;
  if (y <> 0) and (m <> 0) and (d <> 0) then
  begin
    expdate := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,EncodeDate(y,m,d));
  end;
  if expdate <> '' then
  begin
    if dbm.gf.remoteLogin then
       dt := copy(RemoteServerDateTime,1,10)
    else dt := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,dbm.getServerDateTime);
    dt1 := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,now);
    if (strtodate(dt) > strtodate(expDate)) or (strtodate(dt1) > strtodate(expDate))then
        raise exception.create('License expired.');
//  if dt <> dt1 then raise exception.create('Client and Server Dates are different. Can not continue.');
  end;
end;

function TAxProvider.MessageSent(fromwhom,towhom,msgstring :String ):String;
var
  w,towhoms,t,upddatetime,tostatus,fromstatus,readstatus :String;
  recid,groupid : Extended;
  i,p : integer;
begin
  fromstatus := '0';
  tostatus := '0';
  readstatus := '0';
  i := 0;
  groupid:=0;
  if pos(';',towhom) > 0 then groupid := dbm.gf.Gen_Id('',1);
  upddatetime := datetimetostr(dbm.getServerDateTime);
  towhoms := trim(towhom) +';';
  try
    while towhoms <> '' do
    begin
      inc(i);
      p := pos(';',towhoms);
      t := copy(towhoms,1,p-1);
      recid := dbm.Gen_id(dbm.Connect.Connection);
      w:='msgid ='+ floattostr(recid);
      x.Submit('msgid', floattostr(recid), 'n');
      x.Submit('groupid', floattostr(groupid), 'n');
      x.Submit('fromwhom', fromwhom, 'c');
      x.Submit('towhom',t,'c');
      if ( groupid > 0 ) and ( i =1 ) then
        x.Submit('towhoms', copy(towhoms,1,length(towhoms)-1), 'c');
      x.Submit('message', msgstring, 'c');
      x.Submit('upddatetime', upddatetime, 'c');
      x.Submit('fromstatus', fromstatus, 'n');
      x.Submit('tostatus', tostatus, 'n');
      x.Submit('readstatus', readstatus, 'n');
      x.AddOrEdit('axmessage', w);
      towhoms := trim(copy(towhoms,p+1,100));
    end;
    result := 'done';
  except on E : Exception do
     begin
       result :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxProvider.GetAllMessages(loc,fs : String) : IXMLDocument;
var  rnode,xnode : IXMLNode;
     sqlstring,s : String;
     q1 : Txds;
     i : integer;
begin
  q1 :=  dbm.GetXDS(nil);
  q1.buffered := True;
  x.close;
  try
    if fs <> '' then fs := ' AND '+dbm.gf.SQLLower+'(message) like '+lowercase(quotedstr('%'+fs+'%'));
    if loc = 'R' then
    begin
      sqlstring := 'SELECT msgid,groupid,fromwhom,towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   '  WHERE '+dbm.gf.sqllower+'(TOWHOM)= '+Quotedstr(dbm.gf.username)+' AND TOSTATUS = 0 '+fs+' order by upddatetime desc';
    end else
    if loc='S' then begin
      sqlstring := 'SELECT msgid,groupid,fromwhom,towhoms towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   'WHERE '+dbm.gf.sqllower+'(FROMWHOM)='+Quotedstr(dbm.gf.username)+' AND FROMSTATUS = 0 AND GROUPID > 0 AND TOWHOMS IS NOT NULL '+
                   fs+
                   'UNION '+
                   'SELECT msgid,groupid,fromwhom, towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   'WHERE '+dbm.gf.sqllower+'(FROMWHOM)='+quotedstr(dbm.gf.Username)+' AND FROMSTATUS = 0 AND GROUPID = 0 '+fs+' order by upddatetime desc';
    end else
    if loc='D' then begin
      sqlstring := 'SELECT msgid,groupid,fromwhom,towhoms towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   'WHERE '+dbm.gf.sqllower+'(FROMWHOM)='+Quotedstr(dbm.gf.username)+' AND FROMSTATUS = 1 AND GROUPID > 0 AND TOWHOMS IS NOT NULL '+
                   fs+
                   'UNION '+
                   'SELECT msgid,groupid,fromwhom, towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   'WHERE '+dbm.gf.sqllower+'(FROMWHOM)='+Quotedstr(dbm.gf.username)+' AND FROMSTATUS = 1 '+fs+
                   'UNION '+
                   'SELECT msgid,groupid,fromwhom, towhom,fromstatus,tostatus,readstatus,message,upddatetime FROM AXMESSAGE '+
                   'WHERE '+dbm.gf.sqllower+'(TOWHOM)='+Quotedstr(dbm.gf.username)+' AND TOSTATUS = 1 '+fs+
                   ' order by upddatetime desc'
    end;
    if dbm.gf.pagination_pageno = 1 then
    begin
       s := dbm.ChangeSqlForPagination(sqlstring,true);
       q1.CDS.CommandText := s;
       q1.open;
       dbm.gf.pagination_totalrows := q1.CDS.FieldByName('recno').AsInteger;
       q1.close;
    end;
//    if (dbm.gf.pagination_totalrows > 0) then begin
      sqlstring := dbm.ChangeSqlForPagination(sqlstring,false);
//    end;
    Q1.Close;
    Q1.CDS.CommandText := sqlstring;
    dbm.gf.DoDebug.Msg('SQL:'+sqlstring);
    Q1.CDS.open;
    dbm.gf.DoDebug.Msg('Open Successfully');
    result := LoadXMLData('<root></root>');
    rnode := result.DocumentElement;
    i := 0;
    while not Q1.CDS.Eof do
    begin
      inc(i);
      xnode := rnode.AddChild('row_'+loc);
      xnode.AddChild('msgid').NodeValue := Q1.CDS.FieldByName('msgid').AsString;
      xnode.AddChild('groupid').NodeValue := Q1.CDS.FieldByName('groupid').AsString;
      xnode.AddChild('upddatetime').NodeValue := Q1.CDS.FieldByName('upddatetime').AsString;
      xnode.AddChild('fromwhom').NodeValue := Q1.CDS.FieldByName('fromwhom').AsString;
      xnode.AddChild('towhom').NodeValue := Q1.CDS.FieldByName('towhom').AsString;
      xnode.AddChild('fromstatus').NodeValue := Q1.CDS.FieldByName('fromstatus').AsString;
      xnode.AddChild('tostatus').NodeValue := Q1.CDS.FieldByName('tostatus').AsString;
      xnode.AddChild('read').NodeValue := Q1.CDS.FieldByName('readstatus').AsString;
      xnode.AddChild('message').NodeValue := Q1.CDS.FieldByName('message').AsString;
      Q1.CDS.Next;
    end;
    rnode.Attributes['total_rows'] :=vartostr(dbm.gf.pagination_totalrows);
    Q1.close;
  Except on E: Exception  do begin
    result.DocumentElement.Attributes['error'] := E.Message;
  end;
  end;
  if assigned(q1) then begin
    q1.close;
    q1.Free;
  end;
end;

function TAxprovider.MessageDelete(msgid : String):String;
var  fromwhom,towhom,sqlstring,groupid : String;
     cnt : integer;
begin
  result := '';
  try
    x.close;
    sqlstring := 'select groupid,towhom,fromwhom from axmessage where msgid = '+msgid;
    x.sqltext := sqlstring;
    x.open;
    fromwhom := x.fieldbyname('fromwhom').AsString;
    towhom := x.fieldbyname('towhom').AsString;
    groupid := x.fieldbyname('groupid').AsString;
    x.close;
    if lowercase(fromwhom) = lowercase(dbm.gf.username) then  begin
      if groupid='0' then
        sqlstring := 'update axmessage set fromstatus = fromstatus + 1 where msgid = '+msgid
      else
        sqlstring := 'update axmessage set fromstatus = fromstatus + 1 where groupid = '+groupid;
    end
    else  if lowercase(towhom) = lowercase(dbm.gf.username) then
      sqlstring := 'update axmessage set tostatus = tostatus + 1 where msgid = '+msgid;
    ExecSQL(sqlstring,'','',false);
    cnt := 0;
    sqlstring := 'insert into axmessage_archive select * from axmessage where fromstatus=2 and tostatus=2'; {Backup to Archive Table}
    ExecSQL(sqlstring,'','',false);
    sqlstring := 'delete from axmessage where fromstatus = 2 and tostatus =2';
    ExecSQL(sqlstring,'','',false);
  result := 'done';
  Except on E: Exception do
  begin
    result := '<error>'+E.Message+'<\error>';
  end;
  end;
  x.close;
end;

function TAxProvider.GetMessage(msgid :String ):IXMLDocument;
var
  w,msgstring :String;
begin
  result := LoadXMLData('<root></root>');
  try
    x.close;
    x.SqlText := 'select fromwhom, decode(towhoms,'''',towhom,towhoms) tw  ,message from axmessage where msgid='+msgid;
    x.open;
    if not x.isempty then begin
      result.DocumentElement.AddChild('fromwhom').nodevalue := x.fieldbyname('fromwhom').AsString;
      result.DocumentElement.AddChild('towhom').nodevalue := x.fieldbyname('tw').AsString;
      result.DocumentElement.AddChild('message').nodevalue := x.fieldbyname('message').AsString;
    end;
  except on E : Exception do
     begin
       result.DocumentElement.Attributes['error'] :=  E.Message;
     end;
  end;
  x.close;
end;

function TAxprovider.MessageSetReadStatus(msgid : String):String;
var  sqlstring : String;
begin
  result := '';
  try
    sqlstring := 'update axmessage set readstatus=1 where msgid ='+msgid;
    ExecSQL(sqlstring,'','',false);
    result := 'done';
  Except on E: Exception do
    result := '<error>'+E.Message+'<\error>';
  end;
end;

function TAxProvider.FieldFound(FldName:String;TblName:String):Boolean;
var qry:TXDS;
begin
  result := true;
  qry := dbm.GetXDS(nil);
  qry.buffered := True;
  qry.cds.commandtext := 'select '+fldname+' from '+tblname+' where 1=2 ';
  try
  try
    if dbm.gf.RemoteLogin then begin
      qry.open ;
      qry.CDS.Active := True;
    end else
      qry.open;
  except
    On e:Exception do begin
      result := false;
    end;
  end;
  finally
    qry.close; qry := nil;
  end;
end;

function TAxProvider.SaveUserProfile(profilefile : String):String;
var   up : IXMLDocument;
      ts : TStringlist;
      imgfilename,w : String;
begin
  result := 'done';
  if not fileexists(profilefile) then
  begin
    result := profilefile+' does not exists';
    exit;
  end;
  try
    w := dbm.gf.sqllower+'(username) = '+lowercase(quotedstr(dbm.gf.username));
    x.close;
    x.Submit('username',dbm.gf.username,'c');
    x.AddOrEdit('Axuserprofile',w);
    ts := TStringlist.Create;
    ts.LoadFromFile(profilefile);
    up := LoadXMLData(ts.Text);
    imgfilename := vartostr(up.DocumentElement.Attributes['imagefile']);
    up.DocumentElement.Attributes['imagefile'] := '';
    if imgfilename <> '' then up.DocumentElement.Attributes['imagefileext'] := ExtractFileExt(imgfilename);
    dbm.WriteMemo('userprofile','axuserprofile',w,profilefile);
    dbm.gf.dodebug.msg('Profile Updated');
    if imgfilename <> '' then
    begin
      if fileexists(imgfilename) then
      begin
        x.close;
        x.Submit('username',dbm.gf.username,'c');
        x.AddOrEdit('AxuserprofileImage',w);
        dbm.WriteBlob('userimage','axuserprofileimage',w,imgfilename);
        dbm.gf.dodebug.msg('Image Updated for Profile')
      end;
    end;
  Except on E:Exception do
     begin
       dbm.gf.dodebug.msg('Error - '+E.Message);
       result := E.Message;
     end;
  end;
  x.close;
  if assigned(ts) then Ts.Free;
end;

function TAxProvider.GetUserProfile:IXMLDocument;
var cnt : integer;
    imgfilename,w,fname : String;
    xm : IXMLDocument;
    ts : tstringlist;
begin
  result := LoadXMLData('<root></root>');
  try
  w := dbm.gf.sqllower+'(username) = '+lowercase(quotedstr(dbm.gf.username));
  fname :=  dbm.gf.startpath+'\'+dbm.gf.username+'.xml';
  dbm.ReadMemo('userprofile','axuserprofile',w,fname);
  ts:=TStringlist.Create;
  ts.LoadFromFile(fname);
  xm := LoadXMLData(ts.Text);
  x.close;
  x.SqlText := 'select '+dbm.gf.sqlnull+'(count(*),0) cnt from axuserprofileimage where '+dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(dbm.gf.username));
  x.open;
  if x.fieldbyname('cnt').AsInteger > 0 then
  begin
    imgfilename := dbm.gf.startpath+'\'+dbm.gf.username+'.'+vartostr(XM.DocumentElement.Attributes['imgfileext']);
    dbm.ReadBlob('userimage','axuserprofileimage',w,imgfilename);
    xm.DocumentElement.Attributes['imgfilename'] := imgfilename;
  end;
  x.close;
  Result := XM;
    Except on E:Exception do begin
      Result := LoadXMLData('<error>'+E.Message +'</error>');
    end;
  end;
  if Assigned(ts) then ts.Free;
  x.close;
end;

procedure TAxProvider.RemoteAddConstraint(TableName, Constraints: String);
begin

end;

procedure TAxProvider.RemoteDropConstraint(TableName, Constraints: String);
begin

end;

function TAxProvider.RemoteEditField(TableName, FName, DType: String; FWidth, FDec: Integer): String;
begin

end;

function TAxProvider.RemoteReadMemo(fname, table, where: String): String;
begin

end;

procedure TAxProvider.DownLoadFile(filename, tempfile: String);
begin

end;

procedure TAxProvider.RemoteSaveWorkflow(name, caption: String;
  WXML: ixmldocument);
begin

end;

function TAxProvider.RemoteServerDateTime: String;
begin

end;

procedure TAxProvider.RemoteSetPrefix(transid,fldname,prefix:String);
begin
end;

procedure TAxProvider.SetStructure(sname, name, caption , uname : String;
           xml:IXMLDocument; UpdSrcDate:Boolean=False);
var w, t : String;
    rfile : String;
    s,tfile,sfile : String;
    StructExists, flag : Boolean;
begin
  if lowercase(name) = 'resource' then
  begin
     //showmessage('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Msg('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Log('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if not DirectoryExists(dbm.gf.startpath) then
    CreateDir(dbm.gf.startpath);
  if not DirectoryExists(dbm.gf.startpath+'\Structures') then
    CreateDir(dbm.gf.startpath+'\Structures');
  if not DirectoryExists(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName) then
    CreateDir(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName);
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  StructExists := False;
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction;
      if (not flag) then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;
      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
        if xml.DocumentElement.HasAttribute('runtimemod') then
          x.Submit('runtimemod',vartostr(xml.DocumentElement.Attributes['runtimemod']),'c');
        if xml.DocumentElement.HasAttribute('runtimetstruct') then
          x.Submit('runtimetstruct',vartostr(xml.DocumentElement.Attributes['runtimetstruct']),'c');
      end;
      x.AddOrEdit(sname, w);
      x.Post;
      if not DirectoryExists(dbm.gf.startpath+'\temp') then
        CreateDir(dbm.gf.startpath+'\temp');
      s:=dbm.gf.startpath+'\temp\xmlmemo'+dbm.gf.getnumber;
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag) then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      if (not flag)then dbm.RollBack(dbm.gf.connectionname);
    end;
  end;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

procedure TAxProvider.SetStructure(sname, name, caption: String; xml:IXMLDocument;
      UpdSrcDate:Boolean=False);
var w, t : String;
    rfile,pexits,s,pcode : String;
    sr:TSearchRec;
    i : integer;
    starttrans, StructExists : boolean;
    tfile,sfile : String;
begin
  pexits := '';
  StructExists := False;
  if (sname = 'axpages') and (name = 'pageorder') then exit;
  if lowercase(name) = 'resource' then
  begin
     //showmessage('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Msg('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Log('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if not DirectoryExists(dbm.gf.startpath) then
    CreateDir(dbm.gf.startpath);
  if not DirectoryExists(dbm.gf.startpath+'\Structures') then
    CreateDir(dbm.gf.startpath+'\Structures');
  if not DirectoryExists(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName) then
    CreateDir(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName);
  if sname = 'tstructs' then begin
    rfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.res';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.cls';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.pfx';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.agf';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'_*.cds';
    if (findfirst(rfile, faAnyFile, sr)=0) then begin
      repeat
        if (sr.name = '.') or (sr.Name = '..') then continue;
        deletefile(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+sr.name);
      until FindNext(sr) <> 0;
      FindClose(sr);
    end;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
//  if fileexists(rfile) then deletefile(rfile);
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,'',xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      if sname = 'tstructs' then xml.DocumentElement.Attributes['pform'] := 'yes' ;
      if name = 'pageorder' then exit;
      if sname = 'axpages' then
      begin
        if not xml.DocumentElement.HasAttribute('ordno') then exit;
        if vartostr(xml.DocumentElement.Attributes['ordno']) = '' then exit;
      end;
      sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption)
  else w:='name='+quotedstr(name);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if sname = 'axpages' then
  begin
    q.close;
    q.sqltext:='select type,parent,ordno,levelno,img,visible,pagetype,icon from '+sname+' where '+w;
    q.open;
    if not q.isempty then
    begin
      xml.DocumentElement.Attributes['img'] := q.fieldbyname('img').AsString;
      xml.DocumentElement.Attributes['visible']:= q.fieldbyname('visible').AsString;
      xml.DocumentElement.Attributes['type']:= q.fieldbyname('type').AsString;
      xml.DocumentElement.Attributes['ordno']:= q.fieldbyname('ordno').AsString;
      xml.DocumentElement.Attributes['levelno']:= q.fieldbyname('levelno').AsString;
      xml.DocumentElement.Attributes['parent']:= q.fieldbyname('parent').AsString;
      xml.DocumentElement.Attributes['pagetype']:= q.fieldbyname('pagetype').AsString;
      xml.DocumentElement.Attributes['icon']:= q.fieldbyname('icon').AsString;
      pexits := 'yes';
    end;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      starttrans := false;
      if not dbm.InTransaction then
      begin
         starttrans := true;
         dbm.StartTransaction(dbm.gf.connectionname);
      end;
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;
      if sname = 'tstructs' then
      begin
        if xml.DocumentElement.HasAttribute('wflow') then
           x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
        if xml.DocumentElement.HasAttribute('runtimemod') then
          x.Submit('runtimemod',vartostr(xml.DocumentElement.Attributes['runtimemod']),'c');
        if xml.DocumentElement.HasAttribute('runtimetstruct') then
          x.Submit('runtimetstruct',vartostr(xml.DocumentElement.Attributes['runtimetstruct']),'c');
        i := 0;
        i := GetProdCode(name);
        if Assigned(lm) then
          i := i + lm.licProdCode
        else
          i := i + 100;
        pcode := inttostr(i);

        xml.DocumentElement.Attributes['pid']:= pcode;
      end;
      if pexits = 'yes' then
      begin
        x.Submit('img', vartostr(xml.DocumentElement.Attributes['img']), 'c');
        x.Submit('visible', vartostr(xml.DocumentElement.Attributes['visible']), 'c');
        x.Submit('type', vartostr(xml.DocumentElement.Attributes['type']), 'c');
        x.Submit('parent', vartostr(xml.DocumentElement.Attributes['parent']), 'c');
        if vartostr(xml.DocumentElement.Attributes['ordno']) <> '' then
           x.Submit('ordno', vartostr(xml.DocumentElement.Attributes['ordno']), 'n');
        if vartostr(xml.DocumentElement.Attributes['levelno']) <> '' then
           x.Submit('levelno', vartostr(xml.DocumentElement.Attributes['levelno']), 'n');
        if vartostr(xml.DocumentElement.Attributes['pagetype']) <> '' then
           x.Submit('pagetype', vartostr(xml.DocumentElement.Attributes['pagetype']), 'c');
        if vartostr(xml.DocumentElement.Attributes['icon']) <> '' then
           x.Submit('icon', vartostr(xml.DocumentElement.Attributes['icon']), 'c');
      end;
      x.AddOrEdit(sname, w);
      x.Post;

      if sname = 'tstructs' then
      begin
        sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
        tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
        xml.SaveToFile(sfile);
        with TCompress.Create do begin
          compressfile(sfile, tfile);
          destroy;
        end;
        if fileexists(tfile) then begin
          if fileexists(sfile) then deletefile(sfile);
        end;
        dbm.WriteBlob('props', sname, w, tfile);
      end else
      begin
        if not DirectoryExists(dbm.gf.startpath+'\temp') then
          CreateDir(dbm.gf.startpath+'\temp');
        s:=dbm.gf.startpath+'\temp\xmlmemo'+dbm.gf.getnumber;
        xml.SaveToFile(s);
        dbm.WriteMemo('props', sname, w, s);
        deletefile(s);
      end;
      if starttrans then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      if starttrans then dbm.RollBack(dbm.gf.connectionname)
      else raise;
    end;
  end;
  if (name = 'pageorder') or ((sname = 'axpages') and (pexits = '')) then exit;
  if sname = 'tstructs' then exit;
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

function TAxProvider.GetPage(name, caption, purpose: String): IXMLDocument;
begin

end;

function TAxProvider.GetModuleWiseTStruct(head : String) : IXMLDocument;
  var n,pnode,n1,n2 : IXMLNode;
  i , j, k , l : integer;
  found : boolean;
  s,s1,stype : String;
begin
  if pos('default',dbm.gf.userroles) > 0 then
     x.sqltext:='select name,parent,levelno from axpages where ordno > (select ordno from axpages where name = '+quotedstr(head) +') and blobno=1 order by ordno ,levelno '
  else
    x.sqltext:='select name,parent,levelno from axpages where ordno > (select ordno from axpages where name = '+quotedstr(head) +') and blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
  s := '';
  x.open;
  if x.isempty then raise exception.Create('User Roles not defined for this user');
  while not x.eof do begin
    if (x.fieldbyname('parent').asstring = head) then
      s := s + quotedstr(x.fieldbyname('name').AsString) + ','
    else begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
    end;
    x.next;
    if x.fieldbyname('levelno').asstring = '0' then break;
  end;
  x.close;
  delete(s,length(s),2);
  if s = '' then raise exception.Create('User Roles not defined for this user');
  s := 'select name from axpages where blobno=1 and name in ( ' + s + ' ) order by ordno ,levelno ';
  x.sqltext:= s;
  s := '';
  x.open;
  while not x.eof do
  begin
    if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
       s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
    x.next;
  end;
  x.close;
  delete(s,length(s),2);
//  s := 'select sname from axpagedetail where stype = ''t'' and name in (' + s + ')';
  if lowercase(dbm.Connection.DbName) = 'ms sql' then
    s := 'select pagetype from axpages where substring(pagetype,1,1) = ''t''  and name in (' + s + ')'
  else
    s := 'select pagetype from axpages where substr(pagetype,1,1) = ''t''  and name in (' + s + ')';
  x.sqltext:= s;
  s := ''; s1:= '';
  x.open;
  while not x.eof do
  begin
    s1 := x.fieldbyname('pagetype').AsString;
    delete(s1,1,1);
    if pos(s1,s) = 0 then
       s := s + quotedstr(s1) + ',' ;
    x.next;
  end;
  x.close;
  delete(s,length(s),2);
  stype := 't';
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow) = ''t'' and name in ( ' + s + ') order by ' + dbm.gf.sqllower + '(caption)'
  else  begin
    x.sqltext:='select name,caption from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow)=''t'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) and name in (' + s + ')order by ' + dbm.gf.sqllower + '(caption)'
  end;
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring+'('+x.fieldbyname('name').asstring+')';
    x.next;
  end;
  x.close;
end;

procedure TAxProvider.SaveImage(foldername,filename,tblname: String;recid:Extended);
  var w,fname:String;
begin
  if dbm.gf.RemoteLogin then
  begin
    {
    w:='recordid='+floattostr(recid);
    q.buffered := True;
    q.CDS.CommandText :='delete from '+sname+' where '+w;
    q.open;
    q.CDS.CommandText := 'insert into ' + sname + ' (recordid,blobno,ftype) values (:recid,1,:ftype)' ;
    q.AssignParam(0, floattostr(recid),'n');
    q.AssignParam(1,ftype,'c');
    q.open;
    }
{    s:=dbm.gf.startpath+'temp\img'+dbm.gf.getnumber + '.' + ftype;
    img.Picture.SaveToFile(s);
    s := UploadFile('temp',s);
    RemoteSaveImage('img',sname, floattostr(recid) ,s,ftype);
    exit;}
  end;
  w:='filename='+quotedstr(filename)+' and recordid='+floattostr(recid);
  q.close;
  q.sqltext:='delete from '+tblname+' where '+w;
  q.execsql;
  x.Submit('recordid', floattostr(recid), 'n');
  x.Submit('blobno', '1', 'n');
  x.Submit('filename', filename, 'c');
  x.AddOrEdit(tblname, w);
  x.Post;
  fname:=foldername+filename;
  dbm.WriteBlob('img', tblname, w, fname);
end;

procedure TAxProvider.GetFontCDS(sname : String ; fcds : TXDS);
begin
  fcds.close;
  fCDS.CDS.CommandText := 'select compname,compcaption,comphint,fontname,fontsize from axlanguage where '+dbm.gf.sqllower+'(sname)= '+quotedstr(lowercase(sname))+ ' and ' + dbm.gf.sqllower +'(dispname) = ' + quotedstr(lowercase(dbm.gf.Applanguage));
  fCDS.open;
end;

procedure TAxProvider.SaveImage(sFolderName,sFileName,tFolderName, tFileName: String);
  var sFile, tFile :String;
begin
  if dbm.gf.RemoteLogin then
  begin
///
  end;
  sFile := sFolderName+sFileName;
  tFile := tFolderName+tFileName;
  copyfile(pChar(sFile),pChar(tFile),False);
end;

Function TAxProvider.IsStructExists(sname, wcond: String):Boolean;
var forcds : TXDS;
begin
  Result := False;
  CreatedOn := '';
  CreatedBy := '';
  ImportedOn := '';
  ImportedBy := '';
  forcds:=dbm.GetXDS(nil);
  forcds.buffered := True ;
  forcds.CDS.CommandText:='select createdon, createdby, importedon, importedby from '+sname+' where '+wcond;
  forcds.open;
  if forcds.CDS.RecordCount > 0 then
  begin
    result := True;
    CreatedOn := forcds.CDS.FieldByName('createdon').AsString;
    CreatedBy := forcds.CDS.FieldByName('createdby').AsString;
    ImportedOn := forcds.CDS.FieldByName('importedon').AsString;
    ImportedBy := forcds.CDS.FieldByName('importedby').AsString;
  end;
  forcds.close;
  forcds.Destroy;
  forcds := nil;

end;


function TAxProvider.FindPrintSourceFormat(strans,formname:String;OnlyPDF:Boolean): String;
var
 x1:TXDS;
begin
  result:='';
  x1:=dbm.GetXDS(nil);
  x1.buffered:=true;
  if OnlyPDF then begin
    x1.CDS.CommandText:='select distinct caption from pdfprops where '+dbm.gf.sqllower+'(transid) ='+dbm.gf.SQLLower+'(:transid) and '+
                         dbm.gf.SQLLower+'(caption)='+dbm.gf.SQLLower+'(:caption) order by caption';
    x1.CDS.Params.ParamValues['transid']:= strans;
    x1.CDS.Params.ParamValues['caption']:=formname;
    x1.open;
    if not x1.CDS.IsEmpty then begin
      result:='pdf';
    end;
  end
  else begin
    formname := MakeFRCSVInQoutedStr(formname);
    x1.CDS.CommandText:='select distinct caption from axpertreports where '+dbm.gf.SQLLower+'(caption) in '+'('+LowerCase(formname)+') order by caption';
    x1.open;
    if not x1.CDS.IsEmpty then begin
      result:='axfast';
    end;
  end;
  x1.close;
  x1.destroy;
  x1:=nil;
end;

procedure TAxProvider.SetStructure(sname, name, caption,uname,transid : String; xml:IXMLDocument; UpdSrcDate:Boolean=false);
var w, t : String;
    rfile : String;
    StructExists, flag : boolean;
    s,tfile,sfile : String;
begin
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     //showmessage('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.msg('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Log('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction;
      if (not flag)  then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('transid', transid, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;

      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
        if xml.DocumentElement.HasAttribute('runtimemod') then
          x.Submit('runtimemod',vartostr(xml.DocumentElement.Attributes['runtimemod']),'c');
        if xml.DocumentElement.HasAttribute('runtimetstruct') then
          x.Submit('runtimetstruct',vartostr(xml.DocumentElement.Attributes['runtimetstruct']),'c');
      end;

      x.AddOrEdit(sname, w);
      x.Post;
      s:=dbm.gf.startpath+'\temp\xmlmemo'+dbm.gf.getnumber;
      if not DirectoryExists(dbm.gf.startpath+'\temp') then
        CreateDir(dbm.gf.startpath+'\temp');
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag) then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure(Overload with 7 params) - '+e.Message);
        if (not flag) then dbm.RollBack(dbm.gf.connectionname);
      end;
    end;
  end;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

function TAxProvider.GetStructure(sname, name, caption,purpose,uname,transid: string): IXMLDocument;
  var s,w,p:String;
  stm : TStringStream;
begin
  result:=LoadXMLData('<root></root>');
  if name='' then
  begin
     w := 'caption= :name and username= :uname and transid = :transid';
     p := caption
  end else
  begin
     w := dbm.gf.sqllower+'(name)= :name and username= :uname and transid = :transid' ;
     p := lowercase(name) +','+uname+','+transid;
  end;
  x.sqltext:='select * from '+sname+' where '+w;
  x.parambyname('name').AsString := lowercase(name);
  x.parambyname('uname').AsString := uname;
  x.parambyname('transid').AsString := transid;
  x.open;
  if x.isempty then
  begin
     x.close;
     p := lowercase(name) +','+'all';
     x.sqltext:='select * from '+sname+' where '+w;
     x.parambyname('name').AsString := lowercase(name);
     x.parambyname('uname').AsString := 'all';
     x.parambyname('transid').AsString := '';
     x.open;
  end;
  if not x.isempty then begin
    s :='';
    stm := TStringStream.Create(s);
    dbm.ReadMemo('props', sname, w,p,'ccc', stm);
    if stm.Size=0 then result:=LoadXMLData('<root/>')
    else result:=Loadxmldata(trim(stm.DataString));
    stm.Free;
    if sname = 'axpages' then
    begin
      GetPageName:='';
      GetPageCaption:='';
      GetPageImg:='';
      GetPageVisible:='';
      GetPageOrdNo := 0;
      GetPageName:=x.fieldbyname('name').asstring;
      GetPageCaption:=x.fieldbyname('caption').asstring;
      result.DocumentElement.Attributes['name']:=GetPageName;
      result.DocumentElement.Attributes['caption']:=GetPageCaption;
      result.DocumentElement.Attributes['orderno']:=GetPageOrdNo;
    end
    else begin
      GetStructName:=x.fieldbyname('name').asstring;
      GetStructCaption:='';
      if assigned(x.findfield('caption')) then GetStructCaption:=x.fieldbyname('caption').asstring;
      result.DocumentElement.Attributes['name'] := GetStructName;
      result.DocumentElement.Attributes['caption'] := GetStructCaption;
    end;
  end else result:=LoadXMLData('<root/>');
  x.close;
end;


procedure TAxProvider.SetStructure(sname, name, caption, uname, transid,purpose: String; xml: IXMLDocument;  UpdSrcDate:Boolean=false);
var w, t : String;
    rfile : String;
    StructExists, flag : boolean;
    s,tfile,sfile : String;
begin
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     //showmessage('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.msg('Resource is an reserved word..Use another name to save the structure..');
     dbm.gf.DoDebug.Log('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
{  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname);}
  if name='' then w:='caption='+quotedstr(caption) + ' and username='+quotedstr(uname) + ' and transid ='+quotedstr(transid)
  else w:='name='+quotedstr(name)+ ' and username='+quotedstr(uname)+' and transid ='+quotedstr(transid);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction;
      if (not flag)  then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('transid', transid, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;

      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
        if xml.DocumentElement.HasAttribute('runtimemod') then
          x.Submit('runtimemod',vartostr(xml.DocumentElement.Attributes['runtimemod']),'c');
        if xml.DocumentElement.HasAttribute('runtimetstruct') then
          x.Submit('runtimetstruct',vartostr(xml.DocumentElement.Attributes['runtimetstruct']),'c');
      end;

      x.AddOrEdit(sname, w);
      x.Post;
      if not DirectoryExists(dbm.gf.StartPath) then CreateDir(dbm.gf.StartPath);
      if not DirectoryExists(dbm.gf.StartPath+'\temp') then CreateDir(dbm.gf.StartPath+'\temp');
      s:=dbm.gf.startpath+'\temp\xmlmemo'+dbm.gf.getnumber;
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag) then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure(Overload with 7 params) - '+e.Message);
        if (not flag) then dbm.RollBack(dbm.gf.connectionname);
      end;
    end;
  end;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
  if not DirectoryExists(dbm.gf.startpath+'\Structures') then CreateDir(dbm.gf.startpath+'\Structures');
  if not DirectoryExists(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName) then CreateDir(dbm.gf.startpath+'\Structures\'+dbm.gf.AppName);
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;


procedure TAxProvider.DeleteStructure(tName,cvName, transid: String);
var
  w,sfile,tfile : String;
begin
  w := 'name='+quotedstr(cvName) + ' and '+ ' transid='+quotedstr(transid);
  x.DeleteRecord(tName, w);
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+cvName+'.xml' ;
  tfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+cvName+'.'+transid+'.'+dbm.gf.Username ;
  if fileexists(sfile) then deletefile(sfile);
  if fileexists(tfile) then deletefile(tfile);
end;

procedure TAxProvider.DeleteStructure(tName,cvName : String);
var
  w,sfile : String;
begin
  w := 'name='+quotedstr(cvName);
  x.DeleteRecord(tName, w);
  sfile := dbm.gf.startpath+'\Structures\'+dbm.gf.AppName+'\'+cvName+'.xml' ;
  if fileexists(sfile) then deletefile(sfile);
end;

procedure TAxProvider.DeleteStructure(sname, name, caption,transid: String);
var
  w,sfile,tfile : String;
begin
  w := 'name='+quotedstr(name) + ' and transid ='+quotedstr(transid) +
       'and username = '+quotedstr(dbm.gf.username);
  x.DeleteRecord(sname, w);
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname;
  if fileexists(sfile) then deletefile(sfile)
  else begin
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+dbm.gf.username;
    if fileexists(sfile) then deletefile(sfile)
  end;
end;






Procedure TAxProvider.CopyFiles(sFolder,tFolder:String);
var fRec : TSearchRec;
begin
  if FindFirst(sFolder+'\*.*', faAnyFile, fRec) = 0 then
  repeat
    CopyFile(pChar(sFolder+'\'+fRec.Name),pChar(tFolder+'\'+fRec.Name),False);
  until FindNext(fRec) <> 0;
  FindClose(fRec);
end;

function TAxProvider.ChangePassword(uname : string ; enode : ixmlnode; FirstTime:String='F') : string;
var
//  mdn5 : MessageDigest_5.IMD5;
 opwd,cpwd,ErrMsg,pwd,oldpwd,adminchange : string;
 rQry : TXds;
begin
    rQry := nil;
    result := '';
    adminchange := 'no';
    if dbm.gf.pwd_AES then
       pwd := vartostr(enode.ChildNodes['pwd'].NodeValue)
    else
       pwd := vartostr(enode.ChildNodes['md5pwd'].NodeValue);
    adminchange := lowercase(vartostr(enode.ChildNodes['changebyadmin'].NodeValue));
    {
    mdn5 := MessageDigest_5.GetMD5();
    mdn5.Update(pwd);
    newpwd := lowercase(mdn5.AsString());
    mdn5 := nil;
    }
    if adminchange <> 'yes' then
    begin
      oldpwd := vartostr(enode.ChildNodes['oldpwd'].NodeValue);
      if Trim(pwd) <> '' then begin
        if  dbm.gf.pwdalphanum then
        begin
          if not dbm.gf.IsAlphaNumeric(pwd) then
          begin
            raise exception.Create('Password should be Alpha Numeric');
          end;
        end;
        if  dbm.gf.pwdminchars > 0 then
        begin
          if length(Trim(pwd)) < dbm.gf.pwdminchars then
          begin
            raise exception.Create('Password should be minimum ' + inttostr(dbm.gf.pwdminchars) + ' characters');
          end;
        end;
      end;
      if not isOldCorrect(oldpwd,uname) then begin
        raise exception.Create('Incorrect old password.');
      end;
      if dbm.gf.pwdprevnos > 0 then
      begin
        if not checkfor_prev_pwds(pwd,uname) then
        begin
          raise exception.Create('New password should not be same as last ' + inttostr(dbm.gf.pwdprevnos) + ' passwords');
        end;
      end;
    end;
    try
      dbm.StartTransaction(dbm.Connection.ConnectionName);
      x.close;
      if adminchange = 'yes' then
         x.SqlText := 'update axusers set password = ' + quotedstr(pwd) + ',isfirsttime = ' + quotedstr(FirstTime) + ',logintry = ' + quotedstr('0') + ' where '+ dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(uName))
      else  x.SqlText := 'update axusers set password = ' + quotedstr(pwd) + ',isfirsttime = ' + quotedstr(FirstTime) + ' where '+dbm.gf.sqllower+'(username) = '+ quotedstr(lowercase(uName));
      x.execsql;

      rQry := dbm.GetXDS(nil);
      rQry.Submit('username',trim(uname),'c');
      if adminchange = 'yes' then
         rQry.Submit('pwdchange','Y','c')
      else
      begin
         rQry.Submit('pwdchange','N','c');
         rQry.Submit('pwdchangedate',datetimetostr(dbm.serverdatetime),'d');
         rQry.Submit('prevpwds',prev_pwds,'c');
      end;
      rQry.AddOrEdit('axuserspwdpolicy', dbm.gf.SQLLower+'(username) = '+quotedstr(lowercase(uname)));
      rQry.close;
      dbm.Commit(dbm.Connection.ConnectionName);
    except
      On E:Exception do begin
        dbm.RollBack(dbm.Connection.ConnectionName);
        ErrMsg := E.Message;
      end;
    end;
    if assigned(rQry) then begin
      rQry.close; rQry.Free; rQry := nil;
    end;
    if ErrMsg <> '' then
      Raise Exception.Create(ErrMsg)
    else begin
      if FirstTime='T' then
         Result := 'Password is reset'
      else
        Result := 'Password is changed successfully'

    end;
end;

function TAxProvider.isOldCorrect(pwd,uname : string):Boolean;
var opwd, encpwd : string;
    md5 : MessageDigest_5.IMD5;
begin
  result := false;
  x.close;
  x.sqltext:='select password from axusers where '+dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(uName));
  x.open;
  opwd := x.FieldByName('password').Value;
  encpwd := dbm.gf.EncryptStr(pwd) ;
  if encpwd =  opwd then
  begin
     result := true
  end else
  begin
    md5 := MessageDigest_5.GetMD5();
    md5.Update(pwd);
    encpwd := lowercase(md5.AsString());   // Getting md5 of password
    md5 := nil;
    if encpwd = opwd then result := true;
  end;
end;

function TAxProvider.checkfor_prev_pwds(pwd,uname : string) : boolean;
  var i : integer;
  s : string;
  pwds : TStringList;
begin
  x.close;
  x.sqltext:='select prevpwds from axuserspwdpolicy where '+dbm.gf.sqllower+'(username) = '+quotedstr(lowercase(uName));
  x.open;
  prev_pwds := x.FieldByName('prevpwds').Value;
  result := true;
  pwds := TStringList.Create;
  i := 1;
  prev_pwds := prev_pwds + ',';
  if copy(prev_pwds,1,1) = ',' then
    prev_pwds := Copy(prev_pwds,2,Length(prev_pwds));
  while True do
  begin
   s := dbm.gf.GetNthString(prev_pwds,i);
   if s = '' then break;
   pwds.Add(s);
   inc(i);
  end;
  if pwds.IndexOf(pwd) > -1 then
  begin
     result := false;
     pwds.Clear;
     FreeAndNil(pwds);
     delete(prev_pwds, length(prev_pwds), 1);
     exit;
  end;
  if pwds.Count + 1 > dbm.gf.pwdprevnos then
  begin
    pwds.Delete(0);
    if pwds.IndexOf(pwd) <= 0 then pwds.Add(pwd);
  end else if pwds.IndexOf(pwd) <= 0 then pwds.Add(pwd);
//  prev_pwds := '';
  for i := 0 to pwds.Count - 1 do
      prev_pwds := prev_pwds + pwds.Strings[0] + ',' ;
  delete(prev_pwds, length(prev_pwds), 1);
  pwds.Clear;
  FreeAndNil(pwds);
end;

function TAxProvider.CheckExistanceInTransControl(recid,transid : string): boolean;
var
  loadedOn : TDateTime;
  iTime,mintaken : Integer;
  sqlstr,sId, TableName : String;
  rId : Extended;
  cxds : Txds;
begin
  result := false;
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  TableName := 'axtranscontrol';
  if dbm.gf.MobileWSFlag then TableName := 'axmtranscontrol';
  cxds := dbm.getxds(nil);
  cxds.buffered := true;
  cxds.cds.commandtext:= 'select username from '+TableName+' where recordid = '+recid +
                          ' and sessionid <> '+ QuotedStr(sId) +
                          ' and transid = ' + QuotedStr(transid);
  cxds.cds.open;
  dbm.gf.RecordLockedBy := '';
  if cxds.cds.recordcount > 0 then
  begin
    dbm.gf.RecordLockedBy := cxds.cds.fieldbyname('username').AsString;
    result := true;
  end;
  cxds.close;
  cxds.Destroy;
  cxds := nil;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl ends');
end;

procedure TAxProvider.InsertIntoTransControl(transid: String; recid: extended);
var
  sdate,sqlstr,sId, TableName : string;
  cxds : Txds;
begin
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>InsertIntoTransControl procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  TableName := 'axtranscontrol';
  if dbm.gf.MobileWSFlag then TableName := 'axmtranscontrol';
  cxds := dbm.getxds(nil);
  DeleteTransControl;
  sdate := datetimetostr(dbm.getServerDateTime);
  cxds.Submit('username',dbm.gf.username,'c');
  cxds.Submit('sessionid',sId,'c');
  cxds.Submit('transid',transid,'c');
  cxds.Submit('recordid',floattostr(recid),'n');
  cxds.Submit('loadedon',sdate,'d');
  cxds.AddOrEdit(TableName,'1=2');
  cxds.close;
  cxds.Destroy;
  cxds := nil;
  dbm.gf.DoDebug.msg('>>InsertIntoTransControl procedure end.');
end;

procedure TAxProvider.DeleteTransControl;
var
  sqlstr,sId, TableName : string;
begin
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  TableName := 'axtranscontrol';
  if dbm.gf.MobileWSFlag then TableName := 'axmtranscontrol';
  if dbm.gf.username  <> '' then
    sqlstr := 'delete from '+TableName+' where username = '+QuotedStr(dbm.gf.username) +
              ' and sessionid = '+ QuotedStr(sId)
  else
    sqlstr := 'delete from '+TableName+' where sessionid = '+ QuotedStr(sId);

  ExecSQL(sqlstr,'','',false);
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure ends');
end;

procedure TAxProvider.DeleteTransControl(recid, transid: string;suser:string='');
var
  sId,sqlstr, TableName : string;
begin
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  TableName := 'axtranscontrol';
  if dbm.gf.MobileWSFlag then TableName := 'axmtranscontrol';
  if suser = '' then
  begin
  sqlstr := 'delete from '+TableName+' where sessionid = '+ QuotedStr(sId) +
            ' and recordid = '+ recid + ' and transid = '+ QuotedStr(transid);
  end else
  begin
    sqlstr := 'delete from '+TableName+' where recordid = '+ recid + ' and transid = '+ QuotedStr(transid);
  end;
  ExecSQL(sqlstr,'','',false);
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure ends');
end;


function TAxProvider.GetConstraintName(Tablenm:String):String;
var x1:Txds;
  Sqlstr,fldname:String;
begin
  result :='';
  x1 :=dbm.GetXDS(nil);
  x1.buffered :=true;
  x1.close;
  if dbm.Connection.DbType='ms sql' then begin
   fldname :='constraint_name';
   Sqlstr :=' SELECT  '+fldname+' FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE '+dbm.gf.SQLLower+'(TABLE_NAME) = '+Quotedstr(Lowercase(Tablenm));

  end
  else if dbm.Connection.DbType='oracle' then begin
    fldname :='constraint_name';
    Sqlstr :='Select '+fldname+' from user_constraints where '+dbm.gf.SQLLower+'(Table_name) = '+Quotedstr(Lowercase(Tablenm));
  end;
  if Sqlstr<>'' then begin
    x1.close;
    x1.CDS.CommandText :=Sqlstr;
    x1.open;
    while not x1.CDS.Eof do begin
      Result :=x1.CDS.FieldByName(fldname).AsString;
      x1.CDS.Next;
    end;
  end;
  if Assigned(x1) then begin
    x1.close;
    freeandnil(x1);
  end;
end;

function TAxProvider.GetPrintDocs(stransid:String): IXMLDocument;
var
  xnode,vnode: IXMLNode;
  Formats:string;
begin
  result:=LoadXMLData('<root></root>');
  stransid := lowercase(stransid);
  result.DocumentElement.AddChild('transid').NodeValue:=stransid;
  x.sqltext:='select distinct caption,name,printdoctype from prints where '
             +dbm.gf.sqllower+'(sname) = ' + quotedstr(Lowercase('t'+stransid)) +' and blobno=1 '+ 'order by caption';
  x.open;
  while not x.eof do begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(x.fieldbyname('name').AsString) ;
    if xnode = nil then
    begin
       vnode:=  result.DocumentElement;
       vnode.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
       vnode:=vnode.ChildNodes.FindNode(x.fieldbyname('name').AsString);
       vnode.Attributes['source']:='doc';
     //  result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    end;
    x.next;
  end;
  x.close;
  if dbm.gf.IsService then begin
    Formats:='''msword'',''html'',''docx'',''xls'',''xlsx''';
    GetAxFastList(stransid,Formats,result);
  end;
end;


function TAxProvider.ExtractFRname(Formname:string):string;
var Extn:string;
begin
  Result:='';
  Extn:=ExtractFileExt(Formname);
  if Extn<>'' then Formname:=Copy(Formname,1,Pos('.',Formname)-1);
  Result:=Formname;
end;


function TAxProvider.MakeFRCSVInQoutedStr(CommaSepVal : String):String;
var
  s,fnames:string;
  i : Integer;
begin
  result := '';
  i := 1;
  s := dbm.gf.GetNthString(CommaSepVal,i);
  while s <> '' do
  begin
    s:=ExtractFRname(s);
    if fnames = '' then
      fnames := QuotedStr(s)
    else
      fnames := fnames+','+QuotedStr(s);
    inc(i);
    s := dbm.gf.GetNthString(CommaSepVal,i)
  end;
  if fnames <> '' then result := fnames;
end;

Function TAxProvider.GetFastReportFileExt(stransid,Rname:String):String;
var x : TXDS;
    Emsg :string;
begin
  result := '';
  Emsg := '';
  dbm.gf.DoDebug.msg('Getting FastReport File extension');
  if not TableFound('axfastlink') then begin
    dbm.gf.DoDebug.msg('Axfastlink is not avilable.');
    exit;
  end;
  try
  x := dbm.GetXDS(nil);
  x.buffered := True;
  x.CDS.CommandText := 'select output from axfastlink where '+dbm.gf.sqllower+'(transid) = ' +
            dbm.gf.SQLLower+'(:transid) and '+dbm.gf.sqllower+'(caption) = ' +
            dbm.gf.SQLLower+'(:caption)';
  x.CDS.Params.ParamValues['transid']:= lowercase(stransid);
  x.CDS.Params.ParamValues['caption']:= lowercase(ExtractFilenameWithoutExtension(Rname));
  x.open;
  If x.CDS.RecordCount > 0 then
     result := x.cds.fieldbyname('output').AsString;
     if lowercase(result) = 'msword' then
      result :='doc'
     else if result = '' then
      result:='pdf';
     result := '.'+result;
  Except
     on E : EDatabaseError do
        Emsg := E.Message;
     on E1 : EAccessViolation do
        Emsg := E1.Message;
  end;
  if Emsg <> '' then
     dbm.gf.DoDebug.msg('Error while executing GetFastReportFileExt : ' +Emsg);
  x.close; x:=nil;
end;


Function TAxProvider.ExtractFilenameWithoutExtension(FRfileName : String):String;
var
  Idx : Integer;
Begin
  result := FRfileName;
  if ExtractFileExt(FRfileName) = '' then Exit;
  Idx := FRfileName.LastDelimiter('.' + PathDelim + DriveDelim);
  result := Copy(FRfileName , 1 , Idx);
End;

procedure TAxProvider.InsertIntoTransCheck;
begin
  dbm.gf.GenMapTrans := true;
  if dbm.gf.sessionid = '' then exit;
  xTransCheck.close;
  xTransCheck.sqltext := 'insert into Axp_TransCheck(sessionid) values ('+quotedstr(dbm.gf.sessionid)+')';
  xTransCheck.execsql;
end;

procedure TAxProvider.DeleteFromTransCheck;
begin
  dbm.gf.TransCheckCount := 0;
  dbm.gf.GenMapTrans := false;
  if dbm.gf.sessionid = '' then exit;
  xTransCheck.close;
  xTransCheck.sqltext := 'delete from Axp_TransCheck where sessionid = '+quotedStr(dbm.gf.sessionid);
  xTransCheck.execsql;
end;

Function TAxProvider.ValidateTransCheck:Boolean;
begin
  dbm.gf.DoDebug.msg('uAxProvider\ValidateTransCheck starts.');
  dbm.gf.DoDebug.msg('uAxProvider\SessioID '+dbm.gf.sessionid);
  if dbm.gf.sessionid = '' then result := true
  else
  begin
    result := false;
    forcds.close;
    forcds.buffered := True;
    forcds.cds.CommandText:='select sessionid from Axp_TransCheck where sessionid = '+quotedStr(dbm.gf.sessionid);
    forcds.open;
    if (forcds.CDS.RecordCount + 1 = dbm.gf.TransCheckCount) then
    begin
      dbm.gf.DoDebug.msg('uAxProvider\TransCheckCounts are same.');
      result := true;
    end
    else
    begin
      dbm.gf.DoDebug.msg('uAxProvider\TransCheckCounts : ' + inttostr(forcds.CDS.RecordCount + 1));
      dbm.gf.DoDebug.msg('uAxProvider\TransCheckCount mismatching.');
    end;
    forcds.close;
  end;
  dbm.gf.DoDebug.msg('uAxProvider\ValidateTransCheck ends.');
end;

function TAxProvider.GetOneRecord(SQLText, ParamValues, ParamTypes:String;UniqueVal : String = ''):IXMLDocument;
var i:integer;
    s:string;
    n:ixmlnode;
    dt : TFieldType;
    CDSName : String;
begin
  result:=loadxmldata('<root></root>');
  q.sqltext:=sqltext;
  {
  if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
    CDSName := 'AxProvider_GetOneRecord_'+UniqueVal
  else
    CDSName := 'nolds_AxProvider_GetOneRecord_'+UniqueVal;
  q.SetCDSName(CDSName);
  }
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    q.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;
  if lowercase(copy(sqltext,1,7)) <> 'select ' then
    q.execsql
  else begin
    q.open;
    xnode:=result.DocumentElement;
    while not q.eof do begin
      n:=xnode.AddChild('row');
      for i:=0 to q.Fields.Count-1 do
        n.AddChild(q.fields[i].FieldName).NodeValue:=q.Fields[i].AsString;
      q.next;
    end;
  end;
end;

function TAxProvider.GetStructureForScript(sname,name,caption,purpose: String): IXMLDocument;
var s,w,p:String;
  stm,cstm : TStringStream;
  sfile,tfile : String;
begin
  result:=LoadXMLData('<root></root>');
  p := '';
  if name='' then
  begin
     w := 'caption= :name ';
     p := caption ;
  end else
  begin
     w := dbm.gf.sqllower+'(name)= :name ';
     p := lowercase(name);
  end;
    s :='';
    stm := TStringStream.Create(s);
    dbm.ReadMemo('props', sname, w, p,'c', stm);
    if stm.Size=0 then result:=LoadXMLData('<root/>')
    else begin
        if sname='tstructs' then
        begin
          cstm := TStringStream.Create('');
          stm.Position := 0;
          with TCompress.Create do begin
            cstm := DecompressStream(stm);
            destroy;
          end;
          cstm.Position := 0;
          result := LoadXMLDataFromWS(trim(cstm.DataString)) ;
          cstm.Free;
          result := CheckProduct(name,result);
        end
        else result:=LoadXMLDataFromWS(trim(stm.DataString));
    end;
    dbm.gf.DoDebug.Msg('Step5');
    stm.Free;

    if sname = 'printprops' then
    begin
       s := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       if GetStructName = '' then
         GetPrintTemplate('printprops',name,s)
       else
         GetPrintTemplate('printprops',GetStructName,s);
    end;
end;

function TAxProvider.GetDataFromAppDB(orgXDS : TXDS;TargetConnectionName:AnsiString='') : TXDS;
var appdbm :TDbManager;
    appxds : TXDS;
    j : integer;
    ParamString,d : AnsiString;
begin
  dbm.gf.dodebug.Msg('GetDataFromAppDB method starts.');
  if TargetConnectionName = '' then TargetConnectionName := dbm.webAppCon;
  dbm.gf.dodebug.Msg('TargetConnectionName='+TargetConnectionName);
  if (TargetConnectionName = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid App schema connection name...');
    exit;
  end;
  if not assigned(orgXDS) then
  begin
    dbm.gf.dodebug.Msg('Invalid XDS App schema...');
    exit;
  end;
  appdbm := nil; appxds := nil;
  try
    try
      appdbm := TDbManager.Create;
      appdbm.gf.username := dbm.gf.username;
      appdbm.gf.connectionname := TargetConnectionName;
      appdbm.gf.LocalProps := dbm.gf.LocalProps.CloneNode(True);
      appdbm.conXML := dbm.gf.WebAppConXML;
      appdbm.remoteOpen := False;
      appdbm.SetDefaultValues := false;
      appdbm.ConnectToDatabase(TargetConnectionName);
      appxds := appdbm.GetXDS(nil);
      appxds.buffered := True;
      appxds.CDS.CommandText := orgXDS.CDS.CommandText;
      appxds.CDS.Params := orgXDS.CDS.Params;
      appxds.open;
      orgXDS.CDS.Data := appxds.CDS.Data;
    except On E:Exception do
      begin
        dbm.gf.dodebug.Msg('Error in GetDataFromAppDB :'+E.Message);
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uProfitEval\'+
                  'GetDataFromAppDB - '+e.Message);
        if assigned(appdbm) then appdbm.Rollback(TargetConnectionName);
        raise Exception.Create('Error in GetDataFromAppDB.'+e.Message);
      end;
    end;
  finally
    if assigned(appxds) then begin
      appxds.close; appxds.destroy; appxds := nil;
    end;
    if assigned(appdbm) then begin
      appdbm.destroy; appdbm := nil;
    end;
  end;
  dbm.gf.dodebug.Msg('GetDataFromAppDB method ends.');
  result := orgXDS;
end;

//GetDBM
(*
 Function to get DBManager for the given connectionname
*)
Function TAxProvider.GetDBM(pTargetDBSchemaConnectionName : String):TDBManager;
begin
  dbm.gf.dodebug.Msg('GetDBM method starts.');
  Result := nil;
  try
      try
        Result := TDbManager.Create;
        Result.gf.username := dbm.gf.username;
        Result.gf.connectionname := pTargetDBSchemaConnectionName;
        Result.gf.LocalProps := dbm.gf.LocalProps.CloneNode(True);
        Result.conXML := dbm.gf.WebAppConXML;
        Result.remoteOpen := False;
        Result.SetDefaultValues := false;
        Result.ConnectToDatabase(pTargetDBSchemaConnectionName);
      Except on E:Exception do
         begin
          dbm.gf.dodebug.Msg('Error in GetDBM :'+E.Message);
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\'+
                    'GetDBM - '+e.Message);
          raise Exception.Create('Error in GetDBM.'+e.Message);
        end;
      end;
  finally

  end;
  dbm.gf.dodebug.Msg('GetDBM method ends.');
end;

//Copy table data from one schema to another schema
(*
 This method takes TargetSchema name , sourcetable , wherecondition and targettable as inputs.
 sTargetDBSchemaConnectionName - Target Database connection name.
 sSourceTable - Table to be copied (Source)
 sWhereCond - Filter condition
 sTargetTable - Table to be updated (Target)
                When sTargetTable is empty the source table name will be assigned to Targettablename
*)
Procedure TAxProvider.CopyTableDataBetweenDBSchema(sTargetDBSchemaConnectionName,sSourceTable,sWhereCond : String;sTargetTable:String='');
var targetDBM :TDbManager;
    sourceXDS,targetXDS : TXDS;

    sSQLQuery : String;
    iRowIdx, iColIdx: Integer;

    fField: TField;
    ftFieldType: TFieldType;
    sFieldType, sFieldName, sFieldValue: String;

    sTempFile,sLOBFieldName,sLOBFieldType : String;
    bIsUpdateLOBField , isblob : Boolean;
    strmLOBData : TStringStream;
begin
  dbm.gf.dodebug.Msg('CopyTableDataBetweenDBSchema method starts.');
  if sTargetDBSchemaConnectionName = '' then sTargetDBSchemaConnectionName := dbm.webAppCon;
  dbm.gf.dodebug.Msg('TargetConnectionName='+sTargetDBSchemaConnectionName);
  if (sTargetDBSchemaConnectionName = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid target schema connection name...');
    exit;
  end;
  if (Trim(sSourceTable) = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid source table...');
    exit;
  end;
  if sTargetTable = '' then
    sTargetTable := sSourceTable;
  targetDBM := nil; targetXDS := nil; sourceXDS := nil;
  strmLOBData := nil;
  try
    try
      targetDBM := GetDBM(sTargetDBSchemaConnectionName);
      (*
      targetDBM := TDbManager.Create;
      targetDBM.gf.username := dbm.gf.username;
      targetDBM.gf.connectionname := sTargetDBSchemaConnectionName;
      targetDBM.gf.LocalProps := dbm.gf.LocalProps.CloneNode(True);
      targetDBM.conXML := dbm.gf.WebAppConXML;
      targetDBM.remoteOpen := False;
      targetDBM.SetDefaultValues := false;
      targetDBM.ConnectToDatabase(sTargetDBSchemaConnectionName);
      *)

      sSQLQuery := 'select * from '+sSourceTable;
      if sWhereCond <> '' then
        sSQLQuery := sSQLQuery+' where '+sWhereCond;
      sourceXDS := dbm.GetXDS(nil);
      sourceXDS.buffered := True;
      sourceXDS.CDS.CommandText := sSQLQuery;
      sourceXDS.open;

      targetXDS := targetDBM.GetXDS(nil);

      for iRowIdx := 0 to sourceXDS.CDS.RecordCount - 1 do
      begin
        targetXDS.close;
        for iColIdx := 0 to sourceXDS.Fields.Count - 1 do
        begin
          fField := sourceXDS.Fields[iColIdx];
          ftFieldType := fField.DataType;
          //ftWideMemo considered as datatype 'c' and working , if req it has to be handled in gf GetFieldType
          sFieldType := dbm.gf.GetFieldType(ftFieldType);
          if (sFieldType = 't') or (sFieldType = 'i') then
          begin
            sLOBFieldName := fField.FieldName;
            sLOBFieldType := sFieldType;
            if Not Assigned(strmLOBData) then
              strmLOBData := TStringStream.Create('');
            if sLOBFieldType = 'i' then //blob
              TBlobField(fField).SaveToStream(strmLOBData)
            else //sLOBFieldType = 't'  //clob
              TMemoField(fField).SaveToStream(strmLOBData);
            bIsUpdateLOBField := True;
          end
          else
          begin
            sFieldName := fField.FieldName;
            sFieldValue := VartoStr(fField.Value);
            targetXDS.Submit(sFieldName, sFieldValue, sFieldType);
          end;

        end;

        targetXDS.AddorEdit(sTargetTable,sWhereCond);

        //Update LOB field data  (Memo and blob fields handled here)
        if (bIsUpdateLOBField) and (Assigned(strmLOBData)) then
        begin
//          sTempFile :=dbm.gf.startpath+'\temp\LOBdata'+dbm.gf.getnumber;
//          if Not DirectoryExists(dbm.gf.startpath+'\temp') then
//            ForceDirectories(dbm.gf.startpath+'\temp');

          strmLOBData.Position := 0;
          {
          //Save stream to temporary file
          strmLOBData.SaveToFile(sTempFile);
          if sLOBFieldType = 'i' then //if Blob
            //Call writblob to update blob data in table
            dbm.WriteBlob(sLOBFieldName,sTargetTable,sWhereCond,sTempFile)
          else //sLOBFieldType = 't' //Clob
            //Call writmemo to update clob data in table
            dbm.WriteMemo(sLOBFieldName,sTargetTable,sWhereCond,sTempFile);

          //delete temporary file
          deletefile(sTempFile);
          }
          if sLOBFieldType = 'i' then //if Blob
          begin
            //Call writblob to update blob data in table
            isblob := true;
            dbm.WriteMemo(sLOBFieldName,sTargetTable,sWhereCond,strmLOBData,isblob)
          end else //sLOBFieldType = 't' //Clob
            //Call writmemo to update clob data in table
            dbm.WriteMemo(sLOBFieldName,sTargetTable,sWhereCond,strmLOBData);

          //Reset values
          sTempFile := '';
          sLOBFieldName := '';
          sLOBFieldType := '';
          bIsUpdateLOBField := False;
          FreeAndNil(strmLOBData);
          strmLOBData := nil;
        end;
        sourceXDS.Next;
      end;

    except On E:Exception do
      begin
        dbm.gf.dodebug.Msg('Error in CopyTableDataBetweenDBSchema :'+E.Message);
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\'+
                  'CopyTableDataBetweenDBSchema - '+e.Message);
        if assigned(targetDBM) then targetDBM.Rollback(sTargetDBSchemaConnectionName);
        raise Exception.Create('Error in CopyTableDataBetweenDBSchema.'+e.Message);
      end;
    end;
  finally
    if assigned(sourceXDS) then begin
      sourceXDS.close; FreeAndNil(sourceXDS);
    end;
    if assigned(targetXDS) then begin
      targetXDS.close; FreeAndNil(targetXDS);
    end;
    if Assigned(strmLOBData) then
      FreeAndNil(strmLOBData);
    if assigned(targetDBM) then begin
      FreeAndNil(targetDBM);
    end;
  end;
  dbm.gf.dodebug.Msg('CopyTableDataBetweenDBSchema method ends.');
end;

//ExecuteSQL
(*
  Procedure to ExecuteSQL SQL based on DBM
  Purpose of this method is to execute sql queries on the DBM which is passed to this method
*)
Procedure TAxProvider.ExecuteSQL(pSQLQuery : String;targetDBM : TDBManager= nil);
var
  axpagesXDS : TXDS;
begin
  dbm.gf.dodebug.Msg('ExecuteSQL method starts.');
try
    axpagesXDS := nil;
    if pSQLQuery = '' then
    begin
      dbm.gf.dodebug.Msg('Invalid sql query...');
      exit;
    end;
    if Not Assigned(targetDBM) then
      targetDBM := dbm; //If DBM is nil then take current DBM as targetDBM

    try
      axpagesXDS := targetDBM.GetXDS(nil);
      axpagesXDS.close;
      axpagesXDS.SqlText := pSQLQuery;
      axpagesXDS.execsql;
    Except on E:Exception do
    begin
      dbm.gf.dodebug.Msg('Error in ExecuteSQL :'+E.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\'+
                  'ExecuteSQL - '+e.Message);
    end;
    end;
  finally
    if Assigned(axpagesXDS) then
    begin
      axpagesXDS.close;
      FreeAndNil(axpagesXDS);
    end;
  end;
  dbm.gf.dodebug.Msg('ExecuteSQL method ends.');
end;



//UpdateAxpagesTableforHTMLPage
(*
  Purpose of this method is to update the AXPAGES Table for HTMLPage (transid: sect) or StandardPage (transid: ad_sp)
  This function takes pHTMLPageNo,pHTMLPagecaption ,pIsNewPage and dbm as input.
    This function will be called for both def and app schema update.

    pHTMLPageNo - HTML page no
    pHTMLPagecaption -  HTML page caption
    pIsNewPage - New / Existing page

*)

Procedure TAxProvider.UpdateAxpagesTableforHTMLPage(pHTMLPageNo,pHTMLPagecaption,transid:String;pIsNewPage : Boolean;targetDBM : TDBManager= nil);
var
  //axpagesXDS : TXDS;
  sSQLQuery,HtmlOrdNo : String;
begin
  dbm.gf.dodebug.Msg('UpdateAxpagesTableforHTMLPage method starts.');
  try
    //axpagesXDS := nil;
    if Not Assigned(targetDBM) then
      targetDBM := dbm; //If DBM is nil then take current DBM as targetDBM
    if (pHTMLPageNo = '') then
    begin
      dbm.gf.dodebug.Msg('Invalid HTML page name...');
      exit;
    end;
    try
      //If required DB wise query needs to be handled.
      if transid = 'sect' then
      begin
        if pIsNewPage then begin
          HtmlOrdNo := GetHTMLOrdNo(targetDBM);
          sSQLQuery := 'insert into axpages (name, caption, props, blobno, visible, type, ordno, levelno,'+
              ' updatedon, createdon, createdby, updatedby, pagetype, websubtype) values '+
              '('+ QuotedStr('HP'+pHTMLPageNo)+','+QuotedStr(pHTMLPagecaption)+','+
              QuotedStr('htmlPages.aspx?load='+pHTMLPageNo)+', 1, ''T'', ''p'','+
              HtmlOrdNo+',0,'+QuotedStr(datetimetostr(targetDBM.serverdatetime))+','+
              QuotedStr(datetimetostr(targetDBM.serverdatetime))+','+QuotedStr(targetDBM.gf.userName)+ ','+
              QuotedStr(targetDBM.gf.userName) +',''web'',''htmlpage'')';
        end
        else
          sSQLQuery := 'update axpages set caption = '+ QuotedStr(pHTMLPagecaption) + ','+
              'updatedon = '+ QuotedStr(datetimetostr(targetDBM.serverdatetime)) +
              ' where name = '+ QuotedStr('HP'+pHTMLPageNo);
        ExecuteSQL(sSQLQuery,targetDBM);
      end else if transid = 'ad_sp' then
      begin
        if pIsNewPage then begin
          HtmlOrdNo := GetHTMLOrdNo(targetDBM);
          sSQLQuery := 'insert into axpages (name, caption, props, blobno, visible, type, ordno, levelno,'+
              ' updatedon, createdon, createdby, updatedby, pagetype, websubtype) values '+
              '('+ QuotedStr('SP'+pHTMLPageNo)+','+QuotedStr(pHTMLPagecaption)+','+
              QuotedStr('standardPage.aspx?pageid='+pHTMLPageNo)+', 1, ''T'', ''p'','+
              HtmlOrdNo+',0,'+QuotedStr(datetimetostr(targetDBM.serverdatetime))+','+
              QuotedStr(datetimetostr(targetDBM.serverdatetime))+','+QuotedStr(targetDBM.gf.userName)+ ','+
              QuotedStr(targetDBM.gf.userName) +',''web'',''standardpage'')';
        end
        else
          sSQLQuery := 'update axpages set caption = '+ QuotedStr(pHTMLPagecaption) + ','+
              'updatedon = '+ QuotedStr(datetimetostr(targetDBM.serverdatetime)) +
              ' where name = '+ QuotedStr('SP'+pHTMLPageNo);
        ExecuteSQL(sSQLQuery,targetDBM);
      end;
    Except on E:Exception do
    begin
      dbm.gf.dodebug.Msg('Error in UpdateAxpagesTableforHTMLPage :'+E.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\'+
                  'UpdateAxpagesTableforHTMLPage - '+e.Message);
    end;
    end;
  finally
    (*
    if Assigned(axpagesXDS) then
    begin
      axpagesXDS.close;
      FreeAndNil(axpagesXDS);
    end;
    *)
  end;
  dbm.gf.dodebug.Msg('UpdateAxpagesTableforHTMLPage method ends.');
end;

Procedure TAxProvider.CopyFlatTableDataBetweenDBSchema(sSourceTable : AnsiString ; sTargetDBSchemaConnectionName : AnsiString = '');
var targetDBM :TDbManager;
    sourceXDS,targetXDS : TXDS;
    sSQLQuery , dtype , PageName : AnsiString;
    iRowIdx, iColIdx: Integer;
    s : string;
begin
  dbm.gf.dodebug.Msg('CopyTableDataBetweenDBSchema method starts.');
  if sTargetDBSchemaConnectionName = '' then sTargetDBSchemaConnectionName := dbm.webAppCon;
  dbm.gf.dodebug.Msg('TargetConnectionName='+sTargetDBSchemaConnectionName);
  if (sTargetDBSchemaConnectionName = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid target schema connection name...');
    exit;
  end;
  if (Trim(sSourceTable) = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid source table...');
    exit;
  end;
  targetDBM := nil; targetXDS := nil; sourceXDS := nil;
  try
    try
      targetDBM := GetDBM(sTargetDBSchemaConnectionName);
      sSQLQuery := 'select * from '+sSourceTable;
      sourceXDS := dbm.GetXDS(nil);
      sourceXDS.buffered := True;
      sourceXDS.CDS.CommandText := sSQLQuery;
      sourceXDS.open;
      targetXDS := targetDBM.GetXDS(nil);
      targetDBM.ConnectToDatabase(sTargetDBSchemaConnectionName);
      if sSourceTable = 'axpages' then
      begin
        try
          dbm.gf.dodebug.Msg('Delete table ' + sSourceTable + ' in CopyFlatTableDataBetweenDBSchema function');
          sSQLQuery := 'delete from '+sSourceTable;
          targetXDS.SqlText := sSQLQuery;
          targetXDS.execsql;
          dbm.gf.dodebug.Msg('Delete table ' + sSourceTable + ' in CopyFlatTableDataBetweenDBSchema function done');
        Except on e:exception do
          begin
            dbm.gf.dodebug.Msg('Error in CopyFlatTableDataBetweenDBSchema : '+E.Message);
            //raise Exception.Create('Error in CopyTableDataBetweenDBSchema.'+e.Message);
          end;
        end;
      end;
      dbm.gf.dodebug.Msg(sSourceTable + ' Record Count : '+ inttostr(sourceXDS.CDS.RecordCount));
      if sSourceTable = 'axpages' then
      begin
        dbm.gf.dodebug.Msg('copying AxPages table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          targetXDS.Append(sSourceTable);
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
          end;
          targetXDS.Post;
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying AxPages table ends...');
      end else if sSourceTable = 'axpdef_tstruct' then
      begin
        dbm.gf.dodebug.Msg('copying axpdef_tstruct table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          PageName := '';
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
              if lowercase(sourceXDS.CDS.Fields[iColIdx].FieldName) = 'axpdef_tstructid' then
              begin
                 PageName := sourceXDS.CDS.Fields[iColIdx].AsString;
              end;
          end;
          targetXDS.AddOrEdit(sSourceTable,'axpdef_tstructid='+ QuotedStr(PageName));
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying axpdef_tstruct table ends...');
      end else if sSourceTable = 'dwb_iviews' then
      begin
        dbm.gf.dodebug.Msg('copying dwb_iviews table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          PageName := '';
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
              if lowercase(sourceXDS.CDS.Fields[iColIdx].FieldName) = 'dwb_iviewsid' then
              begin
                 PageName := sourceXDS.CDS.Fields[iColIdx].AsString;
              end;
          end;
          targetXDS.AddOrEdit(sSourceTable,'dwb_iviewsid='+ QuotedStr(PageName));
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying dwb_iviews table ends...');
      end;
      if sSourceTable = 'axlanguage' then
      begin
        try
          dbm.gf.dodebug.Msg('Delete table ' + sSourceTable + ' in CopyFlatTableDataBetweenDBSchema function');
          sSQLQuery := 'delete from '+sSourceTable;
          targetXDS.SqlText := sSQLQuery;
          targetXDS.execsql;
          dbm.gf.dodebug.Msg('Delete table ' + sSourceTable + ' in CopyFlatTableDataBetweenDBSchema function done');
          dbm.gf.dodebug.Msg('Delete table axlangsource in CopyFlatTableDataBetweenDBSchema function');
          sSQLQuery := 'delete from axlangsource';
          targetXDS.SqlText := sSQLQuery;
          targetXDS.execsql;
          dbm.gf.dodebug.Msg('Delete table axlangsource in CopyFlatTableDataBetweenDBSchema function done');
        Except on e:exception do
          begin
            dbm.gf.dodebug.Msg('Error in CopyFlatTableDataBetweenDBSchema : '+E.Message);
            //raise Exception.Create('Error in CopyTableDataBetweenDBSchema.'+e.Message);
          end;
        end;
      end;
      dbm.gf.dodebug.Msg(sSourceTable + ' Record Count : '+ inttostr(sourceXDS.CDS.RecordCount));
      if sSourceTable = 'axlanguage' then
      begin
        dbm.gf.dodebug.Msg('copying axlanguage table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          targetXDS.Append(sSourceTable);
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
          end;
          targetXDS.Post;
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying axlanguage table ends...');
        //------
        dbm.gf.dodebug.Msg('copying axlangsource table...');
        sourceXDS.close;
        sourceXDS.CDS.CommandText := 'select language,fontcharset,fontname,fontsize from AXPDEF_LANGUAGE';
        sourceXDS.open;
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          targetXDS.Append('axlangsource');
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              s := sourceXDS.CDS.Fields[iColIdx].FieldName;
              if lowercase(s) = 'language' then s := 'langname';
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(s,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
          end;
          targetXDS.Post;
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying axlangsource table ends...');
        //------
      end
      except On E:Exception do
      begin
        dbm.gf.dodebug.Msg('Error in CopyFlatTableDataBetweenDBSchema :'+E.Message);
        if assigned(targetDBM) then targetDBM.Rollback(sTargetDBSchemaConnectionName);
        raise Exception.Create('Error in CopyTableDataBetweenDBSchema.'+e.Message);
      end;
    end;
  finally
    if assigned(sourceXDS) then begin
      sourceXDS.close; FreeAndNil(sourceXDS);
    end;
    if assigned(targetXDS) then begin
      targetXDS.close; FreeAndNil(targetXDS);
    end;
    if assigned(targetDBM) then begin
      FreeAndNil(targetDBM);
    end;
  end;
  dbm.gf.dodebug.Msg('CopyTableDataBetweenDBSchema method ends.');
end;

function TAxProvider.MenuXMLForArrangeMenu(headname,headlevel : String) : IXMLDocument;
  var pnode,cnode,iconNode,icNode : IXMLNode;
  s , p , c , t,pp,ptype,pagenames : String;
  i , j, k,l,level,hidelevel,icdelm: integer;
  hlist : TList;
  hdlist : HeadList;
  added : boolean;
  Errorstr :String;
  intview, img, icon : String;
  iHiddenMainLevel, ExprListCount : Integer;
  SqlTxt,OrgSqlTxt,OrdTxt,vis : string;
begin
  if headlevel <> '' then
  begin
    result := GetMultiLevelMenuInfo(headname,headlevel) ;
    exit;
  end;
  SqlTxt := '';
  ExprListCount := 1;
  result:=LoadXMLData('<root></root>');
  if dbm.gf.Applanguage = '' then
  begin
    if pos('default',dbm.gf.userroles) > 0 then
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 order by ordno ,levelno '
    else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      try
        Errorstr :='';
        x.open;
      except on e:Exception do
        Errorstr :=e.Message;
      end;
      if Errorstr<>'' then begin
        if not FieldFound('webenable','axpages') then begin
          CreateField('axpages','webenable','c',1,0);
          x.open;
        end;
      end;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      OrgSqlTxt := ' select name,caption,type,visible,img,parent,ordno,levelno,props,pagetype,intview,icon from axpages where blobno=1 and name in';
      OrdTxt := ' order by ordno, levelno ';
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        begin
          s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          Inc(ExprListCount);
        end;
        if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
        begin
           s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
           Inc(ExprListCount);
        end;
        x.next;
        if ExprListCount >= 999 then begin
          delete(s,length(s),2);
          if SqlTxt = '' then
             SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
          else
             SqlTxt := SqlTxt + ' Union all '+OrgSqlTxt+' ( ' + s + ' ) ';
          s := '';
          ExprListCount := 1;
        end;
      end;
      if s <> '' then delete(s,length(s),2);
      if (ExprListCount > 1) then begin
         if (SqlTxt = '') then
            SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
         else
            SqlTxt := SqlTxt + ' Union all '+ OrgSqlTxt+' ( ' + s + ' ) ' ;
      end;
      if SqlTxt = '' then raise exception.Create('User Roles not defined for this user');
      SqlTxt := 'select * from ('+SqlTxt+') a '+OrdTxt;
      x.close;
      x.sqltext:= SqlTxt;
    end;
  end else
  begin
    if pos('default',dbm.gf.userroles) > 0 then
    begin
      s:='select a.name,a.caption,a.type,a.visible,a.img,a.parent,a.levelno,a.props,a.pagetype, a.icon, ';
      s:=s+'(case when b.compcaption is null then a.caption else b.compcaption end) as compcaption,a.intview from axpages a ';
      s:=s+'left outer join axlanguage b on '+dbm.gf.sqllower +'(b.dispname) = ' + quotedstr(lowercase(dbm.gf.Applanguage)) + ' and lower(a.name) = lower(b.compname) ';
      s:=s+'where a.blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and ';
      s:=s+' lower(' + dbm.gf.sqlnull + '(a.pagetype,''s'')) <> ''stem'' order by a.ordno ,a.levelno ';
      x.sqltext:= s;
    end
    else
    begin
      s := '';
      x.sqltext:='select name,caption,type,visible,img,parent,levelno,props,pagetype,intview,icon from axpages where blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(pagetype,''s'')) <> ''stem'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
      try
        Errorstr :='';
        x.open;
      except on e:Exception do
        Errorstr :=e.Message;
      end;
      if Errorstr<>'' then begin
        if not FieldFound('webenable','axpages') then begin
          CreateField('axpages','webenable','c',1,0);
          x.open;
        end;
      end;
      if x.isempty then raise exception.Create('User Roles not defined for this user');
      OrgSqlTxt := ' select a.name,a.caption,a.type,a.visible,a.img,a.parent,a.ordno,a.levelno,a.props,a.pagetype,a.icon , (case when b.compcaption is null then a.caption else b.compcaption end)'+' as compcaption,a.intview from axpages a left outer join axlanguage b on '+dbm.gf.sqllower +'(dispname) = ' + quotedstr(lowercase(dbm.gf.Applanguage)) + ' and lower(a.name) = lower(b.compname) where a.blobno=1 and lower('+dbm.gf.sqlnull+'(webenable,''t'')) =''t'' and '+'lower(' + dbm.gf.sqlnull + '(a.pagetype,''s'')) <> ''stem'' and name in ';
      OrdTxt := ' order by a.ordno ,a.levelno ';
      while not x.eof do begin
        if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        begin
          s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
          Inc(ExprListCount);
        end;
        if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
        begin
           s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
          Inc(ExprListCount);
        end;
        x.next;
        if ExprListCount >= 999 then begin
          delete(s,length(s),2);
          if SqlTxt = '' then
             SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
          else
             SqlTxt := SqlTxt + ' Union all '+OrgSqlTxt+' ( ' + s + ' ) ';
          s := '';
          ExprListCount := 1;
        end;
      end;
      if s <> '' then delete(s,length(s),2);
      if (ExprListCount > 1) then begin
         if (SqlTxt = '') then
            SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
         else
            SqlTxt := SqlTxt + ' Union all '+ OrgSqlTxt+' ( ' + s + ' ) ' ;
      end;
      if SqlTxt = '' then raise exception.Create('User Roles not defined for this user');
      SqlTxt := 'select * from ('+SqlTxt+') a '+OrdTxt;
      x.close;
      x.sqltext:= SqlTxt;
    end;
  end;
  s := '';
  try
    Errorstr :='';
    if not x.Active then x.open;
  except on e:Exception do
    begin
      Errorstr :=e.Message;
      dbm.gf.DoDebug.Msg('Error : ' + Errorstr);
    end;
  end;
  if Errorstr<>'' then begin
    if not FieldFound('webenable','axpages') then begin
      CreateField('axpages','webenable','c',1,0);
      x.open;
    end;
  end;
  pnode := result.DocumentElement;
  j := -1;
  k := 0;
  x.first;
  hlist := TList.Create;
  level:=-1;
  hidelevel := -1;
  iHiddenMainLevel := -1;
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    if s = 'inbox' then
    begin
       x.next;
       continue
    end;
    p := x.fieldbyname('parent').asstring;
    t := x.fieldbyname('type').AsString ;
    i := x.fieldbyname('levelno').AsInteger;
    intview := x.FieldByName('intview').AsString;
    icon := x.FieldByName('icon').AsString;
    dbm.gf.DoDebug.Msg('Name : ' + s);
    if dbm.gf.Applanguage <> '' then
    begin
      c := x.fieldbyname('compcaption').asstring;
      if c = '' then c := x.fieldbyname('caption').asstring;
    end else c := x.fieldbyname('caption').asstring;
    ptype := x.fieldbyname('pagetype').AsString;
    img := x.fieldbyname('img').AsString;

    if ptype = 'web' then
       pp := x.fieldbyname('props').AsString
    else
       pp := '';
    if i <= iHiddenMainLevel then
      iHiddenMainLevel := -1;
    (*
    if x.fieldbyname('visible').asstring = 'F' then
    begin
      if iHiddenMainLevel = -1 then
        iHiddenMainLevel := i;
        if t = 'h' then hidelevel := i;
        x.next;
        continue;
    end;
    if hidelevel > -1 then
    begin
       if i > hidelevel then
       begin
         x.next;
         continue;
       end else hidelevel := -1;
    end;
    if (iHiddenMainLevel <> -1) and (i > iHiddenMainLevel) then
    begin
      x.Next;
      Continue;
    end;
    *)
    vis := x.fieldbyname('visible').AsString;
    if i > level then begin
      if level=-1 then
        pnode:=result.documentelement
      else begin
          try
          pnode:=headList(hlist.Items[level]).hnode
          except on e:exception do
          begin
           dbm.gf.DoDebug.Msg('Parent not found 1');
           x.Next;
           Continue;
          end;
        end;
      end;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      new(hdList);
      hdlist.hnode := cnode;
      hlist.Add(hdList);
      level:=i;
    end else if i < level then begin
      k:=i+1 ;
      for l:=level downto k do begin
        if hlist.Count > l then hlist.delete(l);
      end;
      level := i;
      if level>0 then
      begin
          try
           pnode:=headList(hlist.Items[level-1]).hnode
          except on e:exception do
          begin
           dbm.gf.DoDebug.Msg('Parent not found 2');
           x.Next;
           Continue;
          end;
          end;
      end else
        pnode:=result.documentelement;
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end else begin
      if i=0 then
         cnode:=pnode.AddChild('parent')
      else
         cnode:=pnode.AddChild('child');
      headList(hlist.Items[level]).hnode:=cnode;
    end;
    if i > j then j := i;
    if copy(ptype,1,1) = 'i' then
    begin
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'iview.aspx?ivname=' + ptype;
    end else if copy(ptype,1,1) = 't' then
    begin
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'tstruct.aspx?transid=' + ptype ;
    end else if copy(ptype,1,1) = 'n' then
    begin
       delete(ptype,1,1);
       cnode.Attributes['target'] := 'iviewInteractive.aspx?ivname=' + ptype;
    end else if pp <> '' then
       cnode.Attributes['target'] := pp
    else
       cnode.Attributes['target'] :=  '';
    cnode.Attributes['name'] := c;
    cnode.Attributes['url'] := pp;
    cnode.Attributes['level'] := inttostr(i);
    cnode.Attributes['oname'] := s;
    cnode.Attributes['intview'] := intview;
    cnode.Attributes['visible'] := vis;
    cnode.Attributes['img'] := img;
    if (icon <> '') then
    begin
	    icdelm := Pos('|', icon);
      if icdelm > 0 then
      begin
        iconNode := cnode.AddChild('icon');
        icNode := iconNode.AddChild('text');
        icNode.Text := Copy(icon, 0, icdelm-1);;
        icNode := iconNode.AddChild('addClass');
        icNode.Text := Copy(icon, icdelm+ 1, length(icon));
      end
      else
        begin
          iconNode := cnode.AddChild('icon');
          iconNode.Text := icon;
        end;
    end;
    x.next;
  end;
  result.DocumentElement.Attributes['max'] := inttostr(j);
  x.close;
  for i:=0 to hlist.count-1 do begin
    dispose(headlist(hlist[i]));
  end;
  hlist.clear;
end;


function TAxProvider.GetHTMLOrdNo(tDBM : TDbManager) : String; 
var q : TXDS;
begin
  try
    try
      Result := '1';
      q := tDBM.GetXDS(nil);
      q.buffered := True;
      q.CDS.CommandText := 'select max(ordno)+1 from axpages';
      q.open;
      if not q.CDS.IsEmpty then
        Result := q.CDS.Fields[0].AsString;
    Except on E:Exception do
      tDBM.gf.dodebug.Msg('Error in GetHTMLOrdNo :'+E.Message);
    end;
  finally
    if Assigned(q) then begin
      q.close; q.Destroy; q:=nil;
    end;
  end;
end;



//AlterNOTNULLConstraint
(*
Procedure to add / drop NOT NULL constraints.
Mysql and MSSQL requires column definition at the time of NOT NULL constraint update , thats the reason
we are taking column definition details as parameters.
*)
procedure TAxProvider.AlterNOTNULLConstraint(sTableName,sColumnName,sDataType: String; iWidth, iDec: integer;bToModify:Boolean=False;bIsNullable:Boolean=True);
var
  sSQLQuery,sJoinStr : String;
begin
  Try
    q.close;
    if dbm.Connection.DbType = 'postgre' then
    begin
      if Not bIsNullable then
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER COLUMN '+sColumnName+' SET NOT NULL'
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER COLUMN '+sColumnName+' DROP NOT NULL';
    end
    else if dbm.Connection.DbType = 'oracle' then
    begin
      if Not bIsNullable then
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sColumnName+' NOT NULL'
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sColumnName+' NULL';
    end
    else if dbm.Connection.DbType = 'mysql' then
    begin
      sJoinStr := GetJoinStr(sColumnName,sDataType,iWidth,iDec,bToModify);
      if Not bIsNullable then
         sSQLQuery := 'ALTER TABLE '+sTableName+' CHANGE '+sColumnName+' '+ sJoinStr +' NOT NULL'
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' CHANGE '+sColumnName+' '+sJoinStr;
    end
    else if dbm.Connection.DbType = 'ms sql' then
    begin
      sJoinStr := GetJoinStr(sColumnName,sDataType,iWidth,iDec,bToModify);
      if Not bIsNullable then
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER COLUMN '+sJoinStr+' NOT NULL'
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER COLUMN '+sJoinStr;
    end;
    q.SQlText := sSQLQuery;
    q.ExecSQL;
  Except
  on e:Exception do begin
    dbm.gf.DoDebug.msg('Error in AlterNOTNULLConstraint '+E.Message);
   end;
  End;
end;


(*
Procedure to add / drop DEFAULT constraints.
*)
procedure TAxProvider.AlterDEFAULTConstraint(sTableName,sColumnName,sDataType: String; iWidth, iDec: integer;bToModify:Boolean=False;bIsNullable:Boolean=True;sDefaultValue:String='');
var
  sSQLQuery,sJoinStr : String;
begin
  Try
    q.close;
    if dbm.Connection.DbType = 'postgre' then
    begin
      if sDefaultValue <> '' then
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER '+sColumnName+' SET DEFAULT '+ {StringReplace(}sDefaultValue{,'''','''''',[rfReplaceAll])}
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER '+sColumnName+' DROP DEFAULT';
    end
    else if dbm.Connection.DbType = 'oracle' then
    begin
      if sDefaultValue <> '' then
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sColumnName+' DEFAULT '+ {StringReplace(}sDefaultValue{,'''','''''',[rfReplaceAll])}
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sColumnName+' DEFAULT NULL';
    end
    else if dbm.Connection.DbType = 'mysql' then
    begin
      sJoinStr := GetJoinStr(sColumnName,sDataType,iWidth,iDec,bToModify);
      if Not bIsNullable then //if nullable false then add NOT NULL Constraint
        sJoinStr := sJoinStr + ' NOT NULL ';
      (*
      if sDefaultValue <> '' then
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER '+sColumnName+' SET DEFAULT '+ StringReplace(sDefaultValue,'''','''''',[rfReplaceAll])
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' ALTER '+sColumnName+' DROP DEFAULT';
      *)
      //For DATE datatype , SET DEFAULT not working / due to that we are using below queries
      if sDefaultValue <> '' then
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sJoinStr+' DEFAULT '+ {StringReplace(}sDefaultValue{,'''','''''',[rfReplaceAll])}
      else
         sSQLQuery := 'ALTER TABLE '+sTableName+' MODIFY '+sJoinStr;
    end
    else if dbm.Connection.DbType = 'ms sql' then
    begin
      try
        ExecSQL('ALTER TABLE ' +sTableName+' DROP CONSTRAINT '+'df_'+sTableName+'_'+sColumnName,'','',false);
      except
      end;
      if sDefaultValue <> '' then
         sSQLQuery := 'ALTER TABLE '+sTableName+' ADD CONSTRAINT '+'df_'+sTableName+'_'+sColumnName+' DEFAULT '+ {StringReplace(}sDefaultValue{,'''','''''',[rfReplaceAll])}+' FOR '+sColumnName
      else
         sSQLQuery := 'ALTER TABLE ' +sTableName+' DROP CONSTRAINT '+'df_'+sTableName+'_'+sColumnName;
    end;
    q.SQlText := sSQLQuery;
    q.ExecSQL;
  Except
  on e:Exception do begin
    dbm.gf.DoDebug.msg('Error in AlterDEFAULTConstraint '+E.Message);
   end;
  End;
end;

Procedure TAxProvider.CopyFlatTableDataFromDefToApp(sSourceTable : AnsiString ; sTargetDBSchemaConnectionName : AnsiString = '' ; sWhereCond : AnsiString = '');
var targetDBM :TDbManager;
    sourceXDS,targetXDS : TXDS;
    sSQLQuery , dtype , PageName : AnsiString;
    iRowIdx, iColIdx: Integer;
begin
  dbm.gf.dodebug.Msg('CopyFlatTableDataFromDefToApp method starts.');
  if sTargetDBSchemaConnectionName = '' then sTargetDBSchemaConnectionName := dbm.webAppCon;
  dbm.gf.dodebug.Msg('TargetConnectionName='+sTargetDBSchemaConnectionName);
  if (sTargetDBSchemaConnectionName = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid target schema connection name...');
    exit;
  end;
  if (Trim(sSourceTable) = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid source table...');
    exit;
  end;
  targetDBM := nil; targetXDS := nil; sourceXDS := nil;
  try
    try
      targetDBM := GetDBM(sTargetDBSchemaConnectionName);
      targetDBM.ConnectToDatabase(sTargetDBSchemaConnectionName);
      sSQLQuery := 'select * from '+sSourceTable;
      if (sWhereCond <> '') then
         sSQLQuery := sSQLQuery +' '+ sWhereCond;
      sourceXDS := targetDBM.GetXDS(nil);
      sourceXDS.buffered := True;
      sourceXDS.CDS.CommandText := sSQLQuery;
      sourceXDS.open;
      targetXDS := dbm.GetXDS(nil);
      dbm.gf.dodebug.Msg(sSourceTable + ' Record Count : '+ inttostr(sourceXDS.CDS.RecordCount));
      if sSourceTable = 'axpages' then
      begin
        dbm.gf.dodebug.Msg('copying AxPages table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          targetXDS.Append(sSourceTable);
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
          end;
          targetXDS.Post;
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying AxPages table ends...');
      end else if sSourceTable = 'axpdef_tstruct' then
      begin
        dbm.gf.dodebug.Msg('copying axpdef_tstruct table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          PageName := '';
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
              if lowercase(sourceXDS.CDS.Fields[iColIdx].FieldName) = 'axpdef_tstructid' then
              begin
                 PageName := sourceXDS.CDS.Fields[iColIdx].AsString;
              end;
          end;
          targetXDS.AddOrEdit(sSourceTable,'axpdef_tstructid='+ QuotedStr(PageName));
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying axpdef_tstruct table ends...');
      end else if sSourceTable = 'dwb_iviews' then
      begin
        dbm.gf.dodebug.Msg('copying dwb_iviews table...');
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          PageName := '';
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
              if lowercase(sourceXDS.CDS.Fields[iColIdx].FieldName) = 'dwb_iviewsid' then
              begin
                 PageName := sourceXDS.CDS.Fields[iColIdx].AsString;
              end;
          end;
          targetXDS.AddOrEdit(sSourceTable,'dwb_iviewsid='+ QuotedStr(PageName));
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying dwb_iviews table ends...');
      end
      else
      begin
        dbm.gf.dodebug.Msg('copying '+sSourceTable+' table...');
        //Delete data from the table if exists
        if sWhereCond <> '' then
          ExecuteSQL('delete from '+sSourceTable+' '+sWhereCond,dbm);
        sourceXDS.CDS.First;
        while not sourceXDS.CDS.Eof do
        begin
          targetXDS.close;
          targetXDS.Append(sSourceTable);
          for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
          begin
              dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
              targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
          end;
          targetXDS.Post;
          sourceXDS.CDS.Next;
        end;
        dbm.gf.dodebug.Msg('copying '+sSourceTable+' table ends...');
      end
    except On E:Exception do
      begin
        dbm.gf.dodebug.Msg('Error in CopyFlatTableDataFromDefToApp :'+E.Message);
        if assigned(targetDBM) then targetDBM.Rollback(sTargetDBSchemaConnectionName);
        raise Exception.Create('Error in CopyFlatTableDataFromDefToApp.'+e.Message);
      end;
    end;
  finally
    if assigned(sourceXDS) then begin
      sourceXDS.close; FreeAndNil(sourceXDS);
    end;
    if assigned(targetXDS) then begin
      targetXDS.close; FreeAndNil(targetXDS);
    end;
    if assigned(targetDBM) then begin
      FreeAndNil(targetDBM);
    end;
  end;
  dbm.gf.dodebug.Msg('CopyFlatTableDataFromDefToApp method ends.');
end;

//CopyFlatTableDataBetweenSchema
(*
Given table data will be copied from source schema to target schema
*)
Procedure TAxProvider.CopyFlatTableDataBetweenSchema(sSourceTable,sPrimaryField : AnsiString;bDeleteIfExists : Boolean = True; sTargetDBSchemaConnectionName : AnsiString = '');
var targetDBM :TDbManager;
    sourceXDS,targetXDS : TXDS;
    sSQLQuery , dtype , PageName : AnsiString;
    iRowIdx, iColIdx: Integer;
    bDeleteRecIfExists : Boolean;
    curStruct,prevStruct : String;
begin
  dbm.gf.dodebug.Msg('CopyFlatTableDataBetweenSchema method starts.');
  if sTargetDBSchemaConnectionName = '' then sTargetDBSchemaConnectionName := dbm.webAppCon;
  dbm.gf.dodebug.Msg('TargetConnectionName='+sTargetDBSchemaConnectionName);
  if (sTargetDBSchemaConnectionName = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid target schema connection name...');
    exit;
  end;
  if (Trim(sSourceTable) = '') then
  begin
    dbm.gf.dodebug.Msg('Invalid source table...');
    exit;
  end;
  targetDBM := nil; targetXDS := nil; sourceXDS := nil;
  try
    try
      bDeleteRecIfExists := False;
      targetDBM := GetDBM(sTargetDBSchemaConnectionName);
      targetDBM.ConnectToDatabase(sTargetDBSchemaConnectionName);
      sSQLQuery := 'select * from '+sSourceTable;
      sourceXDS := dbm.GetXDS(nil);
      sourceXDS.buffered := True;
      sourceXDS.CDS.CommandText := sSQLQuery;
      sourceXDS.open;
      targetXDS := targetDBM.GetXDS(nil);
      dbm.gf.dodebug.Msg(sSourceTable + ' Record Count : '+ inttostr(sourceXDS.CDS.RecordCount));

      dbm.gf.dodebug.Msg('copying '+sSourceTable+' table...');
      sourceXDS.CDS.First;
      bDeleteRecIfExists := (bDeleteIfExists and (Trim(sPrimaryField) <> ''));
      curStruct := '';prevStruct := '';
      while not sourceXDS.CDS.Eof do
      begin
        //Delete existing data using primary field value
        curStruct := sourceXDS.CDS.FieldByName(sPrimaryField).AsString;
        if (bDeleteRecIfExists) and (curStruct <> prevStruct) then
          ExecuteSQL('delete from '+sSourceTable+' where '+sPrimaryField+' = '+quotedstr(curStruct),targetDBM);
        targetXDS.close;
        targetXDS.Append(sSourceTable);
        for iColIdx := 0 to sourceXDS.CDS.Fields.Count - 1 do
        begin
            dtype := lowercase(Copy(dbm.gf.GetDataType(sourceXDS.CDS.Fields[iColIdx].DataType),1,1));
            targetXDS.Submit(sourceXDS.CDS.Fields[iColIdx].FieldName,sourceXDS.CDS.Fields[iColIdx].AsString,dtype);
        end;
        targetXDS.Post;
        sourceXDS.CDS.Next;
        prevStruct := curStruct;
      end;
      dbm.gf.dodebug.Msg('copying '+sSourceTable+' table ends...');

    except On E:Exception do
      begin
        dbm.gf.dodebug.Msg('Error in CopyFlatTableDataBetweenSchema :'+E.Message);
        if assigned(targetDBM) then targetDBM.Rollback(sTargetDBSchemaConnectionName);
        raise Exception.Create('Error in CopyFlatTableDataBetweenSchema.'+e.Message);
      end;
    end;
  finally
    if assigned(sourceXDS) then begin
      sourceXDS.close; FreeAndNil(sourceXDS);
    end;
    if assigned(targetXDS) then begin
      targetXDS.close; FreeAndNil(targetXDS);
    end;
    if assigned(targetDBM) then begin
      FreeAndNil(targetDBM);
    end;
  end;
  dbm.gf.dodebug.Msg('CopyFlatTableDataBetweenSchema method ends.');
end;

function TAxProvider.CheckAxProcessDef(transtype : string;PEGVersion:String='') : TXDS;
var
  pegXDS : TXDS;
begin
  dbm.gf.DoDebug.msg('CheckAxProcessDef starts...');
  pegXDS := nil;
  try
    pegXDS := dbm.GetXDS(nil);
    pegXDS.buffered := True;
    PEGVersion := lowercase(PEGVersion);
    if (PEGVersion = '') or (PEGVersion='v1') then
    begin
      //PEG V1 definition table check
      pegXDS.cds.CommandText := 'select * from AxProcessDef where '+dbm.gf.sqllower+
                                '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
                                dbm.gf.sqllower+'(active)=''t'' and '+
                                dbm.gf.sqllower+'(tasktype)=''make'' ';
      pegXDS.open;
      if pegXDS.CDS.RecordCount > 0 then
        result := pegXDS
    end;
    if ( (((pegXDS.CDS.Active) and (pegXDS.CDS.RecordCount=0)) and (PEGVersion = '')) or (PEGVersion='v2')) then
    begin
      //PEG V2 definition table check
      pegXDS.close;
      pegXDS.buffered := True;
      (*
      pegXDS.cds.CommandText := 'select * from axprocessdefv2 where '+dbm.gf.sqllower+
                              '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
                              dbm.gf.sqllower+'(active)=''t'' and '+
                              dbm.gf.sqllower+'(amendment)<>''t'' and '+ //Amendment <> 't'
                              dbm.gf.sqllower+'(tasktype)=''make'' ';
      *)
      pegXDS.cds.CommandText :=
        'SELECT ppm.powner as processowner , ppm.pownerflg as processownerflg, ppm.amendment, pdv.* '+
        ' FROM AxprocessDefV2 pdv '+
        ' JOIN axpdef_peg_processmaster ppm ON pdv.processname = ppm.caption '+
        ' WHERE '+ dbm.gf.sqllower+
        '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
        dbm.gf.sqllower+'(active)=''t'' '+
        ' and '+ dbm.gf.sqllower+
        '(tasktype)='+QuotedStr('make')+
        ' and (ppm.amendment is null or ppm.amendment = '''' or '+
                 dbm.gf.sqllower+'(ppm.amendment)<> ''t'')'; //Amendment <> 't'
      pegXDS.open;
      result := pegXDS
    end;
  Except on E:Exception do
    begin
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\CheckAxProcessDef - '+e.Message);
      if Assigned(pegXDS) then
      begin
        if pegXDS.Active then pegXDS.close;
        FreeAndnil(pegXDS);
      end;
      result := pegXDS;
      dbm.gf.DoDebug.msg('CheckAxProcessDef Error : ' +e.Message);
    end;
  end;
  dbm.gf.DoDebug.msg('CheckAxProcessDef ends.');
end;

//IsAmendmentEnabled
function TAxProvider.IsAmendmentEnabled(transtype : string) : TXDS;
var
  pegXDS : TXDS;
begin
  dbm.gf.DoDebug.msg('IsAmendmentEnabled starts...');
  pegXDS := nil;
  try
    pegXDS := dbm.GetXDS(nil);
    pegXDS.buffered := True;
    //PEG V2 | Amendment check
    (*
    pegXDS.cds.CommandText := 'select * from AxProcessDefv2 where '+dbm.gf.sqllower+
                              '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
                              dbm.gf.sqllower+'(active)=''t'' and '+
                              dbm.gf.sqllower+'(amendment)=''t'' '+
                              ' order by indexno';
    *)
    pegXDS.cds.CommandText :=
        'SELECT ppm.powner as processowner , ppm.pownerflg as processownerflg, ppm.amendment, pdv.* '+
        ' FROM AxprocessDefV2 pdv '+
        ' JOIN axpdef_peg_processmaster ppm ON pdv.processname = ppm.caption '+
        ' WHERE '+ dbm.gf.sqllower+
        '(transid)='+QuotedStr(lowercase(transtype))+ ' and '+
        dbm.gf.sqllower+'(active)=''t'' '+
        ' and '+dbm.gf.sqllower+'(ppm.amendment) = ''t'' '+ //Amendment = 't'
        ' order by indexno';
    pegXDS.open;
    if pegXDS.CDS.RecordCount > 0 then
      result := pegXDS
  Except on E:Exception do
    begin
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxProvider\IsAmendmentEnabled - '+e.Message);
      if Assigned(pegXDS) then
      begin
        if pegXDS.Active then pegXDS.close;
        FreeAndnil(pegXDS);
      end;
      result := pegXDS;
      dbm.gf.DoDebug.msg('IsAmendmentEnabled Error : ' +e.Message);
    end;
  end;
  dbm.gf.DoDebug.msg('IsAmendmentEnabled ends.');
end;


end.

