unit uAxProvider;
{Prev : Copied from ver 10.8}
{Copied from Axpert9-XE3\Ver 11.0 Binaries}
interface
uses
  Windows, Messages, SysUtils, Variants, Classes,Graphics, Controls, Forms,
  Dialogs, ExtCtrls, StdCtrls, ComCtrls, DateUtils, Menus, XMLDoc, XMLIntf,DB,
  uDbManager, uGeneralFunctions, Grids, uXDS, Datasnap.DBClient,soap.SoapHTTPClient,
  uDoDebug, IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient, IdFTP,
  uCompress , Types, Math ,uLicMgr,Vcl.Imaging.GIFImg ,uASBARS,DBCommon ;

type
  pProps = ^TProps;
  TProps = record
    Name, Expr, ValExpr, SQL, DataType, MOE, SelectInto,Caption,chkcache : String;
    Width, Decimal : integer;
    Suggestive : Boolean;
    Q : TXDS;
    PickListMode : TPickListMode;
    PickListDef : String;
    PickRecFound, WordSearch : Boolean;
  end;

  TGetQry = function(FldName: String): string of object;

  TAxProvider=class
  private
    x, q , forcds,xTransCheck: TXDS;
    axml,xml : IXMLDocument ;
    xnode : IXMLNode;
    xmlstg , s ,tfile,sfile , msg,servertime : String;
    readlocal : boolean;
    CreatedOn, CreatedBy, ImportedOn, ImportedBy :String;
      function RemoteGetStructure(sname, name,
      caption,purpose,uname: string): IXMLDocument;
    function RemoteGetAllStructures(sname: String): IXMLDocument;
    function RemoteSetStructure(sname, name, caption,uname: string;xml: IXMLDocument) : string ;
    procedure RemoteSetImage(sname, name , filename: string);
    procedure RemoteDeleteStrucutre(sname, name, caption: string);
    function RemoteExecSQL(SQLText, ParamValues, ParamTypes: String;
      WithData: Boolean): IXMLDocument;
    function RemoteGetParam(SQLText: String): IXMLDocument;
    procedure RemoteCreateField(TableName, FName, DType: String; FWidth,
      FDec: Integer);
    procedure RemoteCreateTable(TableName, FName: String);
    procedure RemoteDeletefields(TableName, FieldName: String);
    procedure RemoteDropTable(TableName: String);
    procedure RemoteAddConstraint(TableName, Constraints: String);
//    function RemoteSetPage(name, cap, img, visible: string; xml: IXMLDocument) : string;
    function RemoteGetTStructComp(name, cname: string): IXMLDocument;
    function RemoteEditField(TableName, FName, DType: String; FWidth,
      FDec: Integer): String;
    function RemoteGetAllImages: IXMLDocument;
    procedure RemoteGetPrintTemplate(sname, pname,fname: string);
    procedure GetPrntTempFromStructURL(sname, pname,fname: string);
    procedure RemoteSetPrintTemplate(name, sname, printdoctype,filename,nm: string);
    procedure RemoteSetTreeTable(Tablename, name, transid, transdesc,
      treeorder, treelevel, transidname, parent, gori, ptable, pfield,
      recordid: string);
    procedure ByteArrayToFIle(const ByteArray: TByteDynArray;
      const FileName: string);
    procedure RemoteSaveTreeViews(name, viewname, treename, appon,showasbutton,imgname: string);
    function FIleToByteArray(FileName: string): TByteDynArray;
    procedure RemoteSetAttachments(sname,recordid,filename,recid,nm :string );
    function RemoteSaveImage(fname, table, where ,filename ,ftype: string) : string;
    function RemoteViewAttachment(sname, pname, fname: string) : string;
    function RemoteGetOneRecord(SQLText, ParamValues,
      ParamTypes: String): IXMLDocument;
    function RemoteGetAllStructDTime : IXMLDocument;
    procedure RemoteSetRoles(sname, filename, rolename: string);
    function RemoteGetPDFs(stransid: String): IXMLDocument;
    function RemoteCreatePDF(transid, formname, filename, temppth: string;
      recid: extended;RecidList : TStringlist): string;
    function GetPageOrderXML: IXMLDocument;
//    procedure RemoteEvalUserDefinedTask(n: ixmlnode);

    function RemoteMoveNode(Treeid, Parent,NewParent, Recordid: Extended; Name, gori,
      transid, ptable, pfield,treename: string):string;
    function RemoteSortNode(nm1, nm2: string; Treeid, parent: extended; pname,
      treename: string): string;
    procedure RemoteDropConstraint(TableName, Constraints: String);
    function RemoteDownLoadImage(imgname: String): string;
    procedure RemoteSavePDFImage(imgname, pdfname, filename: string);
    function RemoteB4SaveCheckExisting(tname,sname: String): IXMLDocument;
    function RemoteGetAllWorkFlowTStructs: IXMLDocument;
    function GetProdCode(s: string): integer;
    function CheckProduct(name : string ; pxml: IXMLDocument): IXMLDocument;
    function ExtractFRname(Formname: string): string;
    function MakeFRCSVInQoutedStr(CommaSepVal: String): String;
    function LoadXMLDataFromWS(xml: WideString): IXMLDocument;
    function UpDatedOn_Correction(update_table: string) : Boolean;
//    function IsStructExists(sname, wcond: String): Boolean;
    function RemoteGetMemberShipDetails(WhereCondition,
      RemoteProject: String): String {IXMLDocument};
    function SavePOSMembershipDetails(XMLMemDetDoc: IXMLDocument; CallType,
      RemoteProject: String): String;

  public
    dbm : TDbManager;
    GetStructName, GetStructCaption, wTName, wTaName:string;
    GetPageName, GetPageCaption, GetPageImg, GetPageVisible, PageType, PageOrdNo, PageLevelNo,PageParent, PageFormType :String;
    GetImgExtn,savedimages : String;
//    GetPageOrdNo : Integer;
    ftp: TIdFTP;
    lm : TLicMgr;
    UpdateChanges : TUpdateChanges;
    bImportPrintDoc,IsAxpDefStructure : Boolean;
    getupdtime : String;
    GetQry : TGetQry;

    constructor create(pdbm:TDbManager); virtual;
    destructor destroy; override;
    function GetStructure(sname, name, caption,purpose:string):IXMLDocument;  overload;
    function GetStructure(sname, name, caption,purpose,uname: string): IXMLDocument;  overload;
    function GetStructure(sname, name, caption, purpose, uname,
      transid: string): IXMLDocument;overload;
    procedure SetStructure(sname, name, caption:string; xml:IXMLDocument; UpdSrcDate:Boolean=False); overload;
    procedure SetStructure(sname, name, caption , uname : string; xml:IXMLDocument; UpdSrcDate:Boolean=False); overload;
    procedure SetStructure(sname, name, caption , uname,transid : string; xml:IXMLDocument; UpdSrcDate:Boolean=False); overload;
    procedure SetStructure(sname, name, caption,uname,transid,purpose : string; xml:IXMLDocument);overload;
    procedure SetImage(sname, name : string);
//    procedure UploadImage(sname, name : string);
    procedure DeleteStrucutre(sname, name, caption:string);overload;
    procedure DeleteStrucutre(sname, name, caption,transid:string);overload;
    function GetAllStructures(sname:string) : IXMLDocument;
    function GetAllImages : IXMLDocument;
    function ExecSQL(SQLText, ParamValues, ParamTypes: String;
      WithData: Boolean): IXMLDocument;
    function GetParam(SQLText: String): IXMLDocument;
    function CreateField(TableName, FName, DType: String; FWidth,FDec: Integer) : boolean;
    procedure CreateTable(TableName, FName: String);
    procedure Deletefields(TableName, FieldName: String);
    procedure DropTable(TableName: String);
    function CreateHistoryTable(TableName:String): Boolean;
    function TableFound(Tablename: String): Boolean;
    procedure AddConstraint(TableName, Constraints: String);
    function GetUsers : IXMLDocument;
    function GetUserGroups : IXMLDocument;
    function GetFolders(usergroup:String) : IXMLDocument;
    function GetOptions(usergroup : string) : IXMLDocument;
    function GetPrintForms(sname: String): IXMLDocument;

    function GetImage(ImgName: string; Img:TBitMap):boolean;overload;
    procedure GetImage(ImgName:string; Img:TImage);overload;
    procedure GetImage(Img: TImage;imgpath: string);overload; //ch1
    function DownloadImage(ImgName: string) : string ;
    function GetPage(name, caption, purpose: string): IXMLDocument;
    function GetAllPages(sname: String): IXMLDocument;
    function GetTStructComp(name, cname: string): IXMLDocument;
    function EditField(TableName, FName, DType: String; FWidth,
      FDec: Integer):String;
    function DownLoad(filename,tempfile: string): string;
    function RemoteReadMemo(fname, table, where: string): string;
    function RemoteSaveData(rdata: IXMLNode): string;
    function RemoteDeleteData(transid, recid,action: string;dnode:ixmlnode;detail:Boolean): string;
    procedure SetStructReadonly(sname, name, readonly: string);
    procedure SaveImage(sname,ftype: string;recid:Extended;Img:Timage);overload;
    procedure LoadImage(sname: string; recid: Extended; Img: Timage);overload;
    procedure LoadImage(AxpImgPath,recid:String;Img:Timage);overload;
    procedure LoadImage(FileName:String;Img:Timage);overload;
    function GetPrintTemplate(sname, pname,fname: string): string;
    function GetTreeViews(TreeName: string): IXMLDocument;
    procedure SetPrintTemplate(name, sname,printdoctype: string;
      PropsXML: IXMLDocument);
    procedure DeletePrintForm(sname, name: string);
    procedure SaveTreeViews(name, viewname, treename, appon,showasbutton,imgname: string);
    function GetBOMXML: IXMLDocument;
    procedure SetAttachments(sname, recordid, filename: String);overload;
    procedure SetAttachments(Filename,AxpAttTransPath:String;Recordid:Extended);overload;
    function ViewAttachment(sname, recordid, filename: string): string;
    procedure SetTreeTable(Tablename, name, transid, transdesc, treeorder,
      treelevel, transidname, parent, gori, ptable, pfield,
      recordid: string);
    function RemoteLoadData(transid,recid:string): string;
    function GetOneRecord(SQLText, ParamValues, ParamTypes: String;UniqueVal : String = ''): IXMLDocument;
    function GetAllStructDTime : IXMLDocument;
    function GetPDFs(stransid: String): IXMLDocument;
    function RemoteServerDateTime() : String;
    procedure SetRoles(sname, filename, rolename: String);
    procedure RemoteSetUserGroups(grpno, grpName, roles: String);
    procedure RemoteSetUsers(n:ixmlnode);
    function RemoteGetPrintForms(sname: String): IXMLDocument;
    function RemoteCsvImport(filename: String; n: ixmlnode): string;
    function UploadFile(sname, filename: string): string;
    procedure DebugMessage(s : string);
    function RemoteUserDefinedTask(n: ixmlnode): string;
    function RemotePostIview(n: ixmlnode): string;
    function CreatePDF(transid, formname, filename, temppth: string;
      recid: extended;RecidList : TStringlist): string;
    procedure remoteupdateversion;
    procedure MoveNode(Treeid, Parent, NewParent,Recordid: Extended; Name, gori, transid,
      ptable, pfield,treename: string);
    procedure SortNode(nm1, nm2: string; Treeid, parent: extended; pname,
      treename: string);
    procedure RemoteUpdatePageOrder(n: ixmlnode);
    procedure DownLoadFile(filename, tempfile: string);
    procedure DropConstraint(TableName, Constraints: String);
    procedure RemoteSaveSequence(n: ixmlnode; transid, fldname: String);
    procedure RemoteSetPrefix(transid, fldname, prefix: String);
    function remoteSetlanguage(XML: string): string;
    function SaveRoles(XML: string): string;
    procedure SetMailVars(n : ixmlnode);
    procedure SavePDFImages(imgname, pdfname, filename: string);
    function RemoteReadBlob(fname, table, where: string): string;
    function RemoteDbfImport(filename: String; n: ixmlnode): string;
    function B4SaveCheckExisting(tname,sname: String): IXMLDocument;
    function CheckStructureAccess(sname,name: string): ixmldocument;
    function ViewAttachments(sessionid, sname, recordid,
      filename: string): string;
    function RemoteExcelImport(filename: String; n: ixmlnode): string;
    function GetPageOrderXMLForPageDesign: IXMLDocument;
    function GetAllWorkFlowTStructs: IXMLDocument;
    procedure RemoteSaveWorkflow(name, caption: String; WXML: ixmldocument);
    procedure RemoteSaveAttachInfo(strExp1, wkid, transid: string);
    function GetJoinStr(Fname, DType: String; Width, Dec: integer;ToModify:Boolean=False): string;
    function checkLicence : string;
    function FieldFound(FldName, TblName: String): Boolean;
    function StructLocked(SName: String): Boolean;
    procedure UnLockStruct(SName: String);
    procedure UnLockAllStructs(cno: String);
    procedure SetUpdateChanges(bVal: Boolean);
    procedure SaveImage(foldername,filename,tblname: string;recid:Extended);overload;
    procedure SaveImage(sFolderName, sFileName, tFolderName, tFileName: string); overload;
    procedure SetAttachments(sFolderName,sFileName,tFolderName, tFileName: string);overload;
    procedure SetAttachments(sname,sfile,tfile:String;recordid:Extended;HugeBlob : Boolean = false);overload;
    procedure DeleteAttachments(TblName: String; Recid: Extended);overload;
    Procedure DeleteAttachments(AxpAttPath,TransType:String;Recid:Extended);overload;
    procedure SaveImage(foldername,sfile,tfile,tblname,ftype: string;recid:Extended);overload;
    function SaveImage(sname, imgName: String; recid: Extended): boolean; overload;
    function FindPrintSourceFormat(strans, formname: string;OnlyPDF: Boolean): string;
    function ExecSQLThroughCDS(SQLText, ParamValues, ParamTypes: String;
      WithData: Boolean): IXMLDocument;
    procedure CopyFiles(sFolder, tFolder: String);
    function GetFastReports(stransid:String):IXMLDocument;
    procedure SaveToLog(servicename, structname, serviceresult: String ; recordid : extended);
    procedure DeleteTransControl;overload;
    procedure DeleteTransControl(recid: extended;transid : string);overload;
    function CheckExistanceInTransControl(recid: extended;transid : string): boolean;overload;
    procedure InsertIntoTransControl(transid: String; recid: extended);
    procedure DeleteTransControl(recid, transid: string);overload;
    function CheckExistanceInTransControl(recid,transid : string): boolean;overload;
    function CheckFastReport(Outputs,transid: string): Boolean;
    function CheckPrinForms(transid: string): Boolean;
    function GetFastReportFileExt(stransid, Rname: String): String;
    function ExtractFilenameWithoutExtension(FRfileName: String): String;
    function IsStructExists(sname, wcond: String): Boolean;
    procedure DeleteTransControl(UName : String);overload;
    function GetNewName: string;
    procedure SavetoUserAccess(sname, stype: String);
    procedure ApplyAppSettings(RoleName, PropName, PropValue: String);
    procedure ApplyFormSettings(TblName, SFldName, SFldVal, FldName, PropName,
      PropValue, RoleName: String);
    procedure ApplyCompSettings(TblName, SFldName, SFldVal, PkFldName, PkFldVal,
      PropName, PropValue, RoleName: String; RecFound: Boolean);
    function GetPageOrderXMLForPageCreatedThroughWeb(forweb : Boolean) : IXMLDocument;
    function GetMemberShipDetails(FldName, FldValue,
      CallType, RemoteProject:String): String{IXMLDocument};
    function RemoteSavePOSMembershipDetails(rData: IXMLNode): String;
    procedure InsertIntoTransCheck;
    procedure DeleteFromTransCheck;
    function ValidateTransCheck: Boolean;
    function GetConfigValue(ConfigCDS: TXDS; Props, AsProps: String): String;
    function GetStructureForScript(sname, name, caption,
      purpose: String): IXMLDocument;

  end;
  const ArraySize = 30000;

implementation

{ TAxProvider }

constructor TAxProvider.create(pdbm: TDbManager);
begin
  inherited create;
  x := nil;
  q := nil;
  forcds := nil;
  dbm := pdbm;
  x:=dbm.GetXDS(nil);
  q:=dbm.GetXDS(nil);
  forcds := dbm.GetXDS(nil);
  xTransCheck := dbm.GetXDS(nil);
  xml := nil; axml := nil;
  bImportPrintDoc := false;
  IsAxpDefStructure := False;
  getupdtime := '';
  GetQry := nil;
end;

destructor TAxProvider.destroy;
begin
    x.destroy;
    q.close;
    q.destroy;
    forcds.close;
    forcds.destroy;
    xTransCheck.Close;
    xTransCheck.Destroy;
    xTransCheck := nil;
    inherited;
end;

 function TAxProvider.GetAllStructures(sname:String): IXMLDocument;
  var i : integer;
  stype : string;
begin
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetAllStructures(sname);
    exit;
  end;
   if sname = 'tstructs' then
      stype := 't'
   else if sname = 'iviews' then
      stype := 'i'
   else if sname = 'lviews' then
      stype := 'l'
   else stype := 'p';
  xml := nil;
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
     if (wTaName = 'page') and (sname = 'axpages') then
       begin
         x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' ) order by ordno ,levelno ';
       end
     else
       begin
        x.sqltext:='select name,caption from '+sname+' where blobno=1 order by ' + dbm.gf.sqllower + '(caption)' ;
       end
    else  begin
    if lowercase(sname)<>'prints' then
      if sname = 'axptree' then
        x.sqltext:='select name,caption from '+sname+' where blobno=1  order by ' + dbm.gf.sqllower + '(caption)'
      else
        x.sqltext:='select name,caption from '+sname+' where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
    else  begin
      if lowercase(dbm.Connection.DbName) = 'ms sql' then
        x.sqltext:='select name,caption from '+sname+' where blobno=1 and substring(sname,2,6) in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
      else
        x.sqltext:='select name,caption from '+sname+' where blobno=1 and substr(sname,2,6) in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)';
    end;
  end;
  if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
    x.SetCDSName('Axprovider_'+sname+'_getallstructs')
  else
    x.SetCDSName('nolds_Axprovider_'+sname+'_getallstructs');
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('sname').NodeValue := sname ;
    xml.saveToXML(xmlstg);
    dbm.gf.dodebug.Msg('>>Calling GetallStructures webservice');
//    s := (dbm.gf.AMSCall as ARS).GetAllStructures(xmlstg) ;
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
     raise exception.Create(msg);
    end;
    xml := LoadXMLData(s);
    for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
    begin
      xnode := nil;
      xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
      if xnode = nil then
      begin
         result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
      end;
    end;
  end;
  xml := nil;
end;

function TAxProvider.GetAllStructDTime : IXMLDocument;
  var i,j : integer;
  n,n1,n2 : IXMLNode;
  s1 : string;
  sCDSName_Prefix : String;
begin
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetAllStructDTime ;
    exit;
  end;
  //if (dbm.gf.AxpLocalDB) and (dbm.gf.IsInterNetConnected) then
  //   sCDSName_Prefix := 'nolds_'
  //else
     sCDSName_Prefix := '';
  result:=LoadXMLData('<root></root>');
  n := result.DocumentElement;
  xml := nil;
  xml:=LoadXMLData('<axprops></axprops>');
//  x.sqltext:='select name,updatedon from axprops where blobno=1 order by name';
  if dbm.Connection.DbType = 'ms sql' then
     s1 := 'select name,updatedon from axprops where (blobno=1) and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name'
  else if dbm.Connection.DbType = 'postgre' then
    s1 := 'select name,updatedon from axprops where (blobno=1) and datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp))  > 0 order by name'
  else s1 := 'select name,updatedon from axprops where (blobno=1) and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
  x.SetCDSName(sCDSName_Prefix+'Axprovider_axprops_getallstructDTime');
  x.sqltext:= s1;
  x.open;
  while not x.eof do begin
    s := x.fieldbyname('name').AsString ;
    if s<>'' then
      xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
    x.next;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<axpages></axpages>');
//  x.sqltext:='select name,updatedon from axpages where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
       s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), quotedstr(dbm.gf.lastlogintime) )  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
      s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'', cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 or (cast(importedon as timestamp)  > cast(updatedon as timestamp))) order by name'
    else s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and ((' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' > 0 or ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'importedon') + ' > ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon' ) + ')) order by name' ;
    x.SetCDSName(sCDSName_Prefix+'Axprovider_axpages_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('axpages') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), quotedstr(dbm.gf.lastlogintime) )  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
            s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) order by name'
          else s1 := 'select name,updatedon from axpages where (blobno=1) and (updatedon not like ''%M%'') and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s<>'' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<tstructs></tstructs>');
//  x.sqltext:='select name,updatedon from tstructs where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
       s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
      s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'',cast(updatedon as timestamp), cast('+quotedstr(dbm.gf.lastlogintime)+ ' as timestamp)) > 0 or (cast(importedon as timestamp)  > cast(updatedon as timestamp))) order by name'
    else s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and ((' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' > 0 or ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'importedon') + ' > ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon' ) + ')) order by name' ;
    x.SetCDSName(sCDSName_Prefix+'Axprovider_tstructs_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('tstructs') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
            s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'', cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) order by name'
          else s1 := 'select name,updatedon from tstructs where (blobno=1) and (updatedon not like ''%M%'') and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s<>'' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<iviews></iviews>');
//  x.sqltext:='select name,updatedon from iviews where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
      s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
      s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'') and ((datediff(''minute'', cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) or ( cast(importedon as timestamp) > cast(updatedon as timestamp) )) order by name'
    else s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'') and ((' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' > 0 or ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'importedon') + ' > ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon' ) + ')) order by name' ;
    x.SetCDSName(sCDSName_Prefix+'Axprovider_iviews_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('iviews') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
             s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'')and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 ) order by name'
          else s1 := 'select name,updatedon from iviews where (blobno=1) and (updatedon not like ''%M%'')and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s<>'' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<lviews></lviews>');
//  x.sqltext:='select name,updatedon from lviews where username = ' + quotedstr(dbm.gf.username) + ' and blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
      s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
      s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'') and ((datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp))> 0) or ( cast(importedon as timestamp) > cast(updatedon as timestamp))) order by name'
    else s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'') and ((' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' > 0 or ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'importedon') + ' > ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon' ) + ')) order by name' ;
    x.SetCDSName(sCDSName_Prefix+'Axprovider_lviews_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('lviews') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
             s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'')and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 ) order by name'
          else s1 := 'select name,updatedon from lviews where (blobno=1) and (updatedon not like ''%M%'')and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s <> '' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<pdfprops></pdfprops>');
//  x.sqltext:='select name,updatedon from pdfprops where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
       s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
       s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'', cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) order by name'
    else s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'') and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
    x.SetCDSName(sCDSName_Prefix+'Axprovider_pdfprops_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('pdfprops') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
             s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'')and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 ) order by name'
          else s1 := 'select name,updatedon from pdfprops where (blobno=1) and (updatedon not like ''%M%'')and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s <> '' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<printprops></printprops>');
//  x.sqltext:='select name,updatedon from printprops where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
       s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
       s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'', cast(updatedon as timestamp), cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) order by name'
    else s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'') and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
    x.SetCDSName(sCDSName_Prefix+'Axprovider_printprops_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('printprops') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
             s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'')and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 ) order by name'
          else s1 := 'select name,updatedon from printprops where (blobno=1) and (updatedon not like ''%M%'')and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s <> '' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  xml := nil;
  xml:=LoadXMLData('<images></images>');
//  x.sqltext:='select name,updatedon from images where blobno=1 order by name';
  try
    if dbm.Connection.DbType = 'ms sql' then
       s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
    else if dbm.Connection.DbType = 'postgre' then
      s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'') and (datediff(''minute'',cast(updatedon as timestamp), cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0) order by name'
    else s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'') and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
    x.SetCDSName(sCDSName_Prefix+'Axprovider_images_getallstructDTime');
    x.sqltext:= s1;
    x.open;
  except on e:exception do
    begin
      dbm.gf.DoDebug.Msg(e.Message);
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
      if UpDatedOn_Correction('images') then
      begin
        try
          x.close;
          if dbm.Connection.DbType = 'ms sql' then
             s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'') and datediff(minute,' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ' , ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ') > 0 order by name'
          else if dbm.Connection.DbType = 'postgre' then
             s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'')and (datediff(''minute'',cast(updatedon as timestamp),cast('+quotedstr(dbm.gf.lastlogintime)+' as timestamp)) > 0 ) order by name'
          else s1 := 'select name,updatedon from images where (blobno=1) and (updatedon not like ''%M%'')and (' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'), 'updatedon')  + ' - ' + dbm.gf.findandreplace(dbm.gf.dbdatestring, quotedstr(':value'),quotedstr(dbm.gf.lastlogintime))  + ') > 0 order by name';
          x.sqltext:= s1;
          x.open;
        except on e:exception do
          begin
            dbm.gf.DoDebug.Msg(e.Message);
            dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\GetAllStructDTime - '+e.Message);
          end;
        end;
      end;
    end;
  end;
  if x.Active then
  begin
    while not x.eof do begin
      s := x.fieldbyname('name').AsString ;
      if s <> '' then
        xml.DocumentElement.AddChild(s).NodeValue:=x.fieldbyname('updatedon').asstring;
      x.next;
    end;
  end;
  x.close;
  n1 := xml.DocumentElement ;
  n.ChildNodes.Add(n1.CloneNode(True));
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xml.saveToXML(xmlstg);
    dbm.gf.DoDebug.Msg('>>Calling GetAllStruct DateTime webservice');
//    s := (dbm.gf.AMSCall as ARS).GetAllStructDTime(xmlstg) ;
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
      raise exception.Create(msg);
    end;
    xml := LoadXMLData(s);
    for i := 0 to result.DocumentElement.ChildNodes.Count - 1 do
    begin
       n := result.DocumentElement.ChildNodes[i];
       s := n.NodeName;
       n1 := xml.DocumentElement.ChildNodes.FindNode(s);
       for j := 0 to n.ChildNodes.Count - 1 do
       begin
          s1 := n.ChildNodes[j].NodeName;
          n2 := n1.ChildNodes.FindNode(s1);
          if n2 = nil then continue;
          n.ChildNodes.Add(n2);
       end;
    end;
  end;
end;

function TAxProvider.UpDatedOn_Correction(update_table : string) : boolean;
  var s : string;
begin
  result := false;
  if dbm.Connection.DbType = 'ms sql' then exit;
  try
    x.close;
    s := 'update ' + update_table + ' d set d.updatedon= replace(d.updatedon,''-'',''/'') where d.updatedon like ''%-%''';
    x.SqlText := s;
    try
      x.execsql;
    except on e:exception do
      begin
        dbm.gf.DoDebug.Msg(e.Message);
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\UpDatedOn_Correction - '+e.Message);
      end;
    end;
    x.close;
    s := 'update ' + update_table + ' s set  s.updatedon=substr(s.updatedon,9,2)||''/''||substr(s.updatedon,6,2)||''/''|| substr(s.updatedon,1,4)||substr(s.updatedon,11,18) where substr(s.updatedon,3,1)!=''/''';
    x.SqlText := s;
    try
      x.execsql;
    except on e:exception do
      begin
        dbm.gf.DoDebug.Msg(e.Message);
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\UpDatedOn_Correction - '+e.Message);
      end;
    end;
    x.close;
    s := 'update + update_table + s  set s.updatedon=to_char(sysdate,''dd/mm/yyyy hh:ss:mi'') where s.updatedon is null';
    x.SqlText := s;
    try
      x.execsql;
    except on e:exception do
      begin
        dbm.gf.DoDebug.Msg(e.Message);
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\UpDatedOn_Correction - '+e.Message);
      end;
    end;
    result := true;
  finally
  end;
end;

function TAxProvider.GetPrintForms(sname:String): IXMLDocument;
  var i : integer;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteGetPrintForms(sname);
    exit;
  end;
  xml := nil;
  result:=LoadXMLData('<root></root>');
  sname := lowercase(sname);
  x.close;
  if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
    x.SetCDSName('Axprovder_'+sname+'_getprintforms')
  else
    x.SetCDSName('nolds_Axprovder_'+sname+'_getprintforms');//x.SetCDSName('nolds_Axprovder_'+sname+'_getprintforms');
  x.sqltext:='select distinct caption,name,printdoctype from prints where '+dbm.gf.sqllower+'(sname) = ' + quotedstr(sname) +' and blobno=1 '+ 'order by caption';
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('sname').NodeValue := sname ;
    xml.saveToXML(xmlstg);
    dbm.gf.DoDebug.Msg('>>Calling GetAllPrintForms webservice');
//    s := (dbm.gf.AMSCall as ARS).GetAllPrintForms(xmlstg) ;
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
      raise exception.Create(msg);
    end;
    xml := LoadXMLData(s);
    for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
    begin
      xnode := nil;
      xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
      if xnode = nil then
      begin
         result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
      end;
    end;
  end;
end;

function TAxProvider.GetAllImages : IXMLDocument;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteGetAllImages ;
    exit;
  end;
  if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
    x.SetCDSName('Axprovider_'+'images_getallimages')
  else
    x.SetCDSName('nolds_Axprovider_'+'images_getallimages');//x.SetCDSName('nolds_Axprovider_'+'images_getallimages');
  x.sqltext:='select name from Images where blobno = 1 order by name';
  x.open;
  result:=LoadXMLData('<root></root>');
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString) ;
    x.next;
  end;
  x.close;
end;

function TAxProvider.GetStructure(sname, name, caption,purpose: string): IXMLDocument;
  var w,stime,readonly,updusername :string;
  getlocal : boolean;
  FxmlDoc:IXMLDocument;
  stm : TStringStream ;
begin
  try
  dbm.gf.IsGetStruct := True;
  readonly := '';
  updusername := '';
  readlocal := false;
  if name = '' then
  begin
     showmessage('Name not found... -' +  caption + ' - ' + sname);;
     exit;
  end;
  {
  if (purpose = 'update') and ((sname = 'tstructs') or (sname = 'iviews')) then
  begin
    axml := ExecSQL('select readonly,updusername from ' + sname + ' where  name = :name',name,'c',True) ;
    xNode := axml.DocumentElement;
    xNode := xNode.ChildNodes.FindNode('data');
    if (xNode <> nil) and (xNode.ChildNodes.Count > 0) then xNode := xNode.ChildNodes[0]
    else xNode := nil;
    if xNode <> nil then
    begin
      readonly := vartostr(xNode.ChildValues['READONLY']);
      updusername := vartostr(xNode.ChildValues['UPDUSERNAME']);
      if readonly = '' then SetStructReadonly(sname,name,'Y');
    end
  end;
  }
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetStructure(sname,name,caption,purpose,'');
//    result.DocumentElement.Attributes['readonly'] := readonly;
    result.DocumentElement.Attributes['updusername'] := updusername;
    GetStructName:=trim(vartostr(Result.DocumentElement.Attributes['name']));
    GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
    if sname = 'printprops' then
    begin
       sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       GetPrintTemplate('printprops',GetStructName,sfile);
    end;
    exit;
  end;
  xml := nil; stime := '';axml := nil ;
  getlocal := false;
  if (dbm.gf.RunMode) then begin
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
    tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
    if fileexists(sfile) then begin
      with TCompress.Create do begin
        decompressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then
      begin
        FxmlDoc:=nil;
        FxmlDoc:=LoadXMLData('<root></root>');
        FxmlDoc.LoadFromFile(tfile);                    // Changed for Unicodet
        xml:=FxmlDoc;
        deletefile(tfile);
       end ;

         getlocal := True;
         readlocal := true;
         stime := 'pagefound';
  //       xml.DocumentElement.Attributes['readonly'] := readonly;
         xml.DocumentElement.Attributes['updusername'] := updusername;
         if sname = 'tstructs' then xml := CheckProduct(name,xml);
         result := xml  ;
         if sname = 'axpages' then
         begin
           GetPageName:=name;
           GetPageCaption:=vartostr(Result.DocumentElement.Attributes['caption']);;
           GetPageImg:=vartostr(Result.DocumentElement.Attributes['img']);
           GetPageVisible:=vartostr(Result.DocumentElement.Attributes['visible']);
           PageType:=vartostr(Result.DocumentElement.Attributes['type']);
           PageOrdNo:=vartostr(Result.DocumentElement.Attributes['ordno']);
           PageLevelNo:=vartostr(Result.DocumentElement.Attributes['levelno']);
           PageParent:=vartostr(Result.DocumentElement.Attributes['parent']);
           PageFormType :=vartostr(result.DocumentElement.Attributes['pgtype']);
         end
         else begin
           GetStructName:=name;
           GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
         end;
    end;
  end;
  if stime <> 'pagefound' then
  begin
    result:=LoadXMLData('<root></root>');
    if name <> 'pageorder' then
    begin
      if dbm.gf.structGetFrom <> 'folder' then begin
      begin
          x:=dbm.getxds(x);
          if name='' then w:=dbm.gf.sqllower+'(caption)='+lowercase(quotedstr(caption))
          else w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name));
          if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
            x.SetCDSName('Axprovider_'+sname+'_'+w)
          else
            x.SetCDSName('nolds_Axprovider_'+sname+'_'+w);
          x.sqltext:='select * from '+sname+' where '+w;
          x.open;
          if not x.isempty then begin
            if (sname = 'tstructs') or (sname = 'tmp_tstructs') then
            begin
              sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
              tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
              if sname = 'tstructs' then
              begin
                dbm.ReadBlob('props', sname, w, sfile);
                if fileexists(sfile) then
                begin
                  with TCompress.Create do begin
                    decompressfile(sfile, tfile);
                    destroy;
                  end;
                end;
              end else dbm.ReadMemo('props', sname, w, tfile);
              if fileexists(tfile) then
              begin
                FxmlDoc:=nil;
                FxmlDoc:=LoadXMLData('<root></root>');          // Changed for Unicodet
                FxmlDoc.LoadFromFile(tfile);
                result:=FxmlDoc;
                deletefile(tfile);
              end;
//              result.DocumentElement.Attributes['readonly'] := readonly;
              result.DocumentElement.Attributes['updusername'] := updusername;
              result := CheckProduct(name,result);
            end else
            begin
              stm := TStringStream.Create;
              dbm.ReadMemo('props', sname, w, stm);
              if stm.Size=0 then result:=LoadXMLData('<root/>')
              else result := LoadXMLDataFromWS(trim(stm.DataString));
              FreeAndNil(stm);
            end;
            if sname = 'axpages' then
            begin
              GetPageName:='';
              GetPageCaption:='';
              GetPageImg:='';
              GetPageVisible:='';
              GetPageName:=x.fieldbyname('name').asstring;
              GetPageCaption:=x.fieldbyname('caption').asstring;
              GetPageImg:= x.fieldbyname('img').asstring;
              GetPageVisible:= x.fieldbyname('visible').asstring;;
              PageType:=x.fieldbyname('type').asstring;;
              PageOrdNo:=x.fieldbyname('ordno').asstring;;
              PageLevelNo:=x.fieldbyname('levelno').asstring;;
              PageParent:=x.fieldbyname('parent').asstring;;
              PageFormType :=x.fieldbyname('pagetype').asstring;
              result.DocumentElement.Attributes['name']:=GetPageName;
              result.DocumentElement.Attributes['caption']:=GetPageCaption;
              result.DocumentElement.Attributes['img'] := GetPageImg ;
              result.DocumentElement.Attributes['visible'] := GetPageVisible;
              result.DocumentElement.Attributes['type'] := PageType;
              result.DocumentElement.Attributes['ordno'] := PageOrdNo;
              result.DocumentElement.Attributes['levelno'] := PageLevelNo;
              result.DocumentElement.Attributes['parent'] := PageParent;
              result.DocumentElement.Attributes['pgtype'] := PageFormType;
            end
            else begin
              GetStructName:=x.fieldbyname('name').asstring;
              GetStructCaption:='';
              if assigned(x.findfield('caption')) then GetStructCaption:=x.fieldbyname('caption').asstring;
//              result.DocumentElement.Attributes['readonly'] := readonly;
              result.DocumentElement.Attributes['updusername'] := updusername;
              result.DocumentElement.Attributes['name'] := GetStructName;
              result.DocumentElement.Attributes['caption'] := GetStructCaption;
            end;
          end else
          begin
            GetPageName:='';
            GetPageCaption:='';
            GetPageImg:='';
            GetPageVisible:='';
            result:=LoadXMLData('<root/>');
            x.close;
            if (sname = 'tstructs') or (sname = 'iviews') then
               raise exception.Create(sname + ' [' + name + '] is not available...');
          end;
      end;
      end
      else if (trim(dbm.gf.structURL) <> '') and (result.DocumentElement.ChildNodes.Count = 0) then
      begin
        xml := LoadXMLData('<root></root>') ;
        xnode :=xml.documentelement;
        xnode.attributes['axpapp'] := dbm.gf.AppName;
        xnode.attributes['sessionid'] := dbm.gf.sessionid;
        if dbm.gf.DoDebug.Active then
          xnode.Attributes['trace'] := 'true'
        else
          xnode.Attributes['trace'] := 'false';
        xnode.AddChild('sname').NodeValue := sname;
        xnode.AddChild('name').NodeValue := name;
        xnode.AddChild('caption').NodeValue := caption;
        xnode.AddChild('uname').NodeValue := '';
        xml.saveToXML(xmlstg);
        dbm.gf.DoDebug.Msg('>>Calling GetStructure webservice');
//        s := ( dbm.gf.AMSCall as ARS).GetStructure(xmlstg) ;
        msg := copy(s,1,pos('~',s)-1);
        delete(s,1,pos('~',s));
        if dbm.gf.DoDebug.Active then DebugMessage(msg);
        if copy(s,1,7) = '<error>' then
        begin
          delete(s,1,7);
          msg := copy(s,1,pos('<',s)-1);
          raise exception.Create(msg);
        end;
        result := LoadXMLData(s);
        if (sname = 'axpages') then
        begin
          GetPageName:='';
          GetPageCaption:='';
          GetPageImg:='';
          GetPageVisible:='';
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetPageName:=vartostr(result.DocumentElement.Attributes['name']);
              GetPageCaption:=vartostr(result.DocumentElement.Attributes['caption']);
              GetPageImg:=vartostr(result.DocumentElement.Attributes['img']);
              GetPageVisible:=vartostr(result.DocumentElement.Attributes['visible']);
              PageType:=vartostr(result.DocumentElement.Attributes['type']);
              PageOrdNo:=vartostr(result.DocumentElement.Attributes['ordno']);
              PageLevelNo:=vartostr(result.DocumentElement.Attributes['levelno']);
              PageParent:=vartostr(result.DocumentElement.Attributes['parent']);
              PageFormType :=vartostr(result.DocumentElement.Attributes['pgtype']);
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end else begin
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetStructName:=vartostr(result.DocumentElement.Attributes['name']);
              GetStructCaption:=trim(vartostr(result.DocumentElement.Attributes['caption']));
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end;
      end;
    end
    else result := GetPageOrderXML;
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
    if sname = 'tstructs' then exit;
//    result.DocumentElement.Attributes['readonly'] := readonly;
    result.DocumentElement.Attributes['updusername'] := updusername;
    tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
    result.SaveToFile(sfile);
    with TCompress.Create do begin
       compressfile(sfile, tfile);
       destroy;
    end;
    if fileexists(tfile) then begin
       if fileexists(sfile) then deletefile(sfile);
    end;
//    if sname = 'tstructs' then result := CheckProduct(name,result);
  end;
  if sname = 'printprops' then
  begin
     sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
     GetPrintTemplate('printprops',GetStructName,sfile);
  end;
  axml := nil; xnode:= nil;
  finally
    dbm.gf.IsGetStruct := False;
  end;
end;

function TAxProvider.CheckProduct(name : string ; pxml :  IXMLDocument) : IXMLDocument;
  var i,pid : integer;
begin
  result := pxml;
  exit;
  if (dbm.gf.evalcopy) or (dbm.gf.FromAdr) then exit;
  if dbm.gf.dbmflag = 'axpman' then exit;
  if pxml.DocumentElement.HasAttribute('pid') then
  begin
     pid := strtoint(vartostr(pxml.DocumentElement.Attributes['pid']));
     i := 0;
     i := GetProdCode(name);
     i := pid - i;
     if (i <> 100) and (i <> 0) then
     begin
       if (i <>  lm.licProdCode) and (not lm.inwait) then
       begin
         showmessage('Product not compatible with licensed version.' + #13 + 'Please use update ProductID option in AxpManager to update ProductID');
         Application.MainForm.Tag := 100;
         Application.MainForm.Close;
         Halt;
       end;
     end;
     pxml.DocumentElement.Attributes['pid'] := '';
  end;
  result := pxml;
end;

function TAxProvider.GetStructure(sname, name, caption,purpose,uname: string): IXMLDocument;
  var w,stime,readonly,updusername :string;
  getlocal : boolean;
  i : integer;
  FxmlDoc:IXMLDocument;
  stm : TStringStream;
begin
  try
  dbm.gf.IsGetStruct := True;
  readonly := '';
  updusername := '';
  readlocal := false;
  if name = '' then
  begin
     showmessage('Name not found... -' +  caption + ' - ' + sname);;
     exit;
  end;
  {
  if purpose = 'update' then
  begin
    axml := ExecSQL('select readonly,updusername from ' + sname + ' where  name = :name',name,'c',True) ;
    xNode := axml.DocumentElement;
    xNode := xNode.ChildNodes.FindNode('data');
    if (xNode <> nil) and (xNode.ChildNodes.Count > 0) then xNode := xNode.ChildNodes[0]
    else xNode := nil;
    if xNode <> nil then
    begin
      readonly := vartostr(xNode.ChildValues['READONLY']);
      updusername := vartostr(xNode.ChildValues['UPDUSERNAME']);
      if readonly = '' then SetStructReadonly(sname,name,'Y');
    end
  end;
  }
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetStructure(sname,name,caption,purpose,uname);
//    result.DocumentElement.Attributes['readonly'] := readonly;
    result.DocumentElement.Attributes['updusername'] := updusername;
    GetStructName:=trim(vartostr(Result.DocumentElement.Attributes['name']));
    GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
    if sname = 'printprops' then
    begin
       sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       GetPrintTemplate('printprops',GetStructName,sfile);
    end;
    exit;
  end;
  xml := nil; stime := '';axml := nil ;
  getlocal := false;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+uname ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  if fileexists(sfile) then begin
    with TCompress.Create do begin
      decompressfile(sfile, tfile);
      destroy;
    end;
       if fileexists(tfile) then
       begin
         FxmlDoc:=nil;
         FxmlDoc:=LoadXMLData('<root></root>');
         FxmlDoc.LoadFromFile(tfile);                    // Changed for Unicodet
         xml:=FxmlDoc;
         deletefile(tfile);
       end;
       getlocal := True;
       readlocal := true;
       stime := 'pagefound';
//       xml.DocumentElement.Attributes['readonly'] := readonly;
       xml.DocumentElement.Attributes['updusername'] := updusername;
       result := xml  ;
       if sname = 'axpages' then
       begin
         GetPageName:=name;
         GetPageCaption:=vartostr(Result.DocumentElement.Attributes['caption']);;
         GetPageImg:=vartostr(Result.DocumentElement.Attributes['img']);
         GetPageVisible:=vartostr(Result.DocumentElement.Attributes['visible']);
         PageType:=vartostr(Result.DocumentElement.Attributes['type']);
         PageOrdNo:=vartostr(Result.DocumentElement.Attributes['ordno']);
         PageLevelNo:=vartostr(Result.DocumentElement.Attributes['levelno']);
         PageParent:=vartostr(Result.DocumentElement.Attributes['parent']);
       end
       else begin
         GetStructName:=name;
         GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
       end;
  end;
  if stime <> 'pagefound' then
  begin
    result:=LoadXMLData('<root></root>');
    if name <> 'pageorder' then
    begin
      if dbm.gf.structGetFrom <> 'folder' then begin
      begin
          x:=dbm.getxds(x);
          if name='' then w:=dbm.gf.sqllower+'(caption)='+lowercase(quotedstr(caption)) + 'and username='+quotedstr(uname)
          else w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name)) + 'and username='+quotedstr(uname) ;
          if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
            x.SetCDSName('Axprovider_'+sname+'_'+w)
          else
            x.SetCDSName('nolds_Axprovider_'+sname+'_'+w);
          x.sqltext:='select * from '+sname+' where '+w;
          x.open;
          if x.isempty then
          begin
             x.close;
             if name='' then w:=dbm.gf.sqllower+'(caption)='+lowercase(quotedstr(caption)) + 'and username='+quotedstr('all')
             else w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name)) + 'and username='+quotedstr('all') ;
             if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
               x.SetCDSName('Axprovider_'+sname+'_'+w)
             else
               x.SetCDSName('nolds_Axprovider_'+sname+'_'+w);
             x.sqltext:='select * from '+sname+' where '+w;
             x.open;
          end;
          if not x.isempty then begin
            stm := TStringStream.Create;
            dbm.ReadMemo('props', sname, w, stm);
            if stm.Size=0 then result:=LoadXMLData('<root/>')
            else result := LoadXMLDataFromWS(trim(stm.DataString));
            FreeAndNil(stm);
            if sname = 'axpages' then
            begin
              GetPageName:='';
              GetPageCaption:='';
              GetPageImg:='';
              GetPageVisible:='';
              GetPageName:=x.fieldbyname('name').asstring;
              GetPageCaption:=x.fieldbyname('caption').asstring;
              GetPageImg:= x.fieldbyname('img').asstring;
              GetPageVisible:= x.fieldbyname('visible').asstring;;
              PageType:=x.fieldbyname('type').asstring;;
              PageOrdNo:=x.fieldbyname('ordno').asstring;;
              PageLevelNo:=x.fieldbyname('levelno').asstring;;
              PageParent:=x.fieldbyname('parent').asstring;;
              result.DocumentElement.Attributes['name']:=GetPageName;
              result.DocumentElement.Attributes['caption']:=GetPageCaption;
              result.DocumentElement.Attributes['img'] := GetPageImg ;
              result.DocumentElement.Attributes['visible'] := GetPageVisible;
              result.DocumentElement.Attributes['type'] := PageType;
              result.DocumentElement.Attributes['ordno'] := PageOrdNo;
              result.DocumentElement.Attributes['levelno'] := PageLevelNo;
              result.DocumentElement.Attributes['parent'] := PageParent;
            end
            else begin
              GetStructName:=x.fieldbyname('name').asstring;
              GetStructCaption:='';
              if assigned(x.findfield('caption')) then GetStructCaption:=x.fieldbyname('caption').asstring;
              result.DocumentElement.Attributes['name'] := GetStructName;
              result.DocumentElement.Attributes['caption'] := GetStructCaption;
//              result.DocumentElement.Attributes['readonly'] := readonly;
              result.DocumentElement.Attributes['updusername'] := updusername;
            end;
          end else
          begin
            GetPageName:='';
            GetPageCaption:='';
            GetPageImg:='';
            GetPageVisible:='';
            result:=LoadXMLData('<root/>');
            x.close;
            if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
               raise exception.Create(sname + ' [' + name + '] is not available...');
          end;
      end;
      end
      else if (trim(dbm.gf.structURL) <> '') and (result.DocumentElement.ChildNodes.Count = 0) then
      begin
        xml := LoadXMLData('<root></root>') ;
        xnode :=xml.documentelement;
        xnode.attributes['axpapp'] := dbm.gf.AppName;
        xnode.attributes['sessionid'] := dbm.gf.sessionid;
        if dbm.gf.DoDebug.Active then
          xnode.Attributes['trace'] := 'true'
        else
          xnode.Attributes['trace'] := 'false';
        xnode.AddChild('sname').NodeValue := sname;
        xnode.AddChild('name').NodeValue := name;
        xnode.AddChild('caption').NodeValue := caption;
        xnode.AddChild('uname').NodeValue := uname;
        xml.saveToXML(xmlstg);
        dbm.gf.DoDebug.Msg('>>Calling GetStructure webservice');
//        s := ( dbm.gf.AMSCall as ARS).GetStructure(xmlstg) ;
        msg := copy(s,1,pos('~',s)-1);
        delete(s,1,pos('~',s));
        if dbm.gf.DoDebug.Active then DebugMessage(msg);
        if copy(s,1,7) = '<error>' then
        begin
          delete(s,1,7);
          msg := copy(s,1,pos('<',s)-1);
          raise exception.Create(msg);
        end;
        result := LoadXMLData(s);
        if (sname = 'axpages') then
        begin
          GetPageName:='';
          GetPageCaption:='';
          GetPageImg:='';
          GetPageVisible:='';
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetPageName:=vartostr(result.DocumentElement.Attributes['name']);
              GetPageCaption:=vartostr(result.DocumentElement.Attributes['caption']);
              GetPageImg:=vartostr(result.DocumentElement.Attributes['img']);
              GetPageVisible:=vartostr(result.DocumentElement.Attributes['visible']);
              PageType:=vartostr(result.DocumentElement.Attributes['type']);
              PageOrdNo:=vartostr(result.DocumentElement.Attributes['ordno']);
              PageLevelNo:=vartostr(result.DocumentElement.Attributes['levelno']);
              PageParent:=vartostr(result.DocumentElement.Attributes['parent']);
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end else begin
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetStructName:=vartostr(result.DocumentElement.Attributes['name']);
              GetStructCaption:=trim(vartostr(result.DocumentElement.Attributes['caption']));
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end;
      end;
    end
    else result := GetPageOrderXML;
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
//    result.DocumentElement.Attributes['readonly'] := readonly;
    result.DocumentElement.Attributes['updusername'] := updusername;
    tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+uname ;
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
    result.SaveToFile(sfile);
    with TCompress.Create do begin
       compressfile(sfile, tfile);
       destroy;
    end;
    if fileexists(tfile) then begin
       if fileexists(sfile) then deletefile(sfile);
    end;
  end;
  if sname = 'printprops' then
  begin
     sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
     GetPrintTemplate('printprops',GetStructName,sfile);
  end;
  axml := nil; xnode:= nil;
  finally
    dbm.gf.IsGetStruct := False;
  end;
end;

procedure TAxProvider.SetStructure(sname, name, caption: string; xml:IXMLDocument; UpdSrcDate:Boolean=False);
var w, t : string;
    rfile,pexits,s,pcode,sverno,prodstring : String;
    sr:TSearchRec;
    i , pid , j : integer;
    starttrans, StructExists : boolean;
begin
  servertime := '';
  pexits := '';
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     showmessage('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if sname = 'tstructs' then begin
    rfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.res';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.cls';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.pfx';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.agf';
    if fileexists(rfile) then deletefile(rfile);
    rfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'_*.cds';
    if (findfirst(rfile, faAnyFile, sr)=0) then begin
      repeat
        if (sr.name = '.') or (sr.Name = '..') then continue;
        deletefile(dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+sr.name);
      until FindNext(sr) <> 0;
      FindClose(sr);
    end;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
//  if fileexists(rfile) then deletefile(rfile);
  if dbm.gf.RemoteLogin then
  begin
    t := RemoteSetStructure(sname,name,caption,'',xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      if sname = 'tstructs' then xml.DocumentElement.Attributes['pform'] := 'yes' ;
      if name = 'pageorder' then exit;
      if sname = 'axpages' then
      begin
        if not xml.DocumentElement.HasAttribute('ordno') then exit;
        if vartostr(xml.DocumentElement.Attributes['ordno']) = '' then exit;
      end;
      sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption)
  else w:='name='+quotedstr(name);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  getupdtime := t;
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if sname = 'axpages' then
  begin
    q.close;
    if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
      q.SetCDSName('Axprovider_'+sname+'_'+w)
    else
      q.SetCDSName('nolds_Axprovider_'+sname+'_'+w);
    q.sqltext:='select type,parent,ordno,levelno,img,visible from '+sname+' where '+w;
    q.open;
    if not q.isempty then
    begin
      xml.DocumentElement.Attributes['img'] := q.fieldbyname('img').AsString;
      xml.DocumentElement.Attributes['visible']:= q.fieldbyname('visible').AsString;
      xml.DocumentElement.Attributes['type']:= q.fieldbyname('type').AsString;
      xml.DocumentElement.Attributes['ordno']:= q.fieldbyname('ordno').AsString;
      xml.DocumentElement.Attributes['levelno']:= q.fieldbyname('levelno').AsString;
      xml.DocumentElement.Attributes['parent']:= q.fieldbyname('parent').AsString;
      pexits := 'yes';
    end;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      starttrans := false;
      if not dbm.InTransaction then
      begin
         starttrans := true;
         dbm.StartTransaction(dbm.gf.connectionname);
      end;
      q.close;
      q.SetCDSName(sname);
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;
      if sname = 'tstructs' then
      begin
        if xml.DocumentElement.HasAttribute('wflow') then
           x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
        prodstring := trim(vartostr(xml.DocumentElement.Attributes['pid']));
 //       if strtoint(vartostr(xml.DocumentElement.Attributes['pid'])) > 0  then
        if (prodstring <> '') and (strtoint(prodstring) > 0) then
        begin
          pid := strtoint(vartostr(xml.DocumentElement.Attributes['pid']));
          i := 0;
          i := GetProdCode(name);
          j := i;
          i := pid - i;
          if (i <> lm.licProdCode) and (i<>0) then
          begin
             //ShowMessage('Product code in tstruct('+name+') not compatible with license. This TStruct can not save...');
             //raise Exception.Create('Product code in tstruct('+name+') not compatible with license. This TStruct can not save...');
          end;
        end;
        i := 0;
        i := GetProdCode(name);
        i := i + lm.licProdCode;
        pcode := inttostr(i);
        xml.DocumentElement.Attributes['pid']:= pcode;
        sverno := dbm.gf.RemoveSpecificChar('.',dbm.gf.exeverno);
        if strtoint(sverno) >= 10000 then
           xml.DocumentElement.Attributes['sverno']:= sverno;
      end;
      if pexits = 'yes' then
      begin
        x.Submit('img', vartostr(xml.DocumentElement.Attributes['img']), 'c');
        x.Submit('visible', vartostr(xml.DocumentElement.Attributes['visible']), 'c');
        x.Submit('type', vartostr(xml.DocumentElement.Attributes['type']), 'c');
        x.Submit('parent', vartostr(xml.DocumentElement.Attributes['parent']), 'c');
        if vartostr(xml.DocumentElement.Attributes['ordno']) <> '' then
           x.Submit('ordno', vartostr(xml.DocumentElement.Attributes['ordno']), 'n');
        if vartostr(xml.DocumentElement.Attributes['levelno']) <> '' then
           x.Submit('levelno', vartostr(xml.DocumentElement.Attributes['levelno']), 'n');
      end;
      x.AddOrEdit(sname, w);
      x.Post;
      if sname = 'tstructs' then
      begin
        sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
        tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
        xml.SaveToFile(sfile);
        with TCompress.Create do begin
          compressfile(sfile, tfile);
          destroy;
        end;
        if fileexists(tfile) then begin
          if fileexists(sfile) then deletefile(sfile);
        end;
        dbm.WriteBlob('props', sname, w, tfile);
      end else
      begin
        s:=dbm.gf.startpath+'temp\xmlmemo'+dbm.gf.getnumber;
        xml.SaveToFile(s);
        dbm.WriteMemo('props', sname, w, s);
        deletefile(s);
      end;
      if starttrans then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
       if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure - '+e.Message);
        if starttrans then dbm.RollBack(dbm.gf.connectionname)
        else raise;
      end;
    end;
  end;
  servertime := t;
  if (name = 'pageorder') or ((sname = 'axpages') and (pexits = '')) then exit;
  if sname = 'tstructs' then exit;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

function TAxProvider.GetProdCode(s:string) : integer;
  var i,k,j: integer;
begin
  k := 0;
  s := lowercase(s);
  for i := 1 to length(s) do
  begin
     j := ord(s[i]);
     k := k + (j + i*100);
  end;
  result := k;
end;

procedure TAxProvider.SetStructure(sname, name, caption , uname : string; xml:IXMLDocument; UpdSrcDate:Boolean=False);
var w, t : string;
    rfile : String;
    StructExists, flag : Boolean;
begin
  servertime := '';
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     showmessage('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  getupdtime := t;
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction;
      if (not flag) then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.SetCDSName(sname);
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;
      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
      end;
      x.AddOrEdit(sname, w);
      x.Post;
      s:=dbm.gf.startpath+'temp\xmlmemo'+dbm.gf.getnumber;
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag)  then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure(Overload with 6 params) - '+e.Message);
        if (not flag)  then dbm.RollBack(dbm.gf.connectionname);
      end;
    end;
  end;
  servertime := t;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

procedure TAxProvider.SetStructure(sname, name, caption,uname,transid : string; xml:IXMLDocument; UpdSrcDate:Boolean=False);
var w, t : string;
    rfile : String;
    StructExists,flag : boolean;
begin
  servertime := '';
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     showmessage('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
      tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  getupdtime := t;
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if UpdSrcDate then
  begin
    xml.DocumentElement.Attributes['importedon'] := t;
    xml.DocumentElement.Attributes['importedby'] := dbm.gf.username;
    if StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := CreatedOn;
      xml.DocumentElement.Attributes['createdby'] := CreatedBy;
    end;
  end
  else
  begin
    if not StructExists then
    begin
      xml.DocumentElement.Attributes['createdon'] := t;
      xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
      xml.DocumentElement.Attributes['importedon'] := '';
      xml.DocumentElement.Attributes['importedby'] := '';
    end;
    xml.DocumentElement.Attributes['updatedon'] := t;
    xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  end;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction;
      if (not flag)  then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('transid', transid, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if UpdSrcDate then
      begin
        if not StructExists then
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        end else
        begin
          x.Submit('createdon',CreatedOn,'c');
          x.Submit('createdby',CreatedBy,'c');
        end;
        x.Submit('updatedon',vartostr(xml.DocumentElement.Attributes['updatedon']),'c');
        x.Submit('updatedby',vartostr(xml.DocumentElement.Attributes['updatedby']),'c');
        x.Submit('importedon',t,'c');
        x.Submit('importedby',dbm.gf.username,'c');
      end else
      begin
        if not StructExists then
        begin
          x.Submit('createdon',t,'c');
          x.Submit('createdby',dbm.gf.username,'c');
        end else
        begin
          x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
          x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
          x.Submit('importedon',ImportedOn,'c');
          x.Submit('importedby',ImportedBy,'c');
        end;
        x.Submit('updatedon',t,'c');
        x.Submit('updatedby',dbm.gf.username,'c');
      end;

      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
      end;

      x.AddOrEdit(sname, w);
      x.Post;
      s:=dbm.gf.startpath+'temp\xmlmemo'+dbm.gf.getnumber;
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag) then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure(Overload with 7 params) - '+e.Message);
        if (not flag) then dbm.RollBack(dbm.gf.connectionname);
      end;
    end;
  end;
  servertime := t;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

procedure TAxProvider.SetStructReadonly(sname,name,readonly : string);
   var sqltext : string;
begin
  exit;
  sqltext := 'update '+sname+' set readonly = ' + quotedstr(readonly) + ',updusername = ' + quotedstr(dbm.gf.username) + ' where name = ' + quotedstr(name);
  if dbm.gf.RemoteLogin then
  begin
//    s := q.RExecSQL(sqltext);
    if s <> '' then raise Exception.Create(s);
  end
  else
  begin
    q.close;
    q.sqltext:=sqltext;
    q.execsql;
  end;
end;

function TAxProvider.GetPage(name, caption,purpose: string): IXMLDocument;
   var w,stime,sname:string;
begin
  if dbm.gf.RemoteLogin then begin
    GetPageName:='';
    GetPageCaption:='';
    GetPageImg:='';
    GetPageVisible:='';
    Result := RemotegetStructure('axpages',name, caption,purpose,'');
//    if Result.DocumentElement.ChildNodes.Count = 0 then exit;
    GetPageName:=vartostr(Result.DocumentElement.Attributes['name']);
    GetPageCaption:=vartostr(Result.DocumentElement.Attributes['caption']);
    GetPageImg:=vartostr(Result.DocumentElement.Attributes['img']);
    GetPageVisible:=vartostr(Result.DocumentElement.Attributes['visible']);
    PageType:=vartostr(result.DocumentElement.Attributes['type']);
    PageOrdNo:=vartostr(result.DocumentElement.Attributes['ordno']);
    PageLevelNo:=vartostr(result.DocumentElement.Attributes['levelno']);
    PageParent:=vartostr(result.DocumentElement.Attributes['parent']);
    PageFormType :=vartostr(result.DocumentElement.Attributes['pgtype']);
    exit;
  end;
  result := getStructure('axpages',name,caption,purpose);
end;

function TAxProvider.GetPageOrderXML() : IXMLDocument;
  var n : IXMLNode;
      i,ExprListCount : integer;
      pgs : TStringList;
      cat,SqlTxt,OrgSqlTxt,OrdTxt : string;
begin
  pgs := nil;
  SqlTxt := '';
  ExprListCount := 1;
  if dbm.gf.pageaccess <> '' then
  begin
    pgs := TStringList.Create;
    if pos(',',dbm.gf.pageaccess) > 0 then
    begin
      i := 1;
      while true do
      begin
        s := dbm.gf.GetnthString(dbm.gf.pageaccess,i);
        if s = '' then break;
        pgs.Add(s);
        i := i + 1;
      end;
    end
    else pgs.Add(dbm.gf.pageaccess);
  end;
  result:=LoadXMLData('<root></root>');
  result.DocumentElement.Attributes['updatedon'] := servertime;
  if pos('default',dbm.gf.userroles) > 0 then
   if (wTName = 'page open') or (wTName = 'page load')  then
   begin
     x.SetCDSName('Axprovider_'+'axpages_getpageorder_Default');
     x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' ) order by ordno ,levelno ';
   end
  else
  begin
   x.SetCDSName('Axprovider_'+'axpages_getpageorder_Default');
   x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) order by ordno ,levelno ';
  end
  else
  begin
    s := '';
    x.sqltext:='select name,caption,type,visible,img,parent,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
    x.SetCDSName('Axprovider_'+'axpages_getpageorder_Useraccess');
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    OrgSqlTxt := ' select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) and name in';
    OrdTxt := ' order by ordno ,levelno ';
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
      Inc(ExprListCount);
      if ExprListCount >= 500 then begin
        delete(s,length(s),2);
        if SqlTxt = '' then
           SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
        else
           SqlTxt := SqlTxt + ' Union '+OrgSqlTxt+' ( ' + s + ' ) ';
        s := '';
        ExprListCount := 1;
      end;
    end;
    if s <> '' then delete(s,length(s),2);    
    if (ExprListCount > 1) then begin
       if (SqlTxt = '') then
          SqlTxt := OrgSqlTxt+' ( ' + s + ' ) '
       else
          SqlTxt := SqlTxt + ' Union '+ OrgSqlTxt+' ( ' + s + ' ) ' ;
    end;
    if SqlTxt = '' then raise exception.Create('User Roles not defined for this user');
    SqlTxt := 'select * from ('+SqlTxt+') a '+OrdTxt;
    x.close;
    x.sqltext:= SqlTxt;    
  end;
  s := '';
  x.SetCDSName('Axprovider_'+'axpages_getpageorder');
  x.open;
  while not x.eof do begin
    cat := lowercase(x.fieldbyname('category').AsString) ;
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1  then
      begin
        x.next;
        continue;
      end;
    end;
    s := x.fieldbyname('name').AsString ;
    if (x.fieldbyname('levelno').asstring = '0') then
    begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'true'
       else
          n.Attributes['group'] := 'false';
    end else if (x.fieldbyname('levelno').asstring = '1') then
    begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'pop'
       else
          n.Attributes['group'] := 'false';
    end else begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'subpop'
       else
          n.Attributes['group'] := 'false';
    end;
    n.Attributes['img'] :=  x.fieldbyname('img').asstring;
    n.Attributes['visible'] := x.fieldbyname('visible').asstring;
    n.Attributes['parent']  := x.fieldbyname('parent').asstring;
    n.Attributes['levelno']  := x.fieldbyname('levelno').asstring;
    n.Attributes['pagetype']  := x.fieldbyname('pagetype').asstring;
    n.Attributes['type']  := x.fieldbyname('type').asstring;
    n.NodeValue := x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if assigned(pgs) then
  begin
     pgs.clear;
     Freeandnil(pgs);
  end;
end;

procedure TAxProvider.SetImage(sname, name : string);
var w , t :string;
     flag : Boolean;
begin
  if dbm.gf.RemoteLogin then begin
    s := UploadFile('temp',name);
    RemoteSetImage(sname,name,s);
    exit;
  end;
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  w:='name='+quotedstr(name);
  try
    flag := dbm.InTransaction;
    if (not flag)  then  dbm.StartTransaction(dbm.gf.connectionname);
    q.close;
    q.sqltext:='delete from '+sname+' where '+w;
    q.execsql;
    x.Submit('name', name, 'c');
    x.Submit('blobno', '1', 'n');
    x.Submit('updatedon', t, 'c');
    x.Submit('imgcount', '0', 'n');
    x.AddOrEdit(sname, w);
    x.Post;
    s:=dbm.gf.startpath+'images\'+name;
    dbm.WriteBlob('img', sname, w, s);
    if (not flag) then  dbm.Commit(dbm.gf.connectionname);
  except on e : exception do
    begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetImage - '+e.Message);
      if (not flag) then dbm.RollBack(dbm.gf.connectionname);
    end;
  end;
//  deletefile(s);
end;

procedure TAxProvider.DeleteStrucutre(sname, name, caption: string);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDeleteStrucutre(sname,name,caption);
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
    if fileexists(sfile) then deletefile(sfile);
    exit;
  end;
  axml := nil;
  if name = '' then
  begin
     axml := ExecSQL('select name from ' + sname + ' where  caption = :caption',caption,'c',True);
     xNode := axml.DocumentElement;
     xNode := xNode.ChildNodes.FindNode('data');
     if (xNode <> nil) and (xNode.ChildNodes.Count > 0) then xNode := xNode.ChildNodes[0]
     else xNode := nil;
     if xNode <> nil then
       name := vartostr(xNode.ChildValues['NAME']);
  end;
  if trim(name) = '' then exit;
  x.DeleteRecord(sname, 'name='+quotedstr(name));
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
  if fileexists(sfile) then deletefile(sfile);
end;

function TAxProvider.ExecSQL(SQLText, ParamValues, ParamTypes:String; WithData:Boolean):IXMLDocument;
var i:integer;
    s:string;
    n:ixmlnode;
    dt : TFieldType;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteExecSQL(SQLText,ParamValues,ParamTypes,WithData);
    exit;
  end;
  result:=loadxmldata('<root></root>');
  q.Close;
  {if  lowercase(q.Connection.DbType) = 'ms sql' then q.Ado.Parameters.Clear
  else if lowercase(q.Connection.DbType) = 'oracle' then q.dbx.Params.Clear;}
  q.sqltext:=sqltext;
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    q.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;

  if lowercase(copy(sqltext,1,7)) <> 'select ' then
    q.execsql
  else begin
    if (q.Connection.DbType = 'ms sql') and (pos('into', lowercase(q.SqlText)) > 0) then
      q.execsql
    else begin
      q.open;
      xnode:=result.DocumentElement;
      xnode:=xnode.AddChild('schema');
      for i:=0 to q.Fields.Count-1 do begin
        n:=xnode.AddChild(q.fields[i].FieldName);
        dt := q.Fields[i].DataType;
        case dt of
          ftFMTBcd,ftBCD,ftSmallint,ftInteger,ftFloat,ftCurrency,ftLargeint : n.Attributes['type'] := 'n';
          ftDate,ftTime, ftDateTime,ftTimeStamp : n.Attributes['type'] := 'd';
          else n.Attributes['type'] := 'c';
        end;
        if ( dt = ftOraClob) or (dt = ftOraBlob) or
           ((dt = ftWideMemo) and (q.Connection.DbType = 'oracle')) then n.Attributes['org_datatype'] := VarToStr(dt);
      end;
      if withdata then begin
        xnode:=result.DocumentElement;
        xnode:=xnode.AddChild('data');
        while not q.eof do begin
          n:=xnode.AddChild('row');
          for i:=0 to q.Fields.Count-1 do
            n.AddChild(q.fields[i].FieldName).NodeValue:=q.Fields[i].AsString;
          q.next;
        end;
      end;
    end;
  end;
end;

function TAxProvider.ExecSQLThroughCDS(SQLText, ParamValues, ParamTypes:String; WithData:Boolean):IXMLDocument;
var i:integer;
    s:string;
    n:ixmlnode;
    dt : TFieldType;
begin
  result:=loadxmldata('<root></root>');
  forcds.close;
  forcds.buffered := True;
  forcds.cds.CommandText:=sqltext;
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    forcds.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;

  if lowercase(copy(sqltext,1,7)) <> 'select ' then
    forcds.execsql
  else begin
    if (forcds.Connection.DbType = 'ms sql') and (pos('into', lowercase(forcds.cds.CommandText)) > 0) then
      forcds.execsql
    else begin
      forcds.open;
      xnode:=result.DocumentElement;
      xnode:=xnode.AddChild('schema');
      for i:=0 to forcds.cds.Fields.Count-1 do begin
        n:=xnode.AddChild(forcds.cds.fields[i].FieldName);
        dt := forcds.cds.Fields[i].DataType;
        case dt of
          ftFMTBcd,ftBCD,ftSmallint,ftInteger,ftFloat,ftCurrency,ftLargeint : n.Attributes['type'] := 'n';
          ftDate,ftTime, ftDateTime,ftTimeStamp : n.Attributes['type'] := 'd';
          else n.Attributes['type'] := 'c';
        end;
      end;

      if withdata then begin
        xnode:=result.DocumentElement;
        xnode:=xnode.AddChild('data');
        while not forcds.cds.eof do begin
          n:=xnode.AddChild('row');
          for i:=0 to forcds.cds.Fields.Count-1 do
            n.AddChild(forcds.cds.fields[i].FieldName).NodeValue:=forcds.cds.Fields[i].AsString;
          forcds.cds.next;
        end;
      end;
    end;
  end;
end;

function TAxProvider.GetParam(SQLText:String):IXMLDocument;
var i:integer;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteGetParam(SQLText);
    exit;
  end;
  result:=loadxmldata('<root></root>');
  q.close;
  q.sqltext :=sqltext;
  xnode:=result.DocumentElement;
  q.GetParamNames;
  for i := 0 to q.ParamNames.Count-1 do
    xnode.AddChild(q.ParamNames[i]);
  q.close;
end;


Procedure TAxProvider.CreateTable(TableName:String;FName :String);
 var St ,ErrMsg   :string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteCreateTable(TableName,FName);
    exit;
  end;
  Try
   q.close;
   if FName <> '' then begin
     if dbm.Connection.DbType = 'mysql' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ') ENGINE=InnoDB'
     else if dbm.Connection.DbType = 'access' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + FName + ')'
     else if dbm.Connection.DbType = 'ms sql' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + FName + ')'
     else if dbm.Connection.DbType = 'postgre' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ')'
     else
       St := 'Create Table '+ UpperCase(TableName) + '(' + FName + ')';
   end else begin
     if dbm.Connection.DbType = 'mysql' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id decimal(16)) ENGINE=InnoDB'
     else if dbm.Connection.DbType = 'access' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + TableName +'id double)'
     else if dbm.Connection.DbType = 'ms sql' then
       St := 'Create Table ['+ UpperCase(TableName) + '] (' + TableName +'id integer)'
     else if dbm.Connection.DbType = 'postgre' then
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id numeric(16))'
     else
       St := 'Create Table '+ UpperCase(TableName) + '(' + TableName + 'id integer)';
   end;
   q.sqltext := St;
   q.execsql;
  Except on e:exception do begin
   if assigned(dbm) then
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\CreateTable - '+e.Message);
   ErrMsg := e.message ;
   Showmessage('TablesCreated ~ '+ TableName +'  ' + Errmsg +'');
   end;
  End;
end;

Function TAxProvider.GetJoinStr(Fname,DType:String;Width,Dec :integer;ToModify:Boolean=False):string;
  var  Temp, s : string;
begin
  if dbm.Connection.DbType = 'access' then
    Temp := '[' + Fname + ']'
  else if dbm.Connection.DbType = 'ms sql' then
    Temp := '[' + Fname + ']'
  else if dbm.Connection.DbType = 'mysql' then
    Temp := Fname
  else
    Temp := Fname;
  if (dbm.Connection.DbType = 'postgre') and (ToModify) then
    Temp := Temp+' type ';
  if (uppercase(DType) = 'N') then
  begin
    if dbm.Connection.DbType = 'access' then begin
      If (Width<=5) And (Dec=0) Then Temp := Temp + '  INTEGER'
      Else  Temp := Temp + '  DOUBLE';
    end else begin
      s := '  NUMERIC('+inttostr(width)+ ',' + inttostr(dec)+')';
      Temp := Temp + s;
{     if dbm.Connection.DbType = 'mysql' then
        Temp := Temp + ' Default 0';}        //new
    end;
  end else if (uppercase(DType) = 'C') then begin
    if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  VARCHAR2('+inttostr(width)+')'
    else if dbm.Connection.DbType = 'mysql' then begin
    {*[MYSQL - supports 255 char length for varchar earlier [before ver 5.0.3] , later they changed to 65535]
      So we removed conditional statement which checks whether the char length is grater than 255 *}
      Temp := Temp + '  VARCHAR('+inttostr(width)+')';
    //  Temp := Temp + ' Default '''''; //new
    end else if dbm.Connection.DbType = 'access' then begin
      If width < 255 Then Temp := Temp + '  Text('+inttostr(width)+')'
      Else Temp := Temp + ' Memo';
    end else begin
      if dbm.gf.MsSql_Unicode_Char = 'N' then Temp := Temp + ' NVARCHAR('+inttostr(width)+')'
      else begin
        s := '  VARCHAR('+inttostr(width)+')';
        Temp := Temp + s ;
      end;
    end;
  end else if (uppercase(DType) = 'D') then begin
    if (dbm.Connection.DbType = 'ms sql')  then
      Temp := Temp + '  DATETIME'
    else
    begin
      s := '  DATE';
      Temp := Temp +s;
    end;
    {if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' Default ''1900/01/01''';}//new
  end else if (uppercase(DType) = 'T') then begin
    if dbm.Connection.DbType = 'access' then
      Temp := Temp + ' Memo'
    else if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  NCLOB'//Temp + '  CLOB'
    else if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' Text ' //Default ''''' new
    else if dbm.Connection.DbType = 'ms sql' then begin
      if dbm.gf.MsSql_Unicode_Char = 'N' then Temp := Temp + ' NVARCHAR(MAX)'
      else Temp := Temp + '  VARCHAR(MAX)'
    end
    else
    begin
      s := '  Text';
      Temp := Temp +s;
    end;
  end else if (uppercase(DType) = 'I') then begin
    if dbm.Connection.DbType = 'access' then
      Temp := Temp + ' Memo'
    else if dbm.Connection.DbType = 'oracle' then
      Temp := Temp + '  BLOB'
    else if dbm.Connection.DbType = 'mysql' then
      Temp := Temp + ' BLOB ' //Default ''''' new
    else if dbm.Connection.DbType = 'postgre' then
    begin
      s := ' BYTEA ';
      Temp := Temp + s //Default ''''' new
    end
    else Temp := Temp + '  IMAGE';
  end;
  if (dbm.Connection.DbType = 'postgre') and (ToModify) then
    Temp := Temp+ ' USING '+Fname+'::'+s;
  Result := Temp;
end;


function TAxProvider.CreateField(TableName,FName,DType:String;FWidth,FDec:Integer) : boolean;
  var JoinStr : String;
   flag : Boolean;
begin
  result := false;
  if dbm.gf.RemoteLogin then begin
    RemoteCreateField(TableName,FName,DType,FWidth,FDec);
    result := true;
    exit;
  end;
  JoinStr := GetJoinStr(FName,DType,FWidth,FDec);
  Try
    flag := dbm.InTransaction;
    if (not flag) then dbm.StartTransaction(dbm.gf.connectionname);
    q.close;
    if dbm.Connection.DbType = 'access' then
        q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add ' + JoinStr
    else if dbm.Connection.DbType = 'ms sql' then
        q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add ' + JoinStr
    else
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' add ' + JoinStr;
    q.ExecSQL;
    if (not flag) then dbm.Commit(dbm.gf.connectionname);
  Except on e:Exception do begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\CreateField - '+e.Message);
      if  (not flag)  then dbm.RollBack(dbm.gf.connectionname);
      if Not IsAxpDefStructure then
      begin
        if e.Message = '' then
          ShowMessage('Not able to create field '''+JoinStr+'''')
        else
          showmessage(e.Message+#13+JoinStr);
      end;
      exit;
    end;
  End;
  result := True;
end;

Procedure TAxProvider.Deletefields(TableName,FieldName: String);
  var  sqlstring : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDeletefields(TableName,FieldName);
    exit;
  end;
  if dbm.Connection.DbType = 'paradox' then
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop ' +FieldName
  else if dbm.Connection.DbType = 'ms sql' then
     sqlstring := 'Alter table ['+ UpperCase(TableName) + '] Drop Column [' +FieldName + ']'
  else if dbm.Connection.DbType = 'access' then
     sqlstring := 'Alter table ['+ UpperCase(TableName) + '] Drop Column [' +FieldName + ']'
  else if dbm.Connection.DbType = 'mysql' then
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop Column ' +FieldName
  else
     sqlstring := 'Alter table '+ UpperCase(TableName) + ' Drop Column ' +FieldName ;
  Try
    q.Close;
    q.SQLText := sqlstring;
    q.ExecSQL;
  Except on e:exception do begin
    sqlstring := e.Message ;
    if assigned(dbm) then
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\Deletefields - '+e.Message);
{    if FrmMessage <> nil then begin
     FrmMessage.showErrorMessage('Invalid Relation: ' + Tablename + '.'+Fieldname ); //E.Message
     FrmMessage.ShowFinalMessages('Error' , ' Process Stopped  ' , 'Error While Saving '+ Tablename + '.'+Fieldname );
    end;}
    if dbm.Connection.DbType = 'paradox' then
      if (pos(LowerCase('table does not exist'),LowerCase(sqlstring)) = 0) and (pos(LowerCase('field not found in table'),LowerCase(sqlstring)) = 0) then
        ShowMessage('Not able to drop field '''+FieldName+''''+#13+e.Message)
    else
     if pos(LowerCase('invalid column name'),LowerCase(sqlstring)) = 0 then
        ShowMessage('Not able to drop field '''+FieldName+''''+#13+e.Message);
    sqlstring := '';
    end;
  End
end;

Procedure TAxProvider.DropTable(TableName:String);
  var  St,ErrMsg : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDropTable(TableName);
    exit;
  end;
  Try
   q.Close;
   St := 'Drop Table '+ UpperCase(TableName) ;
   q.sqltext := St;
   q.ExecSQL;
   q.Close;
  Except on e:exception do begin
   if assigned(dbm) then
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\DropTable - '+e.Message);
   ErrMsg := e.message ;
   Showmessage('Cannot Drop Table  ~ '+ TableName +'  ' + Errmsg +'');
   end;
  End;
end;

function TAxProvider.CreateHistoryTable(TableName:String): Boolean;
begin
      if (lowercase(dbm.Connection.DbType) = 'ms sql') and (dbm.gf.MsSql_Unicode_Char = 'N')  then
        q.sqltext := 'recordid numeric(16), modifieddate datetime, ' +
          ' username varchar(30), fieldname varchar(30), oldvalue nvarchar(250), '
          + ' newvalue nvarchar(250),rowno numeric(38), delflag varchar(1), modno numeric(10),'
          + ' frameno numeric(10), parentrow numeric(10), tablerecid numeric(16), '
          + ' idvalue numeric(16), oldidvalue numeric(16), transdeleted varchar(5),newtrans varchar(5),canceltrans varchar(1),cancelremarks nvarchar(250)'
      else if lowercase(dbm.Connection.DbType) = 'ms sql' then
        q.sqltext := 'recordid numeric(16), modifieddate datetime, ' +
          ' username varchar(30), fieldname varchar(30), oldvalue varchar(250), '
          + ' newvalue varchar(250),rowno numeric(38), delflag varchar(1), modno numeric(10),'
          + ' frameno numeric(10), parentrow numeric(10), tablerecid numeric(16), '
          + ' idvalue numeric(16), oldidvalue numeric(16), transdeleted varchar(5),newtrans varchar(5),canceltrans varchar(1),cancelremarks varchar(250)'
      else if lowercase(dbm.Connection.DbType) = 'mysql' then
        q.sqltext := 'recordid numeric(16), modifieddate date, ' +
          ' username varchar(30), fieldname varchar(30), oldvalue varchar(250), '
          + ' newvalue varchar(250),rowno numeric(38), delflag varchar(1), modno numeric(10),'
          + ' frameno numeric(10), parentrow numeric(10), tablerecid numeric(16), '
          + 'idvalue numeric(16), oldidvalue numeric(16), transdeleted varchar(5),newtrans varchar(5),canceltrans varchar(1),cancelremarks varchar(250)'
      else if lowercase(dbm.Connection.DbType) = 'postgre' then
        q.sqltext := 'recordid numeric(16), modifieddate timestamp, ' +
          ' username varchar(30), fieldname varchar(30), oldvalue varchar(250), '
          + ' newvalue varchar(250),rowno numeric(38), delflag varchar(1), modno numeric(10),'
          + ' frameno numeric(10), parentrow numeric(10), tablerecid numeric(16), '
          + 'idvalue numeric(16), oldidvalue numeric(16), transdeleted varchar(5),newtrans varchar(5),canceltrans varchar(1),cancelremarks varchar(250)'
      else
        q.sqltext := 'recordid numeric(16), modifieddate date, ' +
          ' username varchar2(30), fieldname varchar2(30), oldvalue varchar2(250), '
          + ' newvalue varchar2(250),rowno numeric(38), delflag varchar2(1), modno numeric(10),'
          + ' frameno numeric(10), parentrow numeric(10), tablerecid numeric(16), '
          + 'idvalue numeric(16), oldidvalue numeric(16), transdeleted varchar2(5),newtrans varchar2(5),canceltrans varchar2(1),cancelremarks varchar2(250)';
        CreateTable(TableName, q.sqltext);
end;

Function TAxProvider.TableFound(Tablename :String) :Boolean;
begin
  if dbm.gf.RemoteLogin then
  begin
    Result :=False;
    forcds.Close;
    forcds.SetCDSName('Axprovider_'+'tablefound_'+Tablename);
    forcds.buffered := True;
    if dbm.Connection.DbType = 'access' then
      forcds.CDS.CommandText := 'Select * from [' + UpperCase(Tablename) +']'
    else if dbm.Connection.DbType = 'ms sql' then
      forcds.CDS.CommandText := 'Select * from [' + UpperCase(Tablename) +']'
    else
       forcds.CDS.CommandText := 'Select * from ' + UpperCase(Tablename) +'';
    Try
      forcds.open ;
      forcds.CDS.Active := True;
      Result := True;
    Except on e:Exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\TableFound - '+e.Message);
      end;
    end;
  end
  else begin
    Result :=False;
    q.Close;
    q.SetCDSName('Axprovider_'+'tablefound_'+Tablename);
    if dbm.Connection.DbType = 'access' then
      q.sqltext := 'Select * from [' + UpperCase(Tablename) +']  where 1=2 '
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Select * from [' + UpperCase(Tablename) +']  where 1=2 '
    else
       q.sqltext := 'Select * from ' + UpperCase(Tablename)  + ' where 1=2 ';
    Try
      //q.active will be executed directly without going to xds so we used q.open
      //q.Active := True; 
      q.open;
      Result := True;
    Except on e:Exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\TableFound - '+e.Message);
      end;
    end;
  end;
end;

procedure TAxProvider.AddConstraint(TableName,Constraints:String);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteAddConstraint(TableName,Constraints);
    exit;
  end;
  Try
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQlText := 'Alter table ['+ UpperCase(TableName) + '] add constraint ' + Constraints
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] add Constraint ' + Constraints
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' add Constraint ' + Constraints;

    q.ExecSQL;
  Except on e:Exception do
    begin
      if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\AddConstraint - '+e.Message);
      {if e.Message = '' then
        ShowMessage('Not able to create constraint '''+Constraints+'''')
      else
        showmessage(e.Message);}

    end;
  End;
end;

function TAxProvider.GetUsers : IXMLDocument;
begin
end;

function TAxProvider.GetUserGroups : IXMLDocument;
begin
end;

function TAxProvider.GetFolders(usergroup:String): IXMLDocument;
begin
end;

function TAxProvider.GetOptions(usergroup : string) : IXMLDocument;
begin
end;

function TAxProvider.GetImage(ImgName: string; Img: TBitMap):boolean;
  var lpath :string;
begin
  result:= false;
  lpath := ExtractFilepath(Application.ExeName)+'images\'+ImgName;
  if fileExists(lpath) then
  begin
     img.LoadFromFile(lpath);
     result := true;
  end
  else if Trim(imgName) <> '' then
  begin
    s:=DownLoadImage(imgName);
    if fileexists(s) then begin
      img.LoadFromFile(s);
      result := true;
    end;
  end;
end;

procedure TAxProvider.GetImage(ImgName: string; Img: TImage);
  var lpath:string;
begin
  lpath := ExtractFilepath(Application.ExeName)+'images\'+ImgName;
  if fileExists(lpath) then
     img.Picture.LoadFromFile(lpath)
  else if Trim(imgName) <> '' then begin
    s:=DownLoadImage(imgName);
    if fileexists(s) then begin
      img.Picture.LoadFromFile(s);
    end;
  end;
end;

function TAxProvider.DownloadImage(ImgName: string) : string ;
  var w:string;
begin
  result := '';
  if dbm.gf.RemoteLogin then begin
    result := RemoteDownLoadImage(ImgName);
    Exit;
  end;
  w:='name='+quotedstr(imgname);
  x.SetCDSName('Axprovider_'+'images_downloadimage_'+w);
  x.sqltext:='select * from images where '+w;
  x.open;
  if not x.isempty then begin
    s:=dbm.gf.startpath+'images\'+ImgName;
    dbm.ReadBlob('img', 'images', w, s);
    result := s;
  end;
  x.close;
end;

function TAxprovider.RemoteDownLoadImage(imgname : String) : string;
var
  s,tmppath : string;
begin
  result := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('imgname').NodeValue := imgname;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DownLoadImage webservice');
//  s := ( dbm.gf.AESCall as ARS).DownLoadImage(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  tmppath:=dbm.gf.startpath+'images\'+ImgName;
  if s <>'' then
  begin
    DownLoadFile(s,tmppath);
    result := tmppath;
  end;
  axml := nil;
end;

function TAxProvider.GetAllPages(sname:String): IXMLDocument;
var n : IXMLNode;
begin
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetStructure('axprops','pageorder','','','');
    exit;
  end;
  result := GetStructure('axprops','pageorder','','');
end;

function TAxProvider.GetTStructComp(name, cname: string): IXMLDocument;
var w:string;
    n,t : IXMLNode;
    i : Integer;
begin
  if dbm.gf.RemoteLogin then
  begin
    Result := RemoteGetTStructComp(name, cname);
    exit;
  end;
  xml := nil;
  x:=dbm.getxds(x);
  result:=LoadXMLData('<root></root>');
  xml := GetStructure('tstructs',name,'','');
  for i := 0 to xml.DocumentElement.ChildNodes.Count-1 do begin
    n := xml.DocumentElement.ChildNodes[i];
    if (cname = '') then begin
      t := result.DocumentElement.AddChild(n.NodeName);
      t.Attributes['cat'] := n.Attributes['cat'];
      if n.Attributes['cat'] = 'dc' then
        t.Attributes['grid'] := n.ChildValues['a6'];
      t.NodeValue := n.ChildValues['a2'];
    end else begin
      if n.Attributes['cat'] = cname then begin
        t := result.DocumentElement.AddChild(n.NodeName);
        t.Attributes['cat'] := n.Attributes['cat'];
        if vartostr(n.Attributes['cat'])='field' then
          t.Attributes['ftype'] := vartostr(n.ChildValues['a3']);  
        if n.Attributes['cat'] = 'dc' then
          t.Attributes['grid'] := n.ChildValues['a6'];
        t.NodeValue := n.ChildValues['a2'];
      end;
    end;
  end;
  xml := nil; n := nil; t := nil;
end;

function TAxProvider.EditField(TableName,FName,DType:String;FWidth,FDec:Integer):String;
var JoinStr : String;
    flag : Boolean;
begin
  if dbm.gf.RemoteLogin then
  begin
    Result := RemoteEditField(TableName,FName,DType,FWidth,FDec);
    if (Trim(lowercase(result)) = 'field edited successfully') then
      result := '';
    exit;
  end;
  result := '';
  JoinStr := GetJoinStr(FName,DType,FWidth,FDec,True);
  Try
    flag := dbm.InTransaction;
    if (not flag) then dbm.StartTransaction(dbm.gf.connectionname);
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQLtext := 'Alter table ['+ UpperCase(TableName) + '] modify ' + JoinStr
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] alter column ' + JoinStr
    else if dbm.Connection.DbType = 'postgre' then
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' alter column ' + JoinStr
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' modify ' + JoinStr;
    q.ExecSQL;
    if (not flag) then dbm.Commit(dbm.gf.connectionname);
  Except on e:Exception do begin
      if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\EditField - '+e.Message);
      if (not flag) then dbm.RollBack(dbm.gf.connectionname);
      result := 'error';
      if e.Message = '' then
        ShowMessage('Not able to modify field '''+JoinStr+'''')
      else
        ShowMessage('Column to be modified must be empty to decrease width or decimal.');
    end;
  End;
end;

function TAxprovider.RemoteGetStructure(sname, name, caption,purpose,uname:string):IXMLDocument;
  var stime,readonly,updusername : String;
  i : integer;
begin
  readlocal := false;
  xml := nil; stime := ''; result := nil; axml := nil;
  stime := '';
  if sname = 'lviews' then  uname := dbm.gf.username;
  if uname <> '' then
     sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+uname
  else
     sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
  if fileexists(sfile) then begin
    with TCompress.Create do begin
      decompressfile(sfile, tfile);
      destroy;
    end;
    if fileexists(tfile) then
    begin
      with tstringlist.create do begin
        loadfromfile(tfile);
        xml := Loadxmldata(text);
        Free;
      end;
      deletefile(tfile);
    end;
    readlocal := True;
    stime := 'pagefound';
    result := xml  ;
    exit;
  end;
  if name <> 'pageorder' then
  begin
    if stime <> 'pagefound' then
    begin
      xml := LoadXMLData('<root></root>') ;
      xnode :=xml.documentelement;
      xnode.attributes['axpapp'] := dbm.gf.AppName;
      xnode.attributes['sessionid'] := dbm.gf.sessionid;
      if dbm.gf.DoDebug.Active then
        xnode.Attributes['trace'] := 'true'
      else
        xnode.Attributes['trace'] := 'false';
      xnode.AddChild('sname').NodeValue := sname;
      xnode.AddChild('name').NodeValue := name;
      xnode.AddChild('caption').NodeValue := caption;
      xnode.AddChild('uname').NodeValue := uname;
      xml.saveToXML(xmlstg);
      dbm.gf.DoDebug.Msg('>>Calling GetStructure webservice');
//      s := (dbm.gf.AMSDataCall as ARS).GetStructure(xmlstg) ;
      msg := copy(s,1,pos('~',s)-1);
      delete(s,1,pos('~',s));
      if dbm.gf.DoDebug.Active then DebugMessage(msg);
      if copy(s,1,7) = '<error>' then
      begin
        delete(s,1,7);
        msg := copy(s,1,pos('<',s)-1);
        raise exception.Create(msg);
      end;
      result := LoadXMLData(s);
      if result.DocumentElement.ChildNodes.Count = 0 then
      begin
        xnode :=xml.documentelement;
        xnode.attributes['axpapp'] := dbm.gf.AppName;
        xnode.attributes['sessionid'] := dbm.gf.sessionid;
        if dbm.gf.DoDebug.Active then
          xnode.Attributes['trace'] := 'true'
        else
          xnode.Attributes['trace'] := 'false';
        xnode.AddChild('sname').NodeValue := sname;
        xnode.AddChild('name').NodeValue := name;
        xnode.AddChild('caption').NodeValue := caption;
        xnode.AddChild('uname').NodeValue := uname;
        xml.saveToXML(xmlstg);
        dbm.gf.DoDebug.Msg('>>Calling GetStructure webservice');
//        s := (dbm.gf.AMSCall as ARS).GetStructure(xmlStg);
        msg := copy(s,1,pos('~',s)-1);
        delete(s,1,pos('~',s));
        if dbm.gf.DoDebug.Active then DebugMessage(msg);
        if copy(s,1,7) = '<error>' then
        begin
          delete(s,1,7);
          msg := copy(s,1,pos('<',s)-1);
          raise exception.Create(msg);
        end;
        result :=  LoadXMLData(s);
     end;
    end;
  end
  else result := RemoteGetAllStructures('axpages');
  if trim(result.XML.Text) = '<root/>' then
  begin
    if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
       raise exception.Create(sname + ' [' + name + '] is not available...');
  end;
  if result <> nil then
  begin
  if uname <> '' then
     tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+uname
  else
     tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname ;
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.xml' ;
    result.SaveToFile(sfile);
    with TCompress.Create do begin
      compressfile(sfile, tfile);
      destroy;
    end;
    if fileexists(tfile) then begin
      if fileexists(sfile) then deletefile(sfile);
    end;
  end;
  axml := nil; xnode:= nil;
end;

function TAxProvider.RemoteGetAllStructures(sname:String): IXMLDocument;
  var   i : integer;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('role').NodeValue := dbm.gf.userroles;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllStructure webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetAllStructures(xmlStg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  // Getting structures from AMS server
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllStructure webservice');
//  s := ( dbm.gf.AMSCall as ARS).GetAllStructures(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
  begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
    end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteGetAllStructDTime : IXMLDocument;
  var   i,j : integer;
  n,n1,n2 : IXMLNode;
  s1 : string;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['lastlogintime'] := dbm.gf.lastlogintime;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllStructure DateTime webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetAllStructDTime(xmlStg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  // Getting structures from AMS server
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllStructure DateTime webservice');
//  s := ( dbm.gf.AMSCall as ARS).GetAllStructDtime(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to result.DocumentElement.ChildNodes.Count - 1 do
  begin
     n := result.DocumentElement.ChildNodes[i];
     s := n.NodeName;
     n1 := xml.DocumentElement.ChildNodes.FindNode(s);
     for j := 0 to n.ChildNodes.Count - 1 do
     begin
        s1 := n.ChildNodes[j].NodeName;
        n2 := n1.ChildNodes.FindNode(s1);
        if n2 = nil then continue;
        n.ChildNodes.Add(n2);
     end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteSetStructure(sname, name, caption , uname : string; xml:IXMLDocument) : string;
  var i : integer;
begin
  result := '';
  axml := nil;
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('caption').NodeValue := caption;
  xnode.AddChild('uname').NodeValue := uname;
  xml.savetoxml(s);
  xnode.AddChild('xmldata').NodeValue := s;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetStructure webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SetStructure(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

procedure TAxProvider.RemoteSetImage(sname, name , filename : string);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('filename').NodeValue := filename;
  axml.saveToXML(xmlstg);
//  s := ( dbm.gf.AESCall as ARS).SetImage(xmlStg,sname,name,filename) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.RemoteDeleteStrucutre(sname, name, caption: string);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('caption').NodeValue := caption;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DeleteStrucutre webservice');
//  s := (dbm.gf.AMSDataCall as ARS).DeleteStrucutre(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAxProvider.RemoteGetAllImages : IXMLDocument;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllImages webservice');
//  s := ( dbm.gf.AESCall as ARS).GetAllImages(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := LoadXMLData(s);
  axml := nil;
end;

function TAxProvider.RemoteExecSQL(SQLText, ParamValues, ParamTypes:String; WithData:Boolean):IXMLDocument;
var  wdata : String;
   i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sqltext').NodeValue := sqltext;
  xnode.AddChild('paramvalues').NodeValue := paramvalues;
  xnode.AddChild('paramtypes').NodeValue := paramTypes;
  if withdata = true then wdata := 'true' else wdata := 'false';
  xnode.AddChild('withdata').NodeValue := wdata;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling ExecSQL webservice');
  dbm.gf.DoDebug.Msg(xmlStg);
//  s := ( dbm.gf.AESCall as ARS).ExecSQL(xmlStg) ;
  msg := copy(s,1,pos('~',s)-1);
  delete(s,1,pos('~',s));
  if dbm.gf.DoDebug.Active then DebugMessage(msg);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := LoadXMLData(s);
  axml := nil;
end;

function TAxProvider.RemoteGetParam(SQLText:String):IXMLDocument;
var wdata : String;
    i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sqltext').NodeValue := sqltext;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetParam webservice');
//  s := ( dbm.gf.AESCall as ARS).GetParam(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := LoadXMLData(s);
  axml := nil;
end;

procedure TAxProvider.RemoteCreateField(TableName,FName,DType:String;FWidth,FDec:Integer);
var  fw,fd : String;
  i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('fname').NodeValue := fname;
  xnode.AddChild('dtype').NodeValue := dtype;
  fw := inttostr(fwidth);
  fd := inttostr(fdec);
  xnode.AddChild('fwidth').NodeValue := fw;
  xnode.AddChild('fdec').NodeValue := fd;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling CreateField webservice');
//  s := ( dbm.gf.AESCall as ARS).CreateField(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

Procedure TAxProvider.RemoteCreateTable(TableName:String;FName :String);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('fname').NodeValue := fname;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling Createtable webservice');
//  s := ( dbm.gf.AESCall as ARS).Createtable(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

Procedure TAxProvider.RemoteDeletefields(TableName,FieldName: String);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('fieldname').NodeValue := fieldname;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DeleteFields webservice');
//  s := ( dbm.gf.AESCall as ARS).DeleteFields(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

Procedure TAxProvider.RemoteDropTable(TableName:String);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DropTable webservice');
//  s := ( dbm.gf.AESCall as ARS).DropTable(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.RemoteAddConstraint(TableName,Constraints:String);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('constraints').NodeValue := constraints;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling AddConstraint webservice');
//  s := ( dbm.gf.AESCall as ARS).AddConstraint(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAxProvider.RemoteGetPrintForms(sname:String): IXMLDocument;
  var i : integer;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllPrintForms webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetAllPrintForms(xmlStg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  // Getting structures from AMS server
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllPrintForms webservice');
//  s := ( dbm.gf.AMSCall as ARS).GetAllPrintForms(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
  begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
    end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteGetTStructComp(name, cname: string): IXMLDocument;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('cname').NodeValue := cname;
  axml.saveToXML(xmlstg);
//  s := (dbm.gf.AMSCall as ARS).GetTStructComp(xmlStg) ;
  if copy(s,1,7) = '<error>' then
  begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
      delete(s,1,pos('>',s)+1);
      if dbm.gf.DoDebug.Active then
      begin
        showmessage(msg);
        with Tstringlist.Create do
        begin
          text := s;
          for i := 0 to count - 1 do
              dbm.gf.DoDebug.Msg(strings[i]);
          free;
        end;
      end else  Showmessage(s);
      exit ;
  end else result := LoadXMLData(s);
  axml := nil;
end;

function TAxProvider.RemoteEditField(TableName,FName,DType:String;FWidth,FDec:Integer):String;
var Fw,Fd  : String;
   i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('fname').NodeValue := fname;
  xnode.AddChild('dtype').NodeValue := dtype;
  fw := inttostr(fwidth);
  fd := inttostr(fdec);
  xnode.AddChild('fwidth').NodeValue := fw;
  xnode.AddChild('fdec').NodeValue := fd;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling EditField webservice');
//  s := ( dbm.gf.AESCall as ARS).EditField(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteReadMemo(fname, table, where : string) : string;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('fname').NodeValue := fname;
  xnode.AddChild('table').NodeValue := table;
  xnode.AddChild('where').NodeValue := where;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling ReadMemo webservice');
//  s := (dbm.gf.AESCall as ARS).ReadMemo(xmlstg, fname, table, where);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteReadBlob(fname, table, where : string) : string;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('fname').NodeValue := fname;
  xnode.AddChild('table').NodeValue := table;
  xnode.AddChild('where').NodeValue := where;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling ReadMemo webservice');
//  s := (dbm.gf.AESCall as ARS).ReadBlob(xmlstg, fname, table, where);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteSaveImage(fname, table, where ,filename ,ftype: string) : string;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('fname').NodeValue := fname;
  xnode.AddChild('table').NodeValue := table;
  xnode.AddChild('where').NodeValue := where;
  xnode.AddChild('filename').NodeValue := filename;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetImage webservice');
//  s := (dbm.gf.AESCall as ARS).SaveImage(xmlstg, fname, table, where , filename, ftype);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteSaveData(rdata : IXMLNode) : string;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if rdata <> nil then xnode.ChildNodes.Add(rdata.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SaveTrans webservice');
//  s := (dbm.gf.AESCall as ARS).SaveTrans(xmlstg);
  xmlstg := s;
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    delete(s,1,pos('>',s)+1);
    if dbm.gf.DoDebug.Active then
    begin
      showmessage(msg);
      with Tstringlist.Create do
      begin
        text := s;
        for i := 0 to count - 1 do
            dbm.gf.DoDebug.Msg(strings[i]);
        free;
      end;
    end else if copy(msg,1,1) <> '~' then  Showmessage(msg);
    result :=  xmlstg;
    exit ;
  end else
  begin
//    i := Length(s)-19;
//    delete(s,i,20);
    result :=  s;
  end;
  axml := nil;
end;

function TAxProvider.RemoteDeleteData(transid,recid,action : string;dnode:ixmlnode;detail:Boolean) : string;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.Attributes['transid'] := transid;
  xnode.Attributes['recordid'] := recid ;
  xnode.Attributes['action'] := action ;
  if detail then begin
    xnode.ChildNodes.Add(dnode.CloneNode(True));
  end;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DeleteData webservice');
//  s := (dbm.gf.AESCall as ARS).DeleteData(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    showmessage(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.GetPrintTemplate(sname,pname,fname:string) : string;
var  w,tdate,fdate,fn : string;
begin
  fn:=dbm.gf.startpath+'docs\'+fname ;
  if not fileexists(fn) then
  begin
     if dbm.gf.RemoteLogin then
     begin
        RemoteGetPrintTemplate(sname,pname,fname) ;
        exit;
     end;
    if not readlocal then
    begin
      w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(pname));
      dbm.ReadBlob('template','prints',w,fn);
    end
    else
    begin
      if trim(dbm.gf.structURL) <> '' then
         GetPrntTempFromStructURL(sname,pname,fname);
    end;
  end ;
  if not fileexists(fn) then
  begin
     w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(pname));
     dbm.ReadBlob('template','prints',w,fn);
  end ;
end;

procedure TAxProvider.RemoteGetPrintTemplate(sname,pname,fname:string) ;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').Nodevalue := sname;
  xnode.AddChild('pname').NodeValue := pname;
  xnode.AddChild('fname').NodeValue := fname;
  axml.saveToXML(xmlstg);
  s := '';
  dbm.gf.DoDebug.Msg('>>Calling GetPrintTemplate webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetPrintTemplate(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  if s <> '' then
     DownloadFile(s,dbm.gf.startpath+'docs\'+fname)
  else
    GetPrntTempFromStructURL(sname,pname,fname);
  axml := nil;
end;

procedure TAXProvider.GetPrntTempFromStructURL(sname,pname,fname:string) ;
  var i : integer;
begin
    axml := LoadXMLData('<root></root>') ;
    xnode :=axml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    xnode.attributes['sessionid'] := dbm.gf.sessionid;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('sname').Nodevalue := sname;
    xnode.AddChild('pname').NodeValue := pname;
    xnode.AddChild('fname').NodeValue := fname;
    axml.saveToXML(xmlstg);
    s := '';
    dbm.gf.DoDebug.Msg('>>Calling GetPrintTemplate webservice');
//    s := (dbm.gf.AMSCall as ARS).GetPrintTemplate(xmlstg);
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
      raise exception.Create(msg);
    end;
    DownloadFile(s,dbm.gf.startpath+'docs\'+fname);
    axml := nil;
end;

procedure TAxProvider.DownLoadFile(filename,tempfile:string) ;
var tf : File;
    buf :array[1..ArraySize] of char;
    sname : string ;
    ByteArray : TByteDynArray;
begin
  sname := tempfile ;
  dbm.gf.DoDebug.Msg('>>Calling DownloadFile webservice');
//  ByteArray := (dbm.gf.AMSCall as ARS).DownloadFile(filename);
  ByteArrayToFile( ByteArray, sname );
end;

procedure TAxProvider.ByteArrayToFIle( const ByteArray : TByteDynArray;
                            const FileName : string );
var Count : integer;
    F : FIle of Byte;
    pTemp : Pointer;
begin
  AssignFile( F, FileName );
  Rewrite(F);
  try
    Count := Length( ByteArray );
    pTemp := @ByteArray[0];
    BlockWrite(F, pTemp^, Count );
    CloseFile( F );
  except on e:Exception do
    begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\ByteArrayToFIle - '+e.Message);
      CloseFile( F );
    end;
  end;
end;

procedure TAxProvider.SetPrintTemplate(name, sname,printdoctype :string;PropsXML : IXMLDocument);
var
  w, s:string;
  x1  : Txds;
  docfilename : string;
  nm,fn : string;
  p : Integer;
begin
//  nm := lowercase(findandreplace(name,' ','_'))+lowercase(findandreplace(sname,' ','_'))+lowercase(printdoctype);
  nm := name;
  if bImportPrintDoc then
  begin
    fn := PropsXML.DocumentElement.Attributes['filename'];
    docfilename := fn;
    fn := ExtractFileName(fn);
    p := pos('$',fn);
    if p=0 then exit;
    fn := copy(fn,p+1,length(fn)-(p+4));
    PropsXML.DocumentElement.Attributes['filename']:=fn;
    setStructure('printprops',nm,name,PropsXML);
    if dbm.gf.RemoteLogin then begin
      RemoteSetPrintTemplate(nm, sname,printdoctype,docfilename,nm);
      exit;
    end;
  end
  else
  begin
    setStructure('printprops',nm,name,PropsXML);
    docfilename := dbm.gf.startpath+'docs\'+ ExtractFileName(PropsXML.DocumentElement.Attributes['filename']);
    if dbm.gf.RemoteLogin then begin
      RemoteSetPrintTemplate(nm, sname,printdoctype,docfilename,nm);
      exit;
    end;
  end;
  w:=dbm.gf.sqllower+'(name)='+ Quotedstr(lowercase(nm));
  x1 := dbm.GetXDS(nil);
  x1.sqltext := 'delete from prints where ' + w;
  x1.execsql;
  x1.Submit('name', nm, 'c');
  x1.Submit('caption',name,'c');
  x1.Submit('sname',sname,'c');
  x1.Submit('printdoctype',uppercase(printdoctype),'c');
  x1.Submit('blobno','1','n');
  x1.AddOrEdit('Prints', w);
  dbm.WriteBlob('template', 'Prints', w, docfilename);
  x1.free;
end;

procedure TAxProvider.RemoteSetPrintTemplate(name, sname,printdoctype,filename,nm :string );
  var i : integer;
begin
  xmlstg := '';
  s := UploadFile('printprops',filename);
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := nm;
  xnode.AddChild('filename').NodeValue := s;
  xnode.AddChild('caption').NodeValue := name;
  xnode.AddChild('doctype').NodeValue := printdoctype;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetPrintTemplate webservice');
//  s := (dbm.gf.AMSCall as ARS).SetPrintTemplate(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAXProvider.GetTreeViews(TreeName : string) : IXMLDocument;
  var i : integer;
begin
  forcds.close;
  result := LoadXMLData('<root></root>');
  forcds.buffered := True;
  forcds.CDS.CommandText := 'select viewname viewname from axptreeviews where '+dbm.gf.sqllower+'(treename) = '+ quotedstr(lowercase(treename))+' order by 1';
  forcds.open;
  i := 1;
  if not forcds.cds.isempty then begin
    while not forcds.cds.eof do begin
      result.DocumentElement.AddChild('row'+inttostr(i)).NodeValue := forcds.cds.fieldbyname('viewname').AsString;
      forcds.cds.next;
      i := i+1;
    end;
  end;
end;

Procedure TAxprovider.SaveTreeViews(name,viewname,treename,appon,showasbutton,imgname:string);
var
  w : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteSaveTreeViews(name,viewname,treename,appon,showasbutton,imgname);
    exit;
  end;
  w := dbm.gf.sqllower+'(vname)='+quotedstr(lowercase(name));
  x.Submit('vname',name,'c');
  x.Submit('viewname',viewname,'c');
  x.Submit('treename',treename,'c');
  x.Submit('applyon',appon,'c');
  x.Submit('type',showasbutton,'c');
  x.Submit('img',imgname,'c');
  x.AddOrEdit('axptreeviews',w);
end;

procedure TAxProvider.RemoteSaveTreeViews(name,viewname,treename,appon,showasbutton,imgname:string);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('viewname').NodeValue := viewname;
  xnode.AddChild('treename').NodeValue := treename;
  xnode.AddChild('appon').NodeValue := appon;
  xnode.AddChild('showasbutton').NodeValue := showasbutton;
  xnode.AddChild('imgname').NodeValue := imgname;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetTreeViews webservice');
//  s := (dbm.gf.AESCall as ARS).SetTreeViews(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
   axml := Nil;
end;

procedure TAxprovider.SetTreeTable(Tablename,name,transid,transdesc,treeorder,treelevel,transidname,parent,gori,ptable,pfield,recordid:string);
var
  w : string;
begin
  if dbm.gf.RemoteLogin then
  begin
    RemoteSetTreeTable(Tablename,name,transid,transdesc,treeorder,treelevel,transidname,parent,gori,ptable,pfield,recordid);
    exit;
  end;
  w := dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name));
  x.Submit('name',name,'c');
  x.submit('transid',transid,'c');
  x.submit('transdesc',transdesc,'c');
  x.Submit('treeorder',treeorder,'c');
  x.Submit('treelevel',treelevel,'c');
  x.Submit('transidname',transidname,'c');
  x.Submit('parent',parent,'c');
  x.Submit('gori',gori,'c');
  x.Submit('ptable',ptable,'c');
  x.Submit('pfield',pfield,'c');
  x.Submit('recordid',recordid,'c');
  x.AddOrEdit(TABLENAME,w);
end;

procedure TAxProvider.RemoteSetTreeTable(Tablename,name,transid,transdesc,treeorder,treelevel,transidname,parent,gori,ptable,pfield,recordid:string);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := Tablename;
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('transid').NodeValue := transid;
  xnode.AddChild('transdesc').NodeValue := transdesc;
  xnode.AddChild('treeorder').NodeValue := treeorder;
  xnode.AddChild('treelevel').NodeValue := treelevel;
  xnode.AddChild('transidname').NodeValue := transidname;
  xnode.AddChild('parent').NodeValue := parent;
  xnode.AddChild('gori').NodeValue := gori;
  xnode.AddChild('ptable').NodeValue := ptable;
  xnode.AddChild('pfield').NodeValue := pfield;
  xnode.AddChild('recordid').NodeValue := recordid;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetTreeTable webservice');
//  s := (dbm.gf.AESCall as ARS).SetTreeTable(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
end;


procedure TAxprovider.DeletePrintForm(sname,name:string);
  var w : string;
begin
  DeleteStrucutre(sname,name,'');
  DeleteStrucutre('prints',name,'');
end;

procedure TAxProvider.SaveImage(sname,ftype: string;recid:Extended;Img:Timage);
  var w:string;
begin
  if dbm.gf.RemoteLogin then
  begin
    s:=dbm.gf.startpath+'temp\img'+dbm.gf.getnumber + '.' + ftype;
    img.Picture.SaveToFile(s);
    s := UploadFile('temp',s);
    RemoteSaveImage('img',sname, floattostr(recid) ,s,ftype);
    exit;
  end;
  w:='recordid='+floattostr(recid);
  q.close;
  q.sqltext:='delete from '+sname+' where '+w;
  q.execsql;
  x.Submit('recordid', floattostr(recid), 'n');
  x.Submit('blobno', '1', 'n');
  x.Submit('ftype', ftype, 'c');
  x.AddOrEdit(sname, w);
  x.Post;
  s:=dbm.gf.startpath+'temp\img'+dbm.gf.getnumber;
  img.Picture.SaveToFile(s);
  dbm.WriteBlob('img', sname, w, s);
  deletefile(s);
end;

function TAxProvider.SaveImage(sname , imgName: String; recid: Extended) : boolean;
begin
end;

procedure TAxProvider.LoadImage(sname: string;recid:Extended;Img:Timage);
var w : String;
begin
  forcds.Close;
  forcds.buffered := True ;
  w:='recordid='+floattostr(recid);
  forcds.CDS.CommandText:='select ftype from '+sname+' where '+w;
  forcds.open;
  if not forcds.CDS.isempty then
  begin
    GetImgExtn := forcds.CDS.fieldbyname('ftype').AsString;
    if dbm.gf.RemoteLogin then
    begin
      w:='recordid='+floattostr(recid);
      s := RemoteReadBlob('img',sname , w);
      DownLoadFile('axpert\'+dbm.gf.sessionid+'\'+s,dbm.gf.startpath+'temp\'+s);
      s := dbm.gf.startpath+'temp\'+s ;
      if s <> '' then
      if fileexists(s) then begin
        w := s + '.'+GetImgExtn;
        renamefile(s,w);
        s := s + '.'+GetImgExtn;
//        s:=dbm.gf.startpath+'temp\'+s;
        img.Picture.LoadFromFile(s);
      end;
    end
    else begin
      s:=dbm.gf.startpath+'temp\img'+dbm.gf.getnumber+'.'+GetImgExtn;
      dbm.ReadBlob('img', sname, w, s);
      if fileexists(s) then begin
        img.Picture.LoadFromFile(s);
      end;
    end;
  end;
  if fileexists(s) then deletefile(s);
  x.close;
end;

procedure TAxProvider.LoadImage(AxpImgPath,recid:String;Img:Timage);
var fpath,tfile : String;
    frec : TSearchRec;
begin
  fpath := AxpImgPath+'\'+recid+'.*';
  if FindFirst(fpath, faAnyFile, fRec) = 0 then
  repeat
    tfile:= AxpImgPath+'\'+fRec.Name;
    GetImgExtn := ExtractFileExt(frec.Name);
    Delete(GetImgExtn,1,1);
    Img.Picture.LoadFromFile(tfile);
  until FindNext(fRec) <> 0;
  FindClose(fRec);
end;

procedure TAxProvider.LoadImage(FileName:String;Img:Timage);
var fpath,tfile : String;
    frec : TSearchRec;
begin
  fpath := FileName+'.*';
  if FindFirst(fpath, faAnyFile, fRec) = 0 then
  repeat
    tfile:= fRec.Name;
    GetImgExtn := ExtractFileExt(frec.Name);
    Img.Picture.LoadFromFile(FileName+GetImgExtn);
    Delete(GetImgExtn,1,1);
  until FindNext(fRec) <> 0;
  FindClose(fRec);
end;

function TAxprovider.DownLoad(filename,tempfile:string):string;
var tf : File;
    buf :array[1..ArraySize] of char;
    i:integer;
    s , header, sname : string ;
begin
  i:=0;
  if pos('.',tempfile) > 0 then
     sname :=  dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+ tempfile
  else
     sname := dbm.gf.startpath+'temp\'+ extractfilename(tempfile) ;
  assignfile(tf, sname);
  rewrite(tf);
  dbm.gf.DoDebug.Msg('>>Calling DownLoad webservice');
  while true do begin
//    s := (dbm.gf.AESCall as ARS).DownLoad(filename, i);
    header:=copy(s,1,6);delete(s,1,6);
    reset(tf,1);
    for i:=1 to length(s) do buf[i]:=s[i];
    blockwrite(tf, buf, length(s), i);
    close(tf)   ;
    if header[1]='*' then break;
    i:=i+length(s);
  end;
  result := sname;
end;

function TAxProvider.GetBOMXML : IXMLDocument;
var  fn,w : string;
     ts : TStringList;
Begin
  result := LoadXMLData('<root></root>');
  x.SetCDSName('Axprovider_'+'axprops_GetBOMXML');
  x.sqltext := 'select * from axprops where '+dbm.gf.sqllower+'(name)='+lowercase(quotedstr('bom'));
  x.open;
  if not x.isempty then begin
    w := dbm.gf.sqllower+'(name)='+lowercase(quotedstr('bom'));
    fn := dbm.gf.startpath+'temp\bom.xml';
    dbm.ReadMemo('props','axprops',w,fn);
    ts := TStringlist.Create;
    ts.LoadFromFile(fn);
    result := LoadXmlData(ts.Text);
  end;
End;

function  TAxProvider.UploadFile(sname , filename : string) : string;
  var byteArray : TByteDynArray;
  fn : string ;
  i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['session'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  fn := ExtractFileName(filename);
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('filename').NodeValue := fn;
  axml.saveToXML(xmlstg);
  byteArray := FIleToByteArray(fileName);
  dbm.gf.DoDebug.Msg('>>Calling UploadFile webservice');
//  s := (dbm.gf.AMSCall as ARS).UploadFile(xmlstg,byteArray);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
end;

function TAxProvider.FIleToByteArray(FileName : string ) : TByteDynArray;
const BLOCK_SIZE=1024;
var BytesRead, BytesToWrite, Count : integer;
    F : FIle of Byte;
    pTemp : Pointer;
begin
  AssignFile( F, FileName );
  Reset(F);
  try
    Count := FileSize( F );
    SetLength(Result, Count );
    pTemp := @Result[0];
    BytesRead := BLOCK_SIZE;
    while (BytesRead = BLOCK_SIZE ) do
    begin
      BytesToWrite := Min(Count, BLOCK_SIZE);
      BlockRead(F, pTemp^, BytesToWrite , BytesRead );
      pTemp := Pointer(LongInt(pTemp) + BLOCK_SIZE);
      Count := Count-BytesRead;
    end;
  CloseFile( F );
  except on e:Exception do
    begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\FIleToByteArray - '+e.Message);
      CloseFile( F );
    end;
  end;
end;

procedure TAxProvider.SetAttachments(sname,recordid,filename:String);
var
  w, s:string;
  x1  : Txds;
  docfilename : string;
  nm,fn,recid : string;
begin
  docfilename :=  filename;
  fn := ExtractFileName(filename);
  recid := Recordid+'-'+fn;
  if dbm.gf.RemoteLogin then begin
    RemoteSetAttachments(sname,recordid,filename,recid,fn);
    exit;
  end;
  w:='recid ='+ Quotedstr(recid);
  x1 := dbm.GetXDS(nil);
  x1.Submit('recordid', recordid, 'c');
  x1.Submit('recid', recid, 'c');
  x1.Submit('filename',fn,'c');
  x1.Submit('blobno','1','n');
  x1.AddOrEdit(sname, w);
  dbm.WriteBlob('template', sname, w, docfilename);
  x1.free;
end;

procedure TAxProvider.SetAttachments(sname,sfile,tfile:String;recordid:Extended;HugeBlob : Boolean = false);
var
  w, s:string;
  x1  : Txds;
  docfilename : string;
  nm,fn,recid : string;
  cpos : integer;
begin
  recid := Trim(FloatToStr(recordid))+'-'+tfile;
  if dbm.gf.RemoteLogin then begin
//    RemoteSetAttachments(sname,recordid,filename,recid,fn);
    exit;
  end;
  w:='recid ='+ Quotedstr(recid);
  x1 := dbm.GetXDS(nil);
  x1.Submit('recordid', Floattostr(recordid), 'c');
  x1.Submit('recid', recid, 'c');
  x1.Submit('filename',tfile,'c');
  x1.Submit('blobno','1','n');
  x1.AddOrEdit(sname, w);
  dbm.WriteBlob('template', sname, w, sfile);
  x1.free;
end;

procedure TAxProvider.RemoteSetAttachments(sname,recordid,filename,recid,nm :string );
  var i : integer;
begin
  xmlstg := '';
  s := UploadFile('printprops',filename);
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := nm;
  xnode.AddChild('filename').NodeValue := s;
  xnode.AddChild('recordid').NodeValue := recordid;
  xnode.AddChild('recid').NodeValue := recid;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetAttachments webservice');
//  s := (dbm.gf.AESCall as ARS).SetAttachments(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAxProvider.ViewAttachment(sname,recordid,filename:string) : string;
var  w,tdate,fdate,fn : string;
  recid : string;
begin
  recid := Recordid + '-'+lowercase(filename);
  if dbm.gf.RemoteLogin then
  begin
    result := RemoteViewAttachment(sname,recid,filename) ;
    exit;
  end;
//  if readlocal then
//  begin
    fn := dbm.gf.startpath +'temp\'+filename;
//    w:=dbm.gf.sqllower+'(recid)='+QuotedStr(recid);              // changed 
    w:='Recordid='+QuotedStr(Recordid)+'and '+dbm.gf.sqllower+'(filename)='+QuotedStr(lowercase(filename));
    dbm.ReadBlob('template',sname,w,fn);
    result := fn;
//  end;
end;

function TAxProvider.RemoteViewAttachment(sname,pname,fname:string) : string ;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').Nodevalue := sname;
  xnode.AddChild('pname').NodeValue := pname;
  xnode.AddChild('fname').NodeValue := fname;
  axml.saveToXML(xmlstg);
  s := '';
  dbm.gf.DoDebug.Msg('>>Calling ViewAttachment webservice');
//  s := (dbm.gf.AESCall as ARS).ViewAttachment(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  if s <> '' then
     DownloadFile(s,dbm.gf.startpath+'temp\'+fname);
  result := dbm.gf.startpath+'temp\'+fname ;
  axml := nil;
end;

function TAxProvider.RemoteLoadData(transid,recid:string) : string ;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.Attributes['transid'] := transid;
  xnode.Attributes['recordid'] := recid ;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling LoadData webservice');
//  s := (dbm.gf.AESCall as ARS).LoadData(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.GetOneRecord(SQLText, ParamValues, ParamTypes:String;UniqueVal : String = ''):IXMLDocument;
var i:integer;
    s:string;
    n:ixmlnode;
    dt : TFieldType;
    CDSName : String;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteGetOneRecord(SQLText,ParamValues,ParamTypes);
    exit;
  end;
  result:=loadxmldata('<root></root>');
  q.sqltext:=sqltext;
  if (dbm.gf.AxpLocalDB) and  (Not dbm.gf.IsLDSDirectSave) then
    CDSName := 'AxProvider_GetOneRecord_'+UniqueVal
  else
    CDSName := 'nolds_AxProvider_GetOneRecord_'+UniqueVal;
  q.SetCDSName(CDSName);
  i:=1;
  while true do begin
    s:=dbm.gf.getnthstring(paramvalues,i);
    if s='' then break;
    q.AssignParam(i-1, s, paramtypes[i]);
    inc(i);
  end;
  if lowercase(copy(sqltext,1,7)) <> 'select ' then
    q.execsql
  else begin
    q.open;
    xnode:=result.DocumentElement;
    while not q.eof do begin
      n:=xnode.AddChild('row');
      for i:=0 to q.Fields.Count-1 do
        n.AddChild(q.fields[i].FieldName).NodeValue:=q.Fields[i].AsString;
      q.next;
    end;
  end;
end;

function TAxProvider.RemoteGetOneRecord(SQLText, ParamValues, ParamTypes:String):IXMLDocument;
var  wdata : String;
     i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sqltext').NodeValue := sqltext;
  xnode.AddChild('paramvalues').NodeValue := paramvalues;
  xnode.AddChild('paramtypes').NodeValue := paramTypes;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetOneRecord webservice');
  dbm.gf.DoDebug.Msg(xmlStg);
//  s := ( dbm.gf.AESCall as ARS).GetOneRecord(xmlStg) ;
  msg := copy(s,1,pos('~',s)-1);
  delete(s,1,pos('~',s));
  if dbm.gf.DoDebug.Active then DebugMessage(msg);
  DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := LoadXMLData(s);
  axml := nil;
end;
function TAxProvider.GetPDFs(stransid:String): IXMLDocument;
begin
  if dbm.gf.RemoteLogin then begin
    Result := RemoteGetPDfs(stransid);
    exit;
  end;
  xml := nil;
  result:=LoadXMLData('<root></root>');
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    xnode.attributes['sessionid'] := dbm.gf.sessionid;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('stransid').NodeValue := stransid ;
    xml.saveToXML(xmlstg);
//    s := (dbm.gf.AMSCall as ARS).GetPDFs(xmlstg) ;
    result := LoadXMLData(s);
  end;
  stransid := lowercase(stransid);
  x.SetCDSName('Axprovider_'+stransid+'_pdfprops_'+stransid);
  x.sqltext:='select distinct caption,name from pdfprops where '+dbm.gf.sqllower+'(transid) = ' + quotedstr(stransid) + 'order by caption';
  x.open;
  while not x.eof do begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(x.fieldbyname('name').AsString) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    end;
    x.next;
  end;
  x.close;
end;

function TAxProvider.RemoteServerDateTime() : String;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling ServerDateTime webservice');
//  s := (dbm.gf.AMSCall as ARS).ServerDateTime(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

procedure TAxProvider.SetRoles(sname,filename,rolename:String);
var
  w,s,t:string;
  x1  : Txds;
  nm,fn,recid : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteSetRoles(sname,filename,rolename);
    exit;
  end;
  w:='rolename ='+ Quotedstr(rolename);
  x1 := dbm.GetXDS(nil);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  x1.Submit('rolename', rolename, 'c');
  x1.Submit('blobno', '1', 'n');
  x1.Submit('updatedon',t,'c');
  x1.AddOrEdit(sname, w);
  if filename <> '' then
    dbm.WriteMemo('roleaccess', sname, w, filename);
  x1.free;
end;

procedure TAxProvider.RemoteSetRoles(sname,filename,rolename :string );
 var i : integer;
begin
  xmlstg := '';
  if filename <> '' then
    s := UploadFile('roles',filename)
  else
    s := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('name').NodeValue := rolename;
  xnode.AddChild('filename').NodeValue := s;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetRoles webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SetRoles(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.DebugMessage(s : string);
  var msg : string;
      i : integer ;
begin
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
      delete(s,1,pos('>',s)+1);
    end;
    with Tstringlist.Create do
    begin
      text := s;
      for i := 0 to count - 1 do
          dbm.gf.DoDebug.Msg(strings[i]);
      free;
    end;
end;

procedure TAxProvider.RemoteSetUserGroups(grpno,grpName,roles:String);
 var i : integer;
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('sname').NodeValue := 'axusergroups';
  xnode.AddChild('grpno').NodeValue := grpno;
  xnode.AddChild('grpname').NodeValue := grpname;
  xnode.AddChild('roles').NodeValue := roles;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetUserGroups webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SetUserGroups(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.RemoteSetUsers(n:ixmlnode);
 var i : integer;
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetUsers webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SetUsers(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAxProvider.RemoteGetPDFs(stransid:String): IXMLDocument;
  var i : integer;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('stransid').NodeValue := stransid;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetPDfs webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetPDFs(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  // Getting PDFs structures from AMS server
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('stransid').NodeValue := stransid;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetPDFs webservice');
//  s := ( dbm.gf.AMSCall as ARS).GetPDFs(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
  begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
    if xnode = nil then
    begin
      result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
    end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteCsvImport(filename:String;n :ixmlnode) : string ;
 var i : integer;
begin
  if (n = nil) or (filename = '') then
  begin
     showmessage('Parameters for CSV Import not defined properly...');
     exit;
  end;
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['filename'] := filename;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling CsvImport webservice');
//  s := (dbm.gf.AMSDataCall as ARS).CsvImport(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteExcelImport(filename:String;n :ixmlnode) : string ;
 var i : integer;
begin
  if (n = nil) or (filename = '') then
  begin
     showmessage('Parameters for Excel Import not defined properly...');
     exit;
  end;
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['filename'] := filename;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling ExcelImport webservice');
//  s := (dbm.gf.AMSDataCall as ARS).ExcelImport(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteDbfImport(filename:String;n :ixmlnode) : string ;
 var i : integer;
begin
  if (n = nil) or (filename = '') then
  begin
     showmessage('Parameters for Dbf Import not defined properly...');
     exit;
  end;
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['filename'] := filename;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DbfImport webservice');
//  s := (dbm.gf.AMSDataCall as ARS).DbfImport(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result := s;
  axml := nil;
end;

function TAxProvider.RemoteUserDefinedTask(n:ixmlnode) : string;
 var i : integer;
     xmlstg,s,msg : String;
     axml : IXMLDocument;
     xnode,x,x1 : IXMLNode;
begin
  if (n = nil) then
  begin
     showmessage('Parameters for RemoteUserDefinedTask not defined properly...');
     exit;
  end;
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.ChildNodes[0].CloneNode(True));
  if n <> nil then xnode.ChildNodes.Add(n.ChildNodes[1].CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling EvalUserDefinedTask webservice');
//  s := (dbm.gf.AMSDataCall as ARS).EvalUserDefinedTask(xmlstg);
  msg := copy(s,1,pos('~',s)-1);
  delete(s,1,pos('~',s));
  if dbm.gf.DoDebug.Active then DebugMessage(msg);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    showmessage(msg);
    result := '';
    exit;
  end;
  result :=  s;
  axml := nil; xnode := nil;
end;


function TAxProvider.RemotePostIview(n:ixmlnode) : string;
 var i : integer;
     xmlstg,s,msg : String;
     axml : IXMLDocument;
     xnode,x,x1 : IXMLNode;
begin
  if (n = nil) then
  begin
     showmessage('Parameters for RemotePostIview not defined properly...');
     exit;
  end;
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.ChildNodes[0].CloneNode(True));
  if n <> nil then xnode.ChildNodes.Add(n.ChildNodes[1].CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling EvalUserDefinedTask webservice');
//  s := (dbm.gf.AMSDataCall as ARS).PostFromIview(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end
  else result := s;
  axml := nil; xnode := nil;
end;

function TAxprovider.CreatePDF(transid,formname,filename,temppth : string;recid : extended;RecidList : TStringlist) : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteCreatePDF(transid,formname,filename,temppth ,recid,RecidList );
    Exit;
  end;
end;

function TAxprovider.RemoteCreatePDF(transid,formname,filename,temppth : string;recid : extended;RecidList : TStringlist) : string;
var
  s,fn,fn1,fn2 : string;
  reclistnode : IXMLNode;
  i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('transid').NodeValue := transid;
  xnode.AddChild('formname').NodeValue := formname;
  xnode.AddChild('filename').Nodevalue := filename;
  xnode.AddChild('recordid').NodeValue := floattostr(recid);
  if Assigned(Recidlist) and (RecidList.Count>0) then
  begin
    reclistnode := xnode.AddChild('recidlist');
    for i := 0 to Recidlist.Count-1 do
    begin
      reclistnode.AddChild('l'+inttostr(i+1)).nodevalue := RecidList[i];
    end;
  end;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling CreatePDF webservice');
//  s := ( dbm.gf.AESCall as ARS).CreatePDF(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  if s <>'' then begin
    fn := s;
    while fn <> '' do begin
      fn1 := copy(s,1,pos(',',s)-1);
      DownLoadFile(fn1,temppth+Extractfilename(fn1));
      fn := copy(fn,pos(',',fn)+1,length(fn));
    end;

  end;
  result := s;
  axml := nil;
end;

procedure TAxProvider.remoteupdateversion  ;
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['fileverno'] := dbm.gf.fileverno;
  xnode.attributes['appverno'] := dbm.gf.appverno;
  xnode.attributes['exeverno'] := dbm.gf.exeverno;
  xnode.attributes['role'] := dbm.gf.userroles;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling Update Version webservice');
//  s := (dbm.gf.AMSDataCall as ARS).updateversion(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxprovider.MoveNode(Treeid,Parent,NewParent,Recordid : Extended;Name,gori,transid,ptable,pfield,treename:string);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteMoveNode(Treeid,Parent,NewParent,Recordid,Name,gori,transid,ptable,pfield,treename);
    exit;
  end;
end;

function TAxprovider.RemoteMoveNode(Treeid,Parent,NewParent,Recordid : Extended;Name,gori,transid,ptable,pfield,treename:string):string;
var
  s: string;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('treeid').NodeValue := floattostr(treeid);
  xnode.AddChild('parent').NodeValue := floattostr(parent);
  xnode.AddChild('newparent').NodeValue := floattostr(newparent);
  xnode.AddChild('recordid').Nodevalue := floattostr(recordid);
  xnode.AddChild('name').NodeValue := name;
  xnode.AddChild('gori').NodeValue := gori;
  xnode.AddChild('transid').NodeValue := transid;
  xnode.AddChild('ptable').NodeValue := ptable;
  xnode.AddChild('pfield').NodeValue := pfield;
  xnode.AddChild('treename').NodeValue := treename;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling Move Node webservice');
//  s := ( dbm.gf.AESCall as ARS).MoveNode(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    showmessage(msg);
  end;
end;

procedure TAxprovider.SortNode(nm1,nm2:string;Treeid,parent : extended;pname,treename :string);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteSortNode(nm1,nm2,Treeid,parent,pname,treename);
    Exit;
  end;
end;

function TAxprovider.RemoteSortNode(nm1,nm2:string;Treeid,parent : extended;pname,treename :string):string;
var
  s,xmlstg: string;
  axml : IXMLDocument;
  xnode : IXMLNode;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('nm1').NodeValue := nm1;
  xnode.AddChild('nm2').NodeValue := nm2;
  xnode.AddChild('treeid').NodeValue := floattostr(treeid);
  xnode.AddChild('parent').NodeValue := floattostr(parent);
  xnode.AddChild('pname').NodeValue := pname;
  xnode.AddChild('treename').NodeValue := treename;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SortNode webservice');
//  s := ( dbm.gf.AESCall as ARS).SortNode(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    showmessage(msg);
  end;
end;

procedure TAxProvider.RemoteUpdatePageOrder(n : ixmlnode)  ;
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['fileverno'] := dbm.gf.fileverno;
  xnode.attributes['appverno'] := dbm.gf.appverno;
  xnode.attributes['exeverno'] := dbm.gf.exeverno;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling Update Version webservice');
//  s := (dbm.gf.AMSDataCall as ARS).UpdatePageOrder(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.DropConstraint(TableName,Constraints:String);
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDropConstraint(TableName,Constraints);
    exit;
  end;
  Try
    q.close;
    if dbm.Connection.DbType = 'access' then
      q.SQlText := 'Alter table ['+ UpperCase(TableName) + '] drop constraint ' + Constraints
    else if dbm.Connection.DbType = 'ms sql' then
      q.sqltext := 'Alter table ['+ UpperCase(TableName) + '] drop Constraint ' + Constraints
    else if dbm.Connection.DbType = 'mysql' then begin
      if copy(constraints,1,1)='P' then
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop primary key '
      else
        q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop foreign key ' + Constraints;
    end
    else
      q.sqltext := 'Alter table '+ UpperCase(TableName) + ' drop Constraint ' + Constraints;
    q.ExecSQL;
  Except on e:Exception do
    begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\DropConstraint - '+e.Message);
    end;
  End;
end;

procedure TAxProvider.RemoteSaveSequence(n : ixmlnode;transid,fldname:String);
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['transid'] := transid;
  xnode.attributes['combotext'] := fldname;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if n <> nil then xnode.ChildNodes.Add(n.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SaveSequence webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SaveSequence(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

procedure TAxProvider.RemoteSetPrefix(transid,fldname,prefix:String);
begin
  xmlstg := '';
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  xnode.attributes['transid'] := transid;
  xnode.attributes['fieldname'] := fldname;
  xnode.attributes['prefix'] := prefix;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SetPrefix webservice');
//  s := (dbm.gf.AMSDataCall as ARS).SetPrefix(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;


procedure TAxProvider.RemoteDropConstraint(TableName,Constraints:String);
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tablename').NodeValue := tablename;
  xnode.AddChild('constraints').NodeValue := constraints;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling DropConstraint webservice');
//  s := ( dbm.gf.AESCall as ARS).DropConstraint(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;
function TAxProvider.remoteSetlanguage(XML : string):string;
var
  s,XM : string;
begin
  axml := loadxmldata(XML);
  if dbm.gf.RemoteLogin then begin
    xnode :=axml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    xnode.attributes['sessionid'] := dbm.gf.sessionid;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
//    s := (dbm.gf.AMSDataCall as ARS).SetLanguage(AXML.XML.text);
    Exit;
  end;
end;

function TAxProvider.SaveRoles(XML : string):string;
var
  XM : string;
begin
  axml := loadxmldata(XML);
  if dbm.gf.RemoteLogin then begin
    xnode :=axml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    xnode.attributes['sessionid'] := dbm.gf.sessionid;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
//    result := (dbm.gf.AMSDataCall as ARS).SaveRoles(AXML.XML.Text);
    Exit;
  end;
end;

procedure TAxProvider.SetMailVars(n: ixmlnode);
begin

end;

Procedure TAxprovider.SavePDFImages(imgname,pdfname,filename : string);
  var w,s : string;
Begin
  if not dbm.gf.RemoteLogin then
  Begin
    w := dbm.gf.sqllower+'(pdfname)='+lowercase(quotedstr(pdfname));
    w := w+' and '+dbm.gf.sqllower+'(name)='+lowercase(quotedstr(imgname));
    Q.close;
    Q.Submit('name',imgname,'c');
    Q.Submit('pdfname',pdfname,'c');
    Q.AddOrEdit('pdfimage',w);
    dbm.WriteBlob('img','pdfimage',w,filename);
    deletefile(filename);
  End Else
  Begin
    s := UploadFile('temp',filename);
    RemoteSavePDFImage(imgname,pdfname,s);
  End;
End;

procedure TAxProvider.RemoteSavePDFImage(imgname,pdfname,filename : string) ;
  var i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('imgname').NodeValue := imgname;
  xnode.AddChild('pdfname').NodeValue := pdfname;
  xnode.AddChild('filename').NodeValue := filename;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SavePDFImage webservice');
  dbm.gf.DoDebug.Msg(xmlstg);
//  s := (dbm.gf.AESCall as ARS).SavePDFImage(xmlstg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    dbm.gf.DoDebug.Msg(msg);
  end;
  axml := nil;
end;

function TAxProvider.B4SaveCheckExisting(tname,sname:String): IXMLDocument;
  var i : integer;
begin
  if dbm.gf.RemoteLogin then begin
    result := RemoteB4SaveCheckExisting(tname,sname);
    exit;
  end;
  xml := nil;
  result:=LoadXMLData('<root></root>');
  x.sqltext:='select name,caption from '+tname+' where blobno=1 and ' + dbm.gf.sqllower + '(name) = ' + quotedstr(lowercase(sname)) + ' order by ' + dbm.gf.sqllower + '(caption)'  ;
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('sname').NodeValue := sname ;
    xml.saveToXML(xmlstg);
    dbm.gf.DoDebug.Msg('>>Calling GetallStructures webservice');
//    s := (dbm.gf.AMSCall as ARS).GetAllStructures(xmlstg) ;
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
     raise exception.Create(msg);
    end;
    xml := LoadXMLData(s);
    for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
    begin
      xnode := nil;
      xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
      if xnode = nil then
      begin
         result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
      end;
    end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteB4SaveCheckExisting(tname,sname:String): IXMLDocument;
  var   i : integer;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tname').NodeValue := tname;
  xnode.AddChild('sname').NodeValue := sname;
  xnode.AddChild('role').NodeValue := dbm.gf.userroles;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllStructure webservice');
//  s := (dbm.gf.AMSDataCall as ARS).B4SaveCheckExisting(xmlStg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  // Getting structures from AMS server
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('tname').NodeValue := tname;
  xnode.AddChild('sname').NodeValue := sname;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling B4SaveCheckExisting webservice');
//  s := ( dbm.gf.AMSCall as ARS).B4SaveCheckExisting(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
  begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
    end;
  end;
  xml := nil;
end;

function TAxProvider.GetPageOrderXMLForPageDesign() : IXMLDocument;
  var n : IXMLNode;
      i : integer;
      pgs : TStringList;
      cat : string;
begin
  pgs := nil;
  if dbm.gf.pageaccess <> '' then
  begin
    pgs := TStringList.Create;
    if pos(',',dbm.gf.pageaccess) > 0 then
    begin
      i := 1;
      while true do
      begin
        s := dbm.gf.GetnthString(dbm.gf.pageaccess,i);
        if s = '' then break;
        pgs.Add(s);
        i := i + 1;
      end;
    end
    else pgs.Add(dbm.gf.pageaccess);
  end;
  result:=LoadXMLData('<root></root>');
  result.DocumentElement.Attributes['updatedon'] := servertime;
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption,type,visible,img,parent,levelno,category from axpages where blobno=1 order by ordno ,levelno '
  else
  begin
    s := '';
    x.sqltext:='select name,caption,type,visible,img,parent,levelno,category from axpages where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('+ dbm.gf.inuserroles +') and stype = ' + quotedstr('p') +' ) order by ordno ,levelno ';
    x.open;
    if x.isempty then raise exception.Create('User Roles not defined for this user');
    while not x.eof do begin
      if pos(quotedstr(x.fieldbyname('name').AsString),s) = 0 then
        s := s + quotedstr(x.fieldbyname('name').AsString) + ',' ;
      if pos(quotedstr(x.fieldbyname('parent').asstring),s) = 0 then
         s := s + quotedstr(x.fieldbyname('parent').asstring) + ',';
      x.next;
    end;
    x.close;
    delete(s,length(s),2);
    if s = '' then raise exception.Create('User Roles not defined for this user');
    s := 'select name,caption,type,visible,img,parent,levelno,category from axpages where blobno=1 and name in ( ' + s + ' ) order by ordno ,levelno ';
    x.sqltext:= s;
  end;
  s := '';
  x.open;
  while not x.eof do begin
    cat := lowercase(x.fieldbyname('category').AsString) ;
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1  then
      begin
        x.next;
        continue;
      end;
    end;
    s := x.fieldbyname('name').AsString ;
    if (x.fieldbyname('levelno').asstring = '0') then
    begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'true'
       else
          n.Attributes['group'] := 'false';
    end else if (x.fieldbyname('levelno').asstring = '1') then
    begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'pop'
       else
          n.Attributes['group'] := 'false';
    end else begin
       n := result.DocumentElement.AddChild(s);
       if x.fieldbyname('type').AsString  = 'h' then
          n.Attributes['group'] := 'subpop'
       else
          n.Attributes['group'] := 'false';
    end;
    n.Attributes['img'] :=  x.fieldbyname('img').asstring;
    n.Attributes['visible'] := x.fieldbyname('visible').asstring;
    n.Attributes['parent']  := x.fieldbyname('parent').asstring;
    n.NodeValue := x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if assigned(pgs) then pgs.Free;
end;

function TAxProvider.GetAllWorkFlowTStructs: IXMLDocument;
  var i : integer;
  stype : string;
begin
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetAllWorkFlowTStructs;
    exit;
  end;
  stype := 't';
  xml := nil;
  result:=LoadXMLData('<root></root>');
  if pos('default',dbm.gf.userroles) > 0 then
    x.sqltext:='select name,caption,workflow from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow) = ''t'' order by ' + dbm.gf.sqllower + '(caption)'
  else  begin
    x.sqltext:='select name,caption from tstructs where blobno=1 and '+dbm.gf.sqllower+'(workflow)=''t'' and name in (SELECT SNAME FROM AXUSERACCESS WHERE STYPE = ' + QUOTEDSTR(STYPE) + ' AND RNAME IN ('+ dbm.gf.inuserroles +')) order by ' + dbm.gf.sqllower + '(caption)'
  end;
  x.open;
  while not x.eof do begin
    result.DocumentElement.AddChild(x.fieldbyname('name').AsString).NodeValue:=x.fieldbyname('caption').asstring;
    x.next;
  end;
  x.close;
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  if trim(dbm.gf.structURL) <> '' then
  begin
    xml := LoadXMLData('<root></root>') ;
    xnode :=xml.documentelement;
    xnode.attributes['axpapp'] := dbm.gf.AppName;
    if dbm.gf.DoDebug.Active then
      xnode.Attributes['trace'] := 'true'
    else
      xnode.Attributes['trace'] := 'false';
    xnode.AddChild('sname').NodeValue := 'tstructs' ;
    xml.saveToXML(xmlstg);
    dbm.gf.DoDebug.Msg('>>Calling GetallWorkFlowTStructs webservice');
//    s := (dbm.gf.AMSCall as ARS).GetAllWorkFlowTStructs(xmlstg) ;
    if dbm.gf.DoDebug.Active then DebugMessage(s);
    if copy(s,1,7) = '<error>' then
    begin
      delete(s,1,7);
      msg := copy(s,1,pos('<',s)-1);
     raise exception.Create(msg);
    end;
    xml := LoadXMLData(s);
    for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
    begin
      xnode := nil;
      xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
      if xnode = nil then
      begin
         result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
      end;
    end;
  end;
  xml := nil;
end;

function TAxProvider.RemoteGetAllWorkFlowTStructs: IXMLDocument;
  var   i : integer;
begin
  xml := LoadXMLData('<root></root>') ;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.AddChild('role').NodeValue := dbm.gf.userroles;
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllWorkFlowTStructs webservice');
//  s := (dbm.gf.AMSDataCall as ARS).GetAllWorkFlowTStructs(xmlStg);
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  result :=  LoadXMLData(s);
  // Getting structures from AMS server
  if dbm.gf.structURL = dbm.gf.dataURL then exit;
  xnode :=xml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling GetAllWorkFlowTStructs webservice');
//  s := ( dbm.gf.AMSCall as ARS).GetAllWorkFlowTStructs(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  xml := LoadXMLData(s);
  for i := 0 to xml.DocumentElement.ChildNodes.Count - 1 do
  begin
    xnode := nil;
    xnode := result.DocumentElement.ChildNodes.FindNode(vartostr(xml.DocumentElement.ChildNodes[i].NodeName)) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(xml.DocumentElement.ChildNodes[i].NodeName).NodeValue:=xml.DocumentElement.ChildNodes[i].NodeValue;
    end;
  end;
  xml := nil;
end;

procedure TAxProvider.RemoteSaveWorkflow(name,caption:String;WXML:ixmldocument);
var wnode : ixmlnode;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.attributes['wfname'] := name;
  xnode.attributes['wfcaption'] := caption;
  wnode := xnode.AddChild('workxml');
  wnode.ChildNodes.Add(wxml.DocumentElement.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling SaveWorkFlow');
//  s := ( dbm.gf.AMSDataCall as ARS).SaveWorkFlow(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil; wnode := nil;
end;

procedure TAxProvider.RemoteSaveAttachInfo(strExp1, wkid, transid: string);
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  xnode.attributes['transid'] := transid;
  xnode.attributes['workid'] := wkid;
  xnode.attributes['context'] := strExp1;
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.Msg('>>Calling AttachWorkflow');
//  s := ( dbm.gf.AMSDataCall as ARS).AttachWorkFlow(xmlStg) ;
  if dbm.gf.DoDebug.Active then DebugMessage(s);
  if copy(s,1,7) = '<error>' then
  begin                  
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    raise exception.Create(msg);
  end;
  axml := nil;
end;

function TAxProvider.checkLicence: string;
  var y,m,d  : Word ;
     dt,dt1, expDate : string;
begin
  // license expiry date. change here the values of y,m,d. this is only place to change. enter 0 for no-expiry date
  expDate := '';
  y := 2015;
  m := 03;
  d := 30;
  if (y <> 0) and (m <> 0) and (d <> 0) then
  begin
    expdate := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,EncodeDate(y,m,d));
  end;
  if expdate <> '' then
  begin
    if dbm.gf.RemoteLogin then
       dt := copy(RemoteServerDateTime,1,10)
    else dt := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,dbm.GetServerDateTime);
    dt1 := formatDateTime(dbm.gf.ShortDateFormat.ShortDateFormat,now);
    if (strtodate(dt) > strtodate(expDate)) or (strtodate(dt1) > strtodate(expDate))then
        raise exception.create('License expired.');
    if dt <> dt1 then raise exception.create('Client and Server Dates are different. Cannot continue.');
  end;
end;

function TAxProvider.FieldFound(FldName:String;TblName:String):Boolean;
var qry:TXDS;
begin
  result := true;
  qry := dbm.GetXDS(nil);
  qry.SetCDSName('Axprovider_'+'FieldFound_'+TblName+'_'+FldName);
  qry.buffered := True;
  qry.cds.commandtext := 'select '+fldname+' from '+tblname+' where 1=2';
  try
  try
    if dbm.gf.RemoteLogin then begin
      qry.open ;
      qry.CDS.Active := True;
    end else
      qry.open;
  except
    On e:Exception do begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\FieldFound - '+e.Message);
      result := false;
    end;
  end;
  finally
    qry.close;
    FreeAndNil(qry);
  end;
end;

function TAxProvider.StructLocked(SName:String):Boolean;
var lxds : TXDS;
    t : String;
    bError : Boolean;
begin
 dbm.gf.dodebug.Msg('Locking structure '+copy(sname,2,25));
 bError := False;
 t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
 lxds := dbm.GetXDS(nil);
 lxds.buffered := True;
 lxds.CDS.CommandText := 'insert into structlock(sname,cno,lockedon) values(:tname,:cno,:lockedon)';
 lxds.assignparam(0, sname, 'c');
 lxds.assignparam(1, inttostr(dbm.gf.SesCount), 'c');
 lxds.assignparam(2, t, 'c');
 try
   lxds.CDS.Execute;
 except on e:Exception do
  begin
    if assigned(dbm) then
      dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\StructLocked - '+e.Message);
    bError := True;
  end;
 end;
 result := bError;
 lxds.close; lxds.Free;
end;

procedure TAxProvider.UnLockStruct(SName:String);
var lxds :TXDS;
begin
  dbm.gf.dodebug.Msg('Unlocking structure '+copy(sname,2,25));
  lxds := dbm.GetXDS(nil);
  lxds.DeleteRecord('structlock','sname = '+quotedstr(sname));
  lxds.close; lxds.Free;
end;

procedure TAxProvider.UnLockAllStructs(cno:String);
var lxds :TXDS;
begin
  dbm.gf.dodebug.Msg('Unlocking all structures');
  lxds := dbm.GetXDS(nil);
  lxds.DeleteRecord('structlock','cno = '+quotedstr(cno));
  lxds.close; lxds.Free;
end;

Procedure TAxProvider.SetUpdateChanges(bVal:Boolean);
begin
  if bVal then
    q.UpdateChanges := UpdateChanges
  else
    q.UpdateChanges := nil;
end;

procedure TAxProvider.SaveImage(foldername,filename,tblname: string;recid:Extended);
  var w,fname:string;
begin
  if dbm.gf.RemoteLogin then
  begin
    {
    w:='recordid='+floattostr(recid);
    q.buffered := True;
    q.CDS.CommandText :='delete from '+sname+' where '+w;
    q.open;
    q.CDS.CommandText := 'insert into ' + sname + ' (recordid,blobno,ftype) values (:recid,1,:ftype)' ;
    q.AssignParam(0, floattostr(recid),'n');
    q.AssignParam(1,ftype,'c');
    q.open;
    }
{    s:=dbm.gf.startpath+'temp\img'+dbm.gf.getnumber + '.' + ftype;
    img.Picture.SaveToFile(s);
    s := UploadFile('temp',s);
    RemoteSaveImage('img',sname, floattostr(recid) ,s,ftype);
    exit;}
  end;
  w:='filename='+quotedstr(filename)+' and recordid='+floattostr(recid);
  q.close;
  q.sqltext:='delete from '+tblname+' where '+w;
  q.execsql;
  x.Submit('recordid', floattostr(recid), 'n');
  x.Submit('blobno', '1', 'n');
  x.Submit('filename', filename, 'c');
  x.AddOrEdit(tblname, w);
  x.Post;
  fname:=foldername+filename;
  dbm.WriteBlob('img', tblname, w, fname);
end;

procedure TAxProvider.SaveImage(sFolderName,sFileName,tFolderName, tFileName: string);
  var sFile, tFile :string;
begin
  if dbm.gf.RemoteLogin then
  begin
///
  end;
  sFile := sFolderName+sFileName;
  tFile := tFolderName+tFileName;
  try
    if Length(tFile) > 255 then
      raise Exception.Create('The file name (filepath+filename) is larger than is supported by the file system.'+
           'It should have lesss than 255 characters.');

    if not copyfile(pChar(sFile),pChar(tFile),False) then
      RaiseLastOSError;
  except  on E: Exception do
    begin
      if assigned(dbm) then
        dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SaveImage - '+e.Message);
      Raise Exception.Create('Error in storing file sFileName. '+E.Message);
    end;
  end;
end;

procedure TAxProvider.SetAttachments(Filename,AxpAttTransPath:String;Recordid:Extended);
var
  sfile,tfile : string;
begin
  sfile :=  filename;
//  tfile := AxpAttTransPath+ExtractFileName(filename);
  tfile := AxpAttTransPath+Trim(FloatToStr(Recordid))+'-'+ExtractFileName(filename);
  if dbm.gf.RemoteLogin then begin
//    RemoteSetAttachments(sname,recordid,filename,recid,fn);
    exit;
  end;
  CopyFile(pChar(sfile),pChar(tfile),False);
end;

Procedure TAxProvider.DeleteAttachments(TblName:String;Recid:Extended);
var sqlstr, fname : string;
begin
  sqlStr := 'delete from '+tblname+' where recordid = :recid';
  ExecSQL(sqlStr,Floattostr(Recid),'n',false);
end;

Procedure TAxProvider.DeleteAttachments(AxpAttPath,TransType:String;Recid:Extended);
var s: String;
begin
  s := AxpAttPath+'\'+TransType+'\'+Trim(FloatTostr(Recid))+'-*.*';
  dbm.gf.DeleteFilesFromFolder(s);
end;

procedure TAxProvider.SaveImage(foldername, sfile, tfile, tblname, ftype: string; recid: Extended);
  var w,fname:string;
begin
  if dbm.gf.RemoteLogin then
  begin
  //
  end;
  fname:=foldername+sfile;
  x.close;
  if tfile <> '' then
  begin
    w:='filename='+quotedstr(tfile)+' and recordid='+floattostr(recid);
    x.Submit('filename', tfile, 'c');
  end else
  begin
    w:='recordid='+floattostr(recid);
    x.Submit('ftype', ftype, 'c');
  end;
  x.Submit('recordid', floattostr(recid), 'n');
  x.Submit('blobno', '1', 'n');
  x.AddOrEdit(tblname, w);
  x.Post;
  dbm.WriteBlob('img', tblname, w, fname);
end;

procedure TAxProvider.SetAttachments(sFolderName,sFileName,tFolderName, tFileName: string);
  var sFile, tFile :string;
begin
  if dbm.gf.RemoteLogin then
  begin
///
  end;
  sFile := sFolderName+sFileName;
  tFile := tFolderName+tFileName;
  copyfile(pChar(sFile),pChar(tFile),False);
end;


Function TAxProvider.IsStructExists(sname, wcond: String):Boolean;
begin
  Result := False;
  CreatedOn := '';
  CreatedBy := '';
  ImportedOn := '';
  ImportedBy := '';
  forcds.Close;
  forcds.buffered := True ;
  forcds.SetCDSName('Axprovider_'+sname+'_IsStructExists_'+wcond);
  forcds.CDS.CommandText:='select createdon, createdby, importedon, importedby from '+sname+' where '+wcond;
  forcds.open;
  if forcds.CDS.RecordCount > 0 then
  begin
    result := True;
    CreatedOn := forcds.CDS.FieldByName('createdon').AsString;
    CreatedBy := forcds.CDS.FieldByName('createdby').AsString;
    ImportedOn := forcds.CDS.FieldByName('importedon').AsString;
    ImportedBy := forcds.CDS.FieldByName('importedby').AsString;
  end;
end;

Procedure TAxProvider.CopyFiles(sFolder,tFolder:String);
var
  fRec : TSearchRec;
  IsFileCopied : Boolean;
begin
  if FindFirst(sFolder+'\*.*', faAnyFile, fRec) = 0 then
  repeat
    if (fRec.name = '.') or (fRec.Name = '..') then continue;
    if Length(tFolder+'\'+fRec.Name) > 255 then
       raise Exception.Create('The file name (filepath+filename) is larger than is supported by the file system.'+
           'It should have less than 255 characters.');
    IsFileCopied := CopyFile(pChar(sFolder+'\'+fRec.Name),pChar(tFolder+'\'+fRec.Name),False);
    if Not IsFileCopied then
    begin
      try
        RaiseLastOSError;
      Except on E:Exception do
      begin
        dbm.gf.dodebug.Msg(sFolder+'\'+fRec.Name+' file is not copied to '+tFolder+'\'+fRec.Name);
        dbm.gf.dodebug.Msg('Error : '+E.message);
        dbm.gf.dodebug.Log(sFolder+'\'+fRec.Name+' file is not copied to '+tFolder+'\'+fRec.Name);
        dbm.gf.dodebug.Log('CopyFiles Error : '+E.message);
      end;
      end;
    end;
  until FindNext(fRec) <> 0;
  FindClose(fRec);
end;

function TAxProvider.CheckStructureAccess(sname, name: string): ixmldocument;
begin
end;

function TAxProvider.ViewAttachments(sessionid, sname, recordid,
  filename: string): string;
begin

end;

function TAxProvider.FindPrintSourceFormat(strans,formname:string;OnlyPDF:Boolean): string;
var
 x1:TXDS;
begin
  result:='';
  x1:=dbm.GetXDS(nil);
  x1.buffered:=true;
  if OnlyPDF then begin
    x1.SetCDSName('Axprovider_FindPrintSourceFormat_pdfprops');
    x1.CDS.CommandText:='select distinct caption from pdfprops where '+dbm.gf.sqllower+'(transid) ='+dbm.gf.SQLLower+'(:transid) and '+
                         dbm.gf.SQLLower+'(caption)='+dbm.gf.SQLLower+'(:caption) order by caption';
    x1.CDS.Params.ParamValues['transid']:= strans;
    x1.CDS.Params.ParamValues['caption']:=formname;
    x1.open;
    if not x1.CDS.IsEmpty then begin
      result:='pdf';
    end;
  end
  else begin
    x1.SetCDSName('Axprovider_FindPrintSourceFormat_axpertreports_'+formname);
    formname := MakeFRCSVInQoutedStr(formname);
    x1.CDS.CommandText:='select distinct caption from axpertreports where '+dbm.gf.SQLLower+'(caption) in '+'('+LowerCase(formname)+') order by caption';
    x1.open;
    if not x1.CDS.IsEmpty then begin
      result:='axfast';
    end;
  end;
  x1.close;
  x1.destroy;
  x1:=nil;
end;

procedure TAxProvider.GetImage(Img: TImage;imgpath: string);
  var imgname,lpath:string;
begin
  lpath := imgpath;
  imgname := ExtractFilename(imgpath);
  if fileExists(lpath) then img.Picture.LoadFromFile(lpath);
  if lowercase(ExtractFileExt(imgname)) = '.gif' then  //ch1
    (Img.Picture.Graphic as TGIFImage).Animate := True;

end;

function TAxProvider.GetFastreports(stransid:String):IXMLDocument;
var
  x1:TXDS;
  Caption,Extn,name:string;
begin
  xml := nil;
  result:=LoadXMLData('<root></root>');
  stransid := lowercase(stransid);
  x1:=dbm.GetXDS(nil);
  x1.SetCDSName('Axprovider_getfastreport');
  x1.buffered:=true;
  x1.CDS.CommandText:='select distinct caption,output from axfastlink where '+dbm.gf.sqllower+'(transid) = ' + dbm.gf.SQLLower+'(:transid) order by output';
  x1.CDS.Params.ParamValues['transid']:= stransid;
  x1.open;

  while not x1.CDS.Eof do begin
    xnode := nil;
    Caption :=x1.cds.FieldByName('caption').AsString;
    Extn:=Lowercase(x1.CDS.FieldByName('output').AsString);
    if Extn='msword' then Extn:='doc'
    else if Extn='' then Extn:='pdf';
    name :=Caption+'.'+Extn;
    xnode := result.DocumentElement.ChildNodes.FindNode(name) ;
    if xnode = nil then
    begin
       result.DocumentElement.AddChild(name).NodeValue:=Caption;
    end;
    x1.CDS.Next;
  end;
  if Assigned(x1) then begin
    x1.close;
    freeandnil(x1);
  end;
end;


procedure TAxProvider.SetStructure(sname, name, caption,uname,transid,purpose : string; xml:IXMLDocument);
var w, t : string;
    rfile : String;
    StructExists, flag : boolean;
begin
  servertime := '';
  StructExists := False;
  if lowercase(name) = 'resource' then
  begin
     showmessage('Resource is an reserved word..Use another name to save the structure..');
     exit;
  end;
  if xml.DocumentElement.HasAttribute('readonly') then xml.DocumentElement.Attributes['readonly'] := '';
  if dbm.gf.RemoteLogin then begin
    t := RemoteSetStructure(sname,name,caption,uname,xml);
    if copy(t,1,4) = 'done' then
    begin
      delete(t,1,4);
      if name='' then name:=copy(caption,1,15)
      else if caption='' then caption:=name;
      xml.DocumentElement.Attributes['updatedon'] := t ;
      xml.DocumentElement.Attributes['name'] := name ;
      xml.DocumentElement.Attributes['caption'] := caption ;
      xml.DocumentElement.Attributes['type'] := 'lview' ;
      sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+sname+uname+'.xml' ;
      tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sName+'.'+uname ;
      xml.SaveToFile(sfile);
      with TCompress.Create do begin
        compressfile(sfile, tfile);
        destroy;
      end;
      if fileexists(tfile) then begin
        if fileexists(sfile) then deletefile(sfile);
      end;
    end;
    exit;
  end;
  if name='' then name:=copy(caption,1,15)
  else if caption='' then caption:=name;
  if name='' then w:='caption='+quotedstr(caption) + 'and username='+quotedstr(uname) + ' and transid ='+quotedstr(transid)
  else w:='name='+quotedstr(name)+ 'and username='+quotedstr(uname)+' and transid ='+quotedstr(transid);
  StructExists := IsStructExists(sname,w);
  t := dbm.gf.convertToDBDateTime(dbm.connection.dbtype,dbm.getserverdatetime);
  getupdtime := t;
  xml.DocumentElement.Attributes['name'] := name ;
  xml.DocumentElement.Attributes['caption'] := caption ;
  xml.DocumentElement.Attributes['type'] := 'lview' ;
  if not StructExists then
  begin
    xml.DocumentElement.Attributes['createdon'] := t;
    xml.DocumentElement.Attributes['createdby'] := dbm.gf.username;
    xml.DocumentElement.Attributes['importedon'] := '';
    xml.DocumentElement.Attributes['importedby'] := '';
  end;
  xml.DocumentElement.Attributes['updatedon'] := t;
  xml.DocumentElement.Attributes['updatedby'] := dbm.gf.username;
  if dbm.gf.structSetTo <> 'folder' then
  begin
    try
      flag := dbm.InTransaction ;
      if (not flag) then  dbm.StartTransaction(dbm.gf.connectionname);
      q.close;
      q.sqltext:='delete from '+sname+' where '+w;
      q.execsql;
      x.Submit('caption', caption, 'c');
      x.Submit('name', name, 'c');
      x.Submit('transid', transid, 'c');
      x.Submit('username', uname, 'c');
      x.Submit('blobno', '1', 'n');
      if not StructExists then
      begin
        x.Submit('createdon',t,'c');
        x.Submit('createdby',dbm.gf.username,'c');
      end else
      begin
        x.Submit('createdon',vartostr(xml.DocumentElement.Attributes['createdon']),'c');
        x.Submit('createdby',vartostr(xml.DocumentElement.Attributes['createdby']),'c');
        x.Submit('importedon',ImportedOn,'c');
        x.Submit('importedby',ImportedBy,'c');
      end;
      x.Submit('updatedon',t,'c');
      x.Submit('updatedby',dbm.gf.username,'c');
      if sname = 'tstructs' then begin
        if xml.DocumentElement.HasAttribute('wflow') then
          x.Submit('workflow',vartostr(xml.DocumentElement.Attributes['wflow']),'c');
      end;

      x.AddOrEdit(sname, w);
      x.Post;
      s:=dbm.gf.startpath+'temp\xmlmemo'+dbm.gf.getnumber;
      xml.SaveToFile(s);
      dbm.WriteMemo('props', sname, w, s);
      deletefile(s);
      if (not flag) then dbm.Commit(dbm.gf.connectionname);
    except on e : exception do
      begin
        if assigned(dbm) then
          dbm.gf.DoDebug.Log(dbm.gf.Axp_logstr+'\uAxprovider\SetStructure(Overload with 7 params) - '+e.Message);
        if (not flag) then dbm.RollBack(dbm.gf.connectionname);
      end;
    end;
  end;
  servertime := t;
  if name = 'pageorder' then exit;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+sname+transid+uname+'.xml' ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid+'.'+uname ;

  xml.SaveToFile(sfile);
  with TCompress.Create do begin
    compressfile(sfile, tfile);
    destroy;
  end;
  if fileexists(tfile) then begin
    if fileexists(sfile) then deletefile(sfile);
  end;
end;

function TAxProvider.GetStructure(sname, name, caption,purpose,uname,transid: string): IXMLDocument;
  var w,stime,readonly,updusername :string;
  getlocal : boolean;
  i : integer;
  FxmlDoc:IXMLDocument;
  stm : TStringStream;
begin
  try
  dbm.gf.IsGetStruct := True;
  readonly := '';
  updusername := '';
  readlocal := false;
  if name = '' then
  begin
     showmessage('Name not found... -' +  caption + ' - ' + sname);;
     exit;
  end;
  if dbm.gf.RemoteLogin then begin
    result := RemoteGetStructure(sname,name,caption,purpose,uname);
    result.DocumentElement.Attributes['updusername'] := updusername;
    GetStructName:=trim(vartostr(Result.DocumentElement.Attributes['name']));
    GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
    if sname = 'printprops' then
    begin
       sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       GetPrintTemplate('printprops',GetStructName,sfile);
    end;
    exit;
  end;
  xml := nil; stime := '';axml := nil ;
  getlocal := false;
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid+'.'+uname ;
  tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+sname+uname+transid+'.xml' ;
 { if fileexists(sfile) then deletefile(sfile);
  if fileexists(tfile) then deletefile(tfile);}

  if fileexists(sfile) then begin
    with TCompress.Create do begin
      decompressfile(sfile, tfile);
      destroy;
    end;
    if fileexists(tfile) then
    begin
      FxmlDoc:=nil;                                                // Changed for Unicode
      FxmlDoc:=LoadXMLData('<root></root>');
      FxmlDoc.LoadFromFile(tfile);
      xml:=FxmlDoc;
      deletefile(tfile);
    end;
    getlocal := True;
    readlocal := true;
    stime := 'pagefound';
    xml.DocumentElement.Attributes['updusername'] := updusername;
    result := xml  ;
    if sname = 'axpages' then
    begin
      GetPageName:=name;
      GetPageCaption:=vartostr(Result.DocumentElement.Attributes['caption']);;
      GetPageImg:=vartostr(Result.DocumentElement.Attributes['img']);
      GetPageVisible:=vartostr(Result.DocumentElement.Attributes['visible']);
      PageType:=vartostr(Result.DocumentElement.Attributes['type']);
      PageOrdNo:=vartostr(Result.DocumentElement.Attributes['ordno']);
      PageLevelNo:=vartostr(Result.DocumentElement.Attributes['levelno']);
      PageParent:=vartostr(Result.DocumentElement.Attributes['parent']);
    end
    else begin
      GetStructName:=name;
      GetStructCaption:=trim(vartostr(Result.DocumentElement.Attributes['caption']));
    end;
  end;
  if stime <> 'pagefound' then
  begin
    result:=LoadXMLData('<root></root>');
    if name <> 'pageorder' then
    begin
      if dbm.gf.structGetFrom <> 'folder' then begin
      begin
          x:=dbm.getxds(x);
          x.SetCDSName('Axprovider_'+sname+'_'+uname);
          if name='' then w:=dbm.gf.sqllower+'(caption)='+lowercase(quotedstr(caption)) +
                         ' and username='+quotedstr(uname) +' and transid ='+quotedstr(transid)
          else w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name)) +
                  'and username='+quotedstr(uname)+ ' and transid ='+quotedstr(transid);
          x.sqltext:='select * from '+sname+' where '+w;
          x.open;
          if x.isempty then
          begin
             x.close;
             if name='' then w:=dbm.gf.sqllower+'(caption)='+lowercase(quotedstr(caption)) + 'and username='+quotedstr('all')
             else w:=dbm.gf.sqllower+'(name)='+lowercase(quotedstr(name)) + 'and username='+quotedstr('all') ;
             x.sqltext:='select * from '+sname+' where '+w;
             x.open;
          end;
          if not x.isempty then begin
            stm := TStringStream.Create;
            dbm.ReadMemo('props', sname, w, stm);
            if stm.Size=0 then result:=LoadXMLData('<root/>')
            else result := LoadXMLDataFromWS(trim(stm.DataString));
            FreeAndNil(stm);
            if sname = 'axpages' then
            begin
              GetPageName:='';
              GetPageCaption:='';
              GetPageImg:='';
              GetPageVisible:='';
              GetPageName:=x.fieldbyname('name').asstring;
              GetPageCaption:=x.fieldbyname('caption').asstring;
              GetPageImg:= x.fieldbyname('img').asstring;
              GetPageVisible:= x.fieldbyname('visible').asstring;;
              PageType:=x.fieldbyname('type').asstring;;
              PageOrdNo:=x.fieldbyname('ordno').asstring;;
              PageLevelNo:=x.fieldbyname('levelno').asstring;;
              PageParent:=x.fieldbyname('parent').asstring;;
              result.DocumentElement.Attributes['name']:=GetPageName;
              result.DocumentElement.Attributes['caption']:=GetPageCaption;
              result.DocumentElement.Attributes['img'] := GetPageImg ;
              result.DocumentElement.Attributes['visible'] := GetPageVisible;
              result.DocumentElement.Attributes['type'] := PageType;
              result.DocumentElement.Attributes['ordno'] := PageOrdNo;
              result.DocumentElement.Attributes['levelno'] := PageLevelNo;
              result.DocumentElement.Attributes['parent'] := PageParent;
            end
            else begin
              GetStructName:=x.fieldbyname('name').asstring;
              GetStructCaption:='';
              if assigned(x.findfield('caption')) then GetStructCaption:=x.fieldbyname('caption').asstring;
              result.DocumentElement.Attributes['name'] := GetStructName;
              result.DocumentElement.Attributes['caption'] := GetStructCaption;
//              result.DocumentElement.Attributes['readonly'] := readonly;
              result.DocumentElement.Attributes['updusername'] := updusername;
            end;
          end else
          begin
            GetPageName:='';
            GetPageCaption:='';
            GetPageImg:='';
            GetPageVisible:='';
            result:=LoadXMLData('<root/>');
            x.close;
            if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
               raise exception.Create(sname + ' [' + name + '] is not available...');
          end;
      end;
      end
      else if (trim(dbm.gf.structURL) <> '') and (result.DocumentElement.ChildNodes.Count = 0) then
      begin
        xml := LoadXMLData('<root></root>') ;
        xnode :=xml.documentelement;
        xnode.attributes['axpapp'] := dbm.gf.AppName;
        xnode.attributes['sessionid'] := dbm.gf.sessionid;
        if dbm.gf.DoDebug.Active then
          xnode.Attributes['trace'] := 'true'
        else
          xnode.Attributes['trace'] := 'false';
        xnode.AddChild('sname').NodeValue := sname;
        xnode.AddChild('name').NodeValue := name;
        xnode.AddChild('caption').NodeValue := caption;
        xnode.AddChild('uname').NodeValue := uname;
        xml.saveToXML(xmlstg);
        dbm.gf.DoDebug.Msg('>>Calling GetStructure webservice');
//        s := ( dbm.gf.AMSCall as ARS).GetStructure(xmlstg) ;
        msg := copy(s,1,pos('~',s)-1);
        delete(s,1,pos('~',s));
        if dbm.gf.DoDebug.Active then DebugMessage(msg);
        if copy(s,1,7) = '<error>' then
        begin
          delete(s,1,7);
          msg := copy(s,1,pos('<',s)-1);
          raise exception.Create(msg);
        end;
        result := LoadXMLData(s);
        if (sname = 'axpages') then
        begin
          GetPageName:='';
          GetPageCaption:='';
          GetPageImg:='';
          GetPageVisible:='';
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetPageName:=vartostr(result.DocumentElement.Attributes['name']);
              GetPageCaption:=vartostr(result.DocumentElement.Attributes['caption']);
              GetPageImg:=vartostr(result.DocumentElement.Attributes['img']);
              GetPageVisible:=vartostr(result.DocumentElement.Attributes['visible']);
              PageType:=vartostr(result.DocumentElement.Attributes['type']);
              PageOrdNo:=vartostr(result.DocumentElement.Attributes['ordno']);
              PageLevelNo:=vartostr(result.DocumentElement.Attributes['levelno']);
              PageParent:=vartostr(result.DocumentElement.Attributes['parent']);
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end else begin
            if  copy(s,1,7) <> '<root/>' then
            begin
              GetStructName:=vartostr(result.DocumentElement.Attributes['name']);
              GetStructCaption:=trim(vartostr(result.DocumentElement.Attributes['caption']));
            end else
            begin
              if (sname = 'tstructs') or (sname = 'iviews') or (sname = 'lviews') then
                 raise exception.Create(sname + ' [' + name + '] is not available...');
            end;
        end;
      end;
    end
    else result := GetPageOrderXML;
    if (result.DocumentElement.ChildNodes.Count = 0) and ((name <> 'pageorder') and (name <> 'template')) then
    begin
       exit;
    end;
    result.DocumentElement.Attributes['updusername'] := updusername;
    tfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid+'.'+uname ;
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+sname+uname+transid+'.xml' ;
    result.SaveToFile(sfile);
    with TCompress.Create do begin
       compressfile(sfile, tfile);
       destroy;
    end;
    if fileexists(tfile) then begin
       if fileexists(sfile) then deletefile(sfile);
    end;
  end;
  if sname = 'printprops' then
  begin
     sfile := ExtractFileName(Result.DocumentElement.Attributes['filename']);
     GetPrintTemplate('printprops',GetStructName,sfile);
  end;
  axml := nil; xnode:= nil;
  finally
    dbm.gf.IsGetStruct := False;
  end;
end;

procedure TAxProvider.DeleteStrucutre(sname, name, caption,transid: string);
var
s : string;
begin
  if dbm.gf.RemoteLogin then begin
    RemoteDeleteStrucutre(sname,name,caption);
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid ;
    if fileexists(sfile) then deletefile(sfile);
    exit;
  end;
  axml := nil;
  if name = '' then
  begin
     axml := ExecSQL('select name from ' + sname + ' where  caption = :caption',caption,'c',True);
     xNode := axml.DocumentElement;
     xNode := xNode.ChildNodes.FindNode('data');
     if (xNode <> nil) and (xNode.ChildNodes.Count > 0) then xNode := xNode.ChildNodes[0]
     else xNode := nil;
     if xNode <> nil then
       name := vartostr(xNode.ChildValues['NAME']);
  end;
  if trim(name) = '' then exit;
  s := 'name='+quotedstr(name) + ' and transid ='+quotedstr(transid) +
       'and username = '+quotedstr(dbm.gf.username);
  x.DeleteRecord(sname, s);
  sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid ;
  if fileexists(sfile) then deletefile(sfile)
  else begin
    sfile := dbm.gf.startpath+'Structures\'+dbm.gf.AppName+'\'+name+'.'+sname+'.'+transid+'.'+dbm.gf.username;
    if fileexists(sfile) then deletefile(sfile)
  end;
end;



function TAxProvider.CheckExistanceInTransControl(recid: extended;transid : string): boolean;
var
  loadedOn : TDateTime;
  iTime,mintaken : Integer;
  sqlstr,sId : String;
  rId : Extended;
  cxds : Txds;
begin
  result := false;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);

  cxds := dbm.getxds(nil);
  cxds.SetCDSName('Axprovider_'+'transcontrol_'+transid+'_'+floattostr(recid));
  cxds.buffered := true;
  cxds.cds.commandtext:= 'select username from axtranscontrol where recordid = '+floattostr(recid) +
                          ' and sessionid <> '+ QuotedStr(sId) +
                          ' and transid = ' + QuotedStr(transid);
  cxds.open;
  dbm.gf.RecordLockedBy := '';
  if cxds.cds.recordcount > 0 then
  begin
    dbm.gf.RecordLockedBy := cxds.cds.fieldbyname('username').AsString;
    result := true;
  end
  else result := false;
  cxds.close;
  cxds.Destroy;
  cxds := nil;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl ends');
end;

procedure TAxProvider.InsertIntoTransControl(transid: String; recid: extended);
var
  sdate,sqlstr,sId : string;
  cxds : Txds;
begin
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>InsertIntoTransControl procedure starts');

  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);

  cxds := dbm.getxds(nil);
  DeleteTransControl;
  sdate := datetimetostr(dbm.getServerDateTime);
  cxds.Submit('username',dbm.gf.username,'c');
  cxds.Submit('sessionid',sId,'c');
  cxds.Submit('transid',transid,'c');
  cxds.Submit('recordid',floattostr(recid),'n');
  cxds.Submit('loadedon',sdate,'d');
  cxds.AddOrEdit('axtranscontrol','1=2');
  cxds.close;
  cxds.Destroy;
  cxds := nil;
  dbm.gf.DoDebug.msg('>>InsertIntoTransControl procedure end.');
end;

procedure TAxProvider.DeleteTransControl;
var
  sqlstr,sId : string;
begin
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);

  if dbm.gf.username  <> '' then
    sqlstr := 'delete from axtranscontrol where username = '+QuotedStr(dbm.gf.username) +
              ' and sessionid = '+ QuotedStr(sId)
  else
    sqlstr := 'delete from axtranscontrol where sessionid = '+ QuotedStr(sId);
  ExecSQL(sqlstr,'','',false);
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure ends');
end;

procedure TAxProvider.DeleteTransControl(recid: extended; transid: string);
var
  sId,sqlstr : string;
begin
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);

  sqlstr := 'delete from axtranscontrol where username = '+QuotedStr(dbm.gf.username) +
            ' and sessionid = '+ QuotedStr(sId) +
            ' and recordid = '+ floattostr(recid) + ' and transid = '+ QuotedStr(transid);
  ExecSQL(sqlstr,'','',false);
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure ends');
end;

function TAxProvider.CheckExistanceInTransControl(recid,transid : string): boolean;
var
  loadedOn : TDateTime;
  iTime,mintaken : Integer;
  sqlstr,sId : String;
  rId : Extended;
  cxds : Txds;
begin
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  cxds := dbm.getxds(nil);
  cxds.SetCDSName('Axprovider_'+'transcontrol_'+transid+'_'+recid);
  cxds.buffered := true;
  cxds.cds.commandtext:= 'select username from axtranscontrol where recordid = '+recid +
                          ' and sessionid <> '+ QuotedStr(sId) +
                          ' and transid = ' + QuotedStr(transid);
  cxds.open;
  dbm.gf.RecordLockedBy := '';
  if cxds.cds.recordcount > 0 then
  begin
    dbm.gf.RecordLockedBy := cxds.cds.fieldbyname('username').AsString;
    result := true;
  end
  else result := false;
  cxds.close;
  cxds.Destroy;
  cxds := nil;
  dbm.gf.DoDebug.msg('>>CheckExistanceInTransControl ends');
end;


procedure TAxProvider.DeleteTransControl(recid, transid: string);
var
  sId,sqlstr : string;
begin
  if copy(lowercase(dbm.gf.username),1,6) = 'portal' then exit;
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure starts');
  if dbm.gf.IsService then sId := dbm.gf.sessionid
  else sID := inttostr(dbm.Connection.ConnectNo);
  sqlstr := 'delete from axtranscontrol where sessionid = '+ QuotedStr(sId) +
            ' and recordid = '+ recid + ' and transid = '+ QuotedStr(transid);
  ExecSQL(sqlstr,'','',false);
  dbm.gf.DoDebug.msg('>>DeleteTransControl (Overload) procedure ends');
end;


procedure TAxProvider.SaveToLog(servicename, structname, serviceresult : String; recordid : extended);
var x:txds;
begin
  x := nil;
  try
    if (dbm.gf.Axp_Axpertlog = False) then Exit;
    dbm.gf.dodebug.msg('# 1#Saving to log');
    x:=dbm.getxds(nil);
    x.append('axpertlog');
    x.Submit('sessionid', dbm.gf.d_sessionid, 'c');
    x.Submit('username', dbm.gf.username, 'c');
    x.Submit('calledon', datetimetostr(dbm.getserverdatetime) , 'd');
    x.Submit('callfinished', datetimetostr(now()) , 'd');
    x.Submit('structname', structname, 'c');
    x.Submit('recordid', floattostr(recordid) , 'n');
    x.Submit('servicename', servicename, 'c');
    x.Submit('serviceresult',serviceresult, 'c');
    x.Submit('timetaken', inttostr(millisecondsbetween(now(),(dbm.getserverdatetime))), 'n');
    x.Submit('dbtimetaken', inttostr(dbm.gf.dbtimetaken), 'n');
    x.Post;
    x.close;
    except on e:exception do
      begin
        dbm.gf.dodebug.msg('Axpert Log Error msg : ' + e.message);
        if assigned(x) then FreeAndNil(x);
      end;
  end;
end;

function TAxprovider.CheckFastReport(Outputs,transid:string):Boolean;
var x1:Txds;
  Sqlstr:string;
begin
  Result:=false;
  x1:=Dbm.GetXDS(nil);
  x1.SetCDSName('Axprovider_'+'checkfastreport_'+transid+'_'+Outputs);
  x1.buffered:=true;
  Sqlstr :='Select distinct caption from axfastlink where '
            + dbm.gf.sqllower+ '(transid) = ' + Lowercase(Quotedstr(transid)) + ' and '
            + dbm.gf.sqllower+ '(output) in (' + Lowercase(Outputs) + ')' + ' Order by caption ';
  x1.CDS.CommandText:= Sqlstr;
  x1.open;
  if not x1.CDS.IsEmpty then result:=true;
  x1.close;
  freeandnil(x1);
end;

function TAxprovider.CheckPrinForms(transid:string):Boolean;
var
  x1 : TXDs;
begin
  Result:=false;
  x1:=Dbm.GetXDS(nil);
  x1.SetCDSName('Axprovider_'+'checkprints_'+transid);
  x1.buffered:=true;
  x1.CDS.CommandText := 'select name from prints where '+dbm.gf.sqllower+'(sname)='+ Quotedstr('t'+lowercase(transid));
  x1.open;
  if not x1.CDS.IsEmpty then result:=true;
  x1.close;
  freeandnil(x1);
end;


function TAxProvider.ExtractFRname(Formname:string):string;
var Extn:string;
begin
  Result:='';
  Extn:=ExtractFileExt(Formname);
  if Extn<>'' then Formname:=Copy(Formname,1,Pos('.',Formname)-1);
  Result:=Formname;
end;


function TAxProvider.MakeFRCSVInQoutedStr(CommaSepVal : String):String;
var
  s,fnames:string;
  i : Integer;
begin
  result := '';
  i := 1;
  s := dbm.gf.GetNthString(CommaSepVal,i);
  while s <> '' do
  begin
    s:=ExtractFRname(s);
    if fnames = '' then
      fnames := QuotedStr(s)
    else
      fnames := fnames+','+QuotedStr(s);
    inc(i);
    s := dbm.gf.GetNthString(CommaSepVal,i)
  end;
  if fnames <> '' then result := fnames;
end;

function TAxProvider.LoadXMLDataFromWS(xml : WideString) : IXMLDocument;
begin
   result := LoadXMLData(xml);
end;

Function TAxProvider.GetFastReportFileExt(stransid,Rname:String):String;
var x1 : TXDS;
    Emsg :string;
begin
  result := '';
  Emsg := '';
  dbm.gf.DoDebug.msg('Getting FastReport File extension');
  if not TableFound('axfastlink') then begin
    dbm.gf.DoDebug.msg('Axfastlink is not avilable.');
    exit;
  end;
  try
  x1 := dbm.GetXDS(nil);
  x1.buffered := True;
  x1.CDS.CommandText := 'select output from axfastlink where '+dbm.gf.sqllower+'(transid) = ' +
            dbm.gf.SQLLower+'(:transid) and '+dbm.gf.sqllower+'(caption) = ' +
            dbm.gf.SQLLower+'(:caption)';
  x1.CDS.Params.ParamValues['transid']:= lowercase(stransid);
  x1.CDS.Params.ParamValues['caption']:= lowercase(ExtractFilenameWithoutExtension(Rname));
  x1.open;
  If x1.CDS.RecordCount > 0 then
     result := x1.cds.fieldbyname('output').AsString;
     if lowercase(result) = 'msword' then
      result :='doc'
     else if result = '' then
      result:='pdf';
     result := '.'+result;
  Except
     on E : EDatabaseError do
        Emsg := E.Message;
     on E1 : EAccessViolation do
        Emsg := E1.Message;
  end;
  if Emsg <> '' then
     dbm.gf.DoDebug.msg('Error while executing GetFastReportFileExt : ' +Emsg);
  x1.close; x1:=nil;
end;

Function TAxProvider.ExtractFilenameWithoutExtension(FRfileName : String):String;
var
  Idx : Integer;
Begin
  result := FRfileName;
  if ExtractFileExt(FRfileName) = '' then Exit;
  Idx := FRfileName.LastDelimiter('.' + PathDelim + DriveDelim);
  result := Copy(FRfileName , 1 , Idx);
End;

procedure TAxProvider.DeleteTransControl(UName: String);
var
  sqlstr : string;
begin
  if not dbm.gf.Axp_LockOnRead  then exit;
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure starts');
  if UName  <> '' then
  begin
    sqlstr := 'delete from axtranscontrol where username = '+QuotedStr(UName);
    ExecSQL(sqlstr,'','',false);
  end;
  dbm.gf.DoDebug.msg('>>DeleteTransControl procedure ends');
end;

function TAxProvider.GetNewName() : string;
  var wXData : IXMLDocument;
      n,n1,n2 : IXMLNode ;
      i,k : integer ;
      s,sqlstr  : string ;
begin
  result := '';
  k := 0;
  if dbm.connection.dbtype = 'ms sql' then
    sqlstr := 'select name from iviews where  name like  ''iview%''  and isnumeric(SUBSTRING(name,6,4)) = 1 order by (select CONVERT(INT,SUBSTRING(name,6,4))) desc'
  else if (dbm.connection.dbtype = 'mysql') or (dbm.connection.dbtype = 'postgre') then
    sqlstr := 'select name from iviews where name like ''iview%'' and substring(name, 6, 4) regexp ''[0-9]+$'' order by CONVERT(substr(name,6,4),UNSIGNED INTEGER)  desc'
  else
    sqlstr := 'select name from iviews where  name like  ''iview%'' and LENGTH(TRANSLATE(substr(name,6,4), ''x0123456789'', ''x'')) IS  NULL  order by to_number(substr(name,6,4))  desc';
  wXData := ExecSQL(sqlstr,'','',True);
  n1 := wXData.DocumentElement ;
  n := n1.ChildNodes.FindNode('data');
  if n = nil then exit;
  for i := 0 to n.ChildNodes.Count - 1 do
  begin
     n2 := n.ChildNodes[i] ;
     s := vartostr(n2.ChildNodes[0].NodeValue);
     s := copy(s,6,length(s)-5 );
     k := StrToIntDef(s,-1);
     if k >= 0 then break;
  end;
  s := 'iview' + inttostr(k+1);
  result := 'iview' + inttostr(k+1);
end;


procedure TAxProvider.SavetoUserAccess(sname,stype:String);
var  i : integer;
    xQry : TXDS;
    r,sqltext,s : string;
    Errstr:string;
begin
  //RemoveUserAccess;
  xQry := dbm.GetXDS(nil);
  xQry.buffered := True;
  i := 1;
  r := dbm.gf.getnthstring(dbm.gf.userroles,i);
  while r<>'' do
  begin
    if r = 'default' then
    begin
      inc(i);
      r := dbm.gf.getnthstring(dbm.gf.userroles,i);
      continue;
    end;
    try
      sqltext := 'insert into axuseraccess(rname,sname,stype,blobno) values (' + quotedstr(r) + ',' + quotedstr(sName) + ',' + quotedstr(stype) + ',' + quotedstr('1') + ')';
      xQry.CDS.CommandText := sqlText;
      if dbm.gf.remotelogin then
        xQry.open
      else
        xQry.execsql;
      dbm.gf.doDebug.Msg('Firing SQL '+ sqltext+' <OK>');
      inc(i);
      r := dbm.gf.getnthstring(dbm.gf.userroles,i);
    Except on e:exception do
      begin
        Errstr:=dbm.gf.Axp_logstr+'\uAxprovider\SavetoUserAccess - '+e.Message;
        dbm.gf.DoDebug.Log(Errstr);
        s := 'Firing SQL '+ sqltext +' <error> '+E.Message ;
        dbm.gf.doDebug.Msg('Firing SQL '+ sqltext +' <error> '+E.Message);
        inc(i);
        r := dbm.gf.getnthstring(dbm.gf.userroles,i);
      end;
    end;
  end;
  FreeAndNil(xQry);
end;

procedure TAxProvider.ApplyAppSettings(RoleName,PropName,PropValue:String);
var w : String;
begin
  x.close;
  if RoleName = '' then
  begin
     w :='OrdNo = 1 and PropName = '+QuotedStr(PropName);
    if dbm.gf.UserLevel < 3 then
      w := w+' and UserLevel = '+ IntToStr(dbm.gf.UserLevel)
    else
      w := w+' and UserName = '+ QuotedStr(dbm.gf.UserName);
    x.Submit('OrdNo','1','n');
    x.Submit('UserName',dbm.gf.username,'c');
    x.Submit('UserLevel',IntToStr(dbm.gf.userlevel),'c');
  end else
  begin
    w :='OrdNo = 2 and PropName = '+QuotedStr(PropName)+ ' and RoleName = '+ QuotedStr(RoleName);
    x.Submit('OrdNo','2','n');
    x.Submit('RoleName',RoleName,'c');
  end;
  x.Submit('PropName',PropName,'c');
  x.Submit('PropValue',PropValue,'c');
  x.AddOrEdit('AxAppConfig',w);
  x.close;
end;

procedure TAxProvider.ApplyFormSettings(TblName,SFldName,SFldVal,FldName,PropName,PropValue,RoleName:String);
var w : String;
begin
  x.close;
  if PropName = '' then
  begin
    w := SFldName+' = '+QuotedStr(SFldVal) ;
  end else
  begin
    w :='PropName = '+QuotedStr(PropName)+  ' and '+SFldName+' = '+QuotedStr(SFldVal)+' and '+FldName+' = ''*''' ;
  end;
  if RoleName = '' then
  begin
    if (PropName = '') and (dbm.gf.UserLevel = 1)then
      w := w+' and ((UserLevel = '+ IntToStr(dbm.gf.UserLevel)+') or (UserName = ''all''))'
    else if dbm.gf.UserLevel < 3 then
      w := w+' and UserLevel = '+ IntToStr(dbm.gf.UserLevel)
    else
      w := w+' and UserName = '+ QuotedStr(dbm.gf.UserName);
  end
  else
    w := w+' and RoleName = '+ QuotedStr(RoleName);

  x.Submit('UserName',dbm.gf.username,'c');
  x.Submit('UserLevel',IntToStr(dbm.gf.userlevel),'c');
  x.Submit(SFldName,SFldVal,'c');
  if PropName ='' then
    x.Submit(FldName,PropValue,'c')
  else
  begin
    x.Submit(FldName,'*','c');
    x.Submit('PropName',PropName,'c');
    x.Submit('PropValue',PropValue,'c');
  end;
  x.AddOrEdit(TblName,w);
  x.close;
end;

procedure TAxProvider.ApplyCompSettings(TblName,SFldName,SFldVal,PkFldName,PkFldVal,PropName,PropValue,RoleName:String;RecFound:Boolean);
var w : String;
begin
  x.close;
  if RecFound then
  begin
    w :='PropName = '+QuotedStr(PropName)+  ' and '+SFldName+' = '+QuotedStr(SFldVal)+' and '+PkFldName+' = '+QuotedStr(PkFldVal) ;
    if RoleName = '' then
    begin
      if dbm.gf.UserLevel < 3 then
        w := w+' and UserLevel = '+ IntToStr(dbm.gf.UserLevel)
      else
        w := w+' and UserName = '+ QuotedStr(dbm.gf.UserName);
    end
    else
      w := w+' and RoleName = '+ QuotedStr(RoleName);
    x.Edit(TblName,w);
  end else
    x.Append(TblName);

  x.Submit('UserName',dbm.gf.username,'c');
  x.Submit('UserLevel',IntToStr(dbm.gf.userlevel),'c');
  x.Submit(SFldName,SFldVal,'c');
  x.Submit(PkFldName,PkFldVal,'c');
  x.Submit('PropName',PropName,'c');
  x.Submit('PropValue',PropValue,'c');
  x.Post;
  x.close;
end;

function TAxProvider.GetPageOrderXMLForPageCreatedThroughWeb(forweb: Boolean)
  : IXMLDocument;
var
  n: IXMLNode;
  i, ExprListCount: integer;
  pgs: TStringlist;
  cat, SqlTxt, OrgSqlTxt, OrdTxt: string;
begin
  pgs := nil;
  SqlTxt := '';
  ExprListCount := 1;
  if dbm.gf.pageaccess <> '' then
  begin
    pgs := TStringlist.create;
    if pos(',', dbm.gf.pageaccess) > 0 then
    begin
      i := 1;
      while True do
      begin
        s := dbm.gf.GetnthString(dbm.gf.pageaccess, i);
        if s = '' then
          break;
        pgs.Add(s);
        i := i + 1;
      end;
    end
    else
      pgs.Add(dbm.gf.pageaccess);
  end;
  result := LoadXMLData('<root></root>');
  result.DocumentElement.attributes['updatedon'] := servertime;
  if (pos('default', dbm.gf.userroles) > 0) then
  begin
    x.SetCDSName('Axprovider_GetPageOrderXMLForPageCreatedThroughWeb_axpages_default');
    if forweb then
      x.SQLText :=
        'select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 order by ordno ,levelno '
    else
      x.SQLText :=
        'select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) order by ordno ,levelno ';
  end
  else
  begin
    s := '';
    if forweb then
      x.SQLText :=
        'select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('
        + dbm.gf.inuserroles + ') and stype = ' + QUOTEDSTR('p') +
        ' ) order by ordno ,levelno '
    else
      x.SQLText :=
        'select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) and name in (SELECT SNAME FROM AXUSERACCESS WHERE RNAME IN ('
        + dbm.gf.inuserroles + ') and stype = ' + QUOTEDSTR('p') +
        ' ) order by ordno ,levelno ';
    x.SetCDSName('Axprovider_GetPageOrderXMLForPageCreatedThroughWeb_axpages_useraccess');
    x.open;
    if x.isempty then
      raise exception.create('User Roles not defined for this user');
    if forweb then
      OrgSqlTxt :=
        ' select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and name in'
    else
      OrgSqlTxt :=
        ' select name,caption,type,visible,img,parent,ordno,levelno,category,pagetype from axpages where blobno=1 and (pagetype <> ''web'' or pagetype is null) and name in';
    OrdTxt := ' order by ordno ,levelno ';
    while not x.eof do
    begin
      if pos(QUOTEDSTR(x.fieldbyname('name').AsString), s) = 0 then
        s := s + QUOTEDSTR(x.fieldbyname('name').AsString) + ',';
      if pos(QUOTEDSTR(x.fieldbyname('parent').AsString), s) = 0 then
        s := s + QUOTEDSTR(x.fieldbyname('parent').AsString) + ',';
      x.next;
      Inc(ExprListCount);
      if ExprListCount >= 500 then
      begin
        delete(s, length(s), 2);
        if SqlTxt = '' then
          SqlTxt := OrgSqlTxt + ' ( ' + s + ' ) '
        else
          SqlTxt := SqlTxt + ' Union ' + OrgSqlTxt + ' ( ' + s + ' ) ';
        s := '';
        ExprListCount := 1;
      end;
    end;
    if s <> '' then
      delete(s, length(s), 2);
    if (ExprListCount > 1) then
    begin
      if (SqlTxt = '') then
        SqlTxt := OrgSqlTxt + ' ( ' + s + ' ) '
      else
        SqlTxt := SqlTxt + ' Union ' + OrgSqlTxt + ' ( ' + s + ' ) ';
    end;
    if SqlTxt = '' then
      raise exception.create('User Roles not defined for this user');
    SqlTxt := 'select * from (' + SqlTxt + ') a ' + OrdTxt;
    x.close;
    x.SetCDSName('login_GetPageOrderXMLForPageCreatedThroughWeb_userroles');
    x.SQLText := SqlTxt;
  end;
  s := '';
  x.open;
  while not x.eof do
  begin
    cat := lowercase(x.fieldbyname('category').AsString);
    if (cat <> '') and (dbm.gf.pageaccess <> '') then
    begin
      i := -1;
      i := pgs.IndexOf(cat);
      if i = -1 then
      begin
        x.next;
        continue;
      end;
    end;
    s := x.fieldbyname('name').AsString;
    if (x.fieldbyname('levelno').AsString = '0') then
    begin
      n := result.DocumentElement.AddChild(s);
      if x.fieldbyname('type').AsString = 'h' then
        n.attributes['group'] := 'true'
      else
        n.attributes['group'] := 'false';
    end
    else if (x.fieldbyname('levelno').AsString = '1') then
    begin
      n := result.DocumentElement.AddChild(s);
      if x.fieldbyname('type').AsString = 'h' then
        n.attributes['group'] := 'pop'
      else
        n.attributes['group'] := 'false';
    end
    else
    begin
      n := result.DocumentElement.AddChild(s);
      if x.fieldbyname('type').AsString = 'h' then
        n.attributes['group'] := 'subpop'
      else
        n.attributes['group'] := 'false';
    end;
    n.attributes['img'] := x.fieldbyname('img').AsString;
    n.attributes['visible'] := x.fieldbyname('visible').AsString;
    n.attributes['parent'] := x.fieldbyname('parent').AsString;
    n.attributes['levelno'] := x.fieldbyname('levelno').AsString;
    n.attributes['pagetype'] := x.fieldbyname('pagetype').AsString;
    n.attributes['type'] := x.fieldbyname('type').AsString;
    n.NodeValue := x.fieldbyname('caption').AsString;
    x.next;
  end;
  x.close;
  if assigned(pgs) then
  begin
    pgs.clear;
    FreeAndNil(pgs);
  end;
end;


function TAxProvider.GetMemberShipDetails(FldName, FldValue, CallType , RemoteProject:String): String{IXMLDocument};
var i : integer;
    QryStr , WhereCondition : String;
    XmlDoc : IXMLDocument;
    rnode,dnode,xnode : ixmlnode;
begin
  dbm.gf.DoDebug.msg('GetMemberShipDetails starts.');
  QryStr := ''; WhereCondition := '';
  if (lowercase(FldName) = 'membershipno') then
    WhereCondition := ' ct.membershipno ='+QuotedStr(FldValue)  //table - membershipdetails
  else if (lowercase(FldName) = 'phone') then
    WhereCondition := ' c.phone = '+QuotedStr(FldValue) //table - membershipdetails
  else if (lowercase(FldName) = 'customercode')  then
    WhereCondition := ' c.customercode = '+QuotedStr(FldValue);
  if lowercase(CallType) = 'remote' then begin
    Result := RemoteGetMemberShipDetails(WhereCondition, RemoteProject);
    exit;
  end;
  XmlDoc :=LoadXMLData('<sqlresultset></sqlresultset>');
  rnode := XmlDoc.DocumentElement.AddChild('response');
  x.close;
  QryStr := GetQry('axpos_customerqry');
  if QryStr = '' then QryStr := 'select c.customername ,c.customercode , c.email , c.phone , c.address , ct.membershipno ,'+
                'ct.pointsavailable ,ct.valueavailable ,ct.creditavailable  from customer c, customersummary ct'+
                  ' where  c.customercode = ct.customercode(+) and '+dbm.gf.SQLLower+'(c.inactive) = ''f'' and '
                  +dbm.gf.SQLLower+'(ct.holdflag) = ''f'' and '
                  +dbm.gf.SQLLower+'(ct.damageflag) = ''f'' and '
                  +dbm.gf.SQLLower+'(ct.inuse) = ''t'' ';
  x.sqltext := QryStr;
  if WhereCondition <> '' then
     x.sqltext := x.sqltext +' and '+ WhereCondition;
  try
  x.open;
  while not x.Eof do begin
    dnode := rnode.addchild('row');
    for i:=0 to x.Fields.Count-1 do begin
      if lowercase(x.Fields[i].FieldName) = 'axrnum' then continue;   // to skip axrnum column which is used for pagination.
//      dnode.AddChild(lowercase(x.Fields[i].FieldName)).NodeValue:=x.Fields[i].AsString;
      xnode := dnode.addchild(lowercase(x.Fields[i].FieldName));
      if x.fields[i].AsString = '' then
        xnode.NodeValue := ''//'*'
      else
        xnode.NodeValue := x.Fields[i].AsString;
    end;
    x.next;
  end;
  Result := XmlDoc.DocumentElement.XML;
  Except on E:Exception do
    begin
       result:='<error>'+e.Message+'</error>';
    end;
  end;
  dbm.gf.DoDebug.msg('GetMemberShipDetails ends.');
end;


function TAxProvider.RemoteGetMemberShipDetails(WhereCondition, RemoteProject:String): String {IXMLDocument};
var
  XmlResultStr : String;
begin
     dbm.gf.DoDebug.msg('POSMembership GetMembershipNo WebService Call starts.');
     try
       Result := (dbm.gf.POSHTTPRio as ASBARS).GetMembershipNo(RemoteProject,WhereCondition); //calls GetMembershipNo webservice
//       Result.LoadFromXML(XmlResultStr);
     Except on E:Exception do
       raise Exception.Create('Webservice Error : ' +e.Message);
     end;
     dbm.gf.DoDebug.msg('POSMembership GetMembershipNo WebService Call ends.');
end;


//Add new Membership record
function TAxProvider.SavePOSMembershipDetails(XMLMemDetDoc : IXMLDocument;CallType,RemoteProject : String):String;
var
//    XMLMemDetDoc : IXMLDocument;
    XMLMemDetNode : IXMLNode;
    SaveDataResult : String;
begin
  dbm.gf.DoDebug.msg('SavePOSMembershipDetails starts.');
  try
    XMLMemDetNode := XMLMemDetDoc.DocumentElement;
    XMLMemDetNode.Attributes['axpapp'] := RemoteProject;
    XMLMemDetNode.Attributes['transid'] := 'custc';//sdef.Transid;
    XMLMemDetNode.Attributes['recordid'] := '0';//FloattoStr(StoreData.LastSavedRecordid);
    if lowercase(CallType) = 'remote' then begin
//      Result := RemoteSavePOSMembershipDetails(XMLMemDetDoc);
      exit;
    end;
  Except on E:Exception do
    begin
       result:='<error>'+e.Message+'</error>';
    end;
  end;
  dbm.gf.DoDebug.msg('SavePOSMembershipDetails ends.');
end;


//Add new Membership record
function TAxProvider.RemoteSavePOSMembershipDetails(rData : IXMLNode):String;
var
  i : integer;
begin
  axml := LoadXMLData('<root></root>') ;
  xnode :=axml.documentelement;
  xnode.attributes['axpapp'] := dbm.gf.AppName;
  xnode.attributes['sessionid'] := dbm.gf.sessionid;
  if dbm.gf.DoDebug.Active then
    xnode.Attributes['trace'] := 'true'
  else
    xnode.Attributes['trace'] := 'false';
  if rdata <> nil then xnode.ChildNodes.Add(rdata.CloneNode(True));
  axml.saveToXML(xmlstg);
  dbm.gf.DoDebug.msg('POSMembership SaveData WebService call starts.');
  try
    Result := (dbm.gf.POSHTTPRio as ASBARS).SaveData(axml.XML.Text);     //calls SaveData webservice
  Except on E:Exception do
    raise Exception.Create('Webservice Error : ' +e.Message);
  end;
  dbm.gf.DoDebug.msg('POSMembership SaveData WebService call ends.');
  xmlstg := s;
  if copy(s,1,7) = '<error>' then
  begin
    delete(s,1,7);
    msg := copy(s,1,pos('<',s)-1);
    delete(s,1,pos('>',s)+1);
    if dbm.gf.DoDebug.Active then
    begin
      showmessage(msg);
      with Tstringlist.Create do
      begin
        text := s;
        for i := 0 to count - 1 do
            dbm.gf.DoDebug.Msg(strings[i]);
        free;
      end;
    end else if copy(msg,1,1) <> '~' then  Showmessage(msg);
    result :=  xmlstg;
    exit ;
  end else
  begin
//    i := Length(s)-19;
//    delete(s,i,20);
    result :=  s;
  end;
  axml := nil;
end;

procedure TAxProvider.InsertIntoTransCheck;
begin
  xTransCheck.close;
  xTransCheck.sqltext := 'insert into Axp_TransCheck(sessionid) values ('+quotedstr(dbm.gf.d_sessionid)+')';
  xTransCheck.execsql;
end;

procedure TAxProvider.DeleteFromTransCheck;
begin
  dbm.gf.TransCheckCount := 0;
  xTransCheck.close;
  xTransCheck.sqltext := 'delete from Axp_TransCheck where sessionid = '+quotedStr(dbm.gf.d_sessionid);
  xTransCheck.execsql;
end;

Function TAxProvider.ValidateTransCheck:Boolean;
begin
  result := false;
  forcds.close;
  forcds.buffered := True;
  forcds.cds.CommandText:='select sessionid from Axp_TransCheck where sessionid = '+quotedStr(dbm.gf.d_sessionid);
  forcds.open;
  if forcds.CDS.RecordCount = dbm.gf.TransCheckCount then result := true;
  forcds.close;
end;

function TAxProvider.GetConfigValue(ConfigCDS:TXDS;Props,AsProps:String):String;
begin
  result := '';
  if not dbm.gf.ConfigTblFound then exit;
  if ConfigCDS = nil then exit;
  ConfigCDS.CDS.First;
  If (ConfigCDS.CDS.Locate('props;asprops',VarArrayOf([Props,AsProps]),[locaseinsensitive])) then begin
    result := ConfigCDS.CDS.FieldByName('propsval').AsString;
  end;
end;

function TAxProvider.GetStructureForScript(sname,name,caption,purpose: String): IXMLDocument;
var s,w,p:String;
  stm,cstm : TStringStream;
  sfile,tfile : String;
begin
  result:=LoadXMLData('<root></root>');
  p := '';
  if name='' then
  begin
     w := 'caption= :name ';
     p := caption ;
  end else
  begin
     w := dbm.gf.sqllower+'(name)= :name ';
     p := lowercase(name);
  end;
    s :='';
    stm := TStringStream.Create(s);
    dbm.ReadMemo('props', sname, w, p,'c', stm);
    if stm.Size=0 then result:=LoadXMLData('<root/>')
    else begin
        if sname='tstructs' then
        begin
          cstm := TStringStream.Create('');
          stm.Position := 0;
          with TCompress.Create do begin
            cstm := DecompressStream(stm);
            destroy;
          end;
          cstm.Position := 0;
          result := LoadXMLDataFromWS(trim(cstm.DataString)) ;
          cstm.Free;
          result := CheckProduct(name,result);
        end
        else result:=LoadXMLDataFromWS(trim(stm.DataString));
    end;
    dbm.gf.DoDebug.Msg('Step5');
    stm.Free;

    if sname = 'printprops' then
    begin
       s := ExtractFileName(Result.DocumentElement.Attributes['filename']);
       if GetStructName = '' then
         GetPrintTemplate('printprops',name,s)
       else
         GetPrintTemplate('printprops',GetStructName,s);
    end;
end;

end.



